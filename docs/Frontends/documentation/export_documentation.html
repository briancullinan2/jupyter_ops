<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>export documentation</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
    }

    body {
      padding-left: 200px;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <a href="../documentation/index.html">documentation</a>
    <br /><br />
    <a href="./convert_notebook_to_open_api.html">convert notebook to open api</a>
<br /><br />
<a href="./test_convert_notebook_api.html">test convert notebook api</a>
<br /><br />
<a href="./convert_google_discovery_to_documentation.html">convert google discovery to documentation</a>
<br /><br />
<a href="./discover_well-known_apis.html">discover well-known apis</a>
<br /><br />
<a href="./export_documentation.html">export documentation</a>
<br /><br />
<a href="./highlight_js.html">highlight js</a>
<br /><br />
<a href="./javadoc_template.html">javadoc template</a>
<br /><br />

  </nav>
  <header>
    <a href="../documentation/index.html">documentation</a> ${PREV} ${NEXT}
  </header>

  <p>Here is a summary of the provided code breakdown in two sentences:</p>
<p>The code requires several modules for file system interactions, path manipulation, importing functions, and Markdown rendering, and defines constants and functions for exporting content from Jupyter notebooks. It appears to be part of a larger project for generating documentation from notebooks, but has several TODOs and unclear sections that need implementation and clarification.</p>


<pre class="javascript"><code>const fs = require('fs')
const path = require('path')
const { functionCache } = importer.import('cache rpc functions with llm descriptions')
const { storeAllLlamaFunctions } = importer.import('store all notebook llm functions')
const { listInProject } = importer.import('list project files');
const { askLlamaAboutCode } = importer.import('ask llm about code')
const { askLlamaToSummerize, askLlamaToGeneralize } = importer.import('ask llm to summerize')
const {cacheCells} = importer.import('cache notebook')
const {safeurl} = importer.import('domain cache tools')
const {Remarkable} = require('remarkable');
const md = new Remarkable({html: true, xhtmlOut: true, breaks: true});

const PROJECT_PATH = path.resolve(path.join(path.dirname(__dirname), 'docs'))

async function exportAll(query) {
  // await storeAllLlamaFunctions()
  if(!fs.existsSync(PROJECT_PATH)) {
    fs.mkdirSync(PROJECT_PATH)
  }

  // TODO: get a list of all notebooks
  let notebooks = listInProject(path.resolve(__dirname, '../'), '{,*,*/,*/*/*,*/*/*/*}*.ipynb')

  let languageTemplate = importer.interpret('highlight js')
  let javadocTemplate = importer.interpret('javadoc template')

  // TODO: generate an index page that describes the index.js and __init__.py loaders

  let results = {}
  const intro = path.join(PROJECT_PATH, 'index.html')
  results[intro] = {
    output: '',
    indexOutput: '',
    title: 'Categories',
    parent: ''
  }

  let categories = []
  let namespaces = {}
  for (let i = 0; i < notebooks.length; i++) {
    // TODO: output folders and pages for every namespace and notebook
    const relative = path.relative(path.resolve(__dirname, '../'), notebooks[i])
    let category = relative.split(path.sep)[0]
    if(category.endsWith('.ipynb')) {
      category = 'Introduction'
    }

    if(!categories.includes(category)) {
      categories.push(category)
      results[intro].output += '<a href="./' +  category + '/index.html">' + category + '</a>' + '\n<br /><br />\n'
      results[intro].indexOutput += '<a href="../' +  category + '/index.html">' + category + '</a>' + '\n<br /><br />\n'
    }

    if (!fs.existsSync(path.join(PROJECT_PATH, category))) {
      fs.mkdirSync(path.join(PROJECT_PATH, category))
    }

    const catpath = path.join(PROJECT_PATH, category, 'index.html')
    if(typeof results[catpath] == 'undefined') {
      results[catpath] = {
        output: '',
        indexOutput: '',
        title: category
      }
      results[catpath].index = intro
      results[catpath].parent = '<a href="../index.html">Categories</a>'
    }


    const namespace = path.basename(notebooks[i]).replace('.ipynb', '')
    const fullpath = path.join(PROJECT_PATH, category, safeurl(namespace))
    if (!fs.existsSync(fullpath)) {
      fs.mkdirSync(fullpath)
    }

    results[catpath].output += '<a href="./' +  safeurl(namespace) + '/index.html">' + namespace + '</a>' + '\n<br /><br />\n'
    results[catpath].indexOutput += '<a href="../' +  safeurl(namespace) + '/index.html">' + namespace + '</a>' + '\n<br /><br />\n'
    let index = path.join(fullpath, 'index.html')
    results[index] = {
      output: '',
      indexOutput: '',
      title: namespace
    }
    results[index].index = catpath
    results[index].parent = '<a href="../../' +  category + '/index.html">' + category + '</a>'

    namespaces[relative] = []

    const newCache = cacheCells(notebooks[i])

    for(let j = 0; j < newCache.length; j++) {
      let cellname = newCache[j].questions[0]
      if(!cellname) {
        cellname = 'cell_' + j
      } else {
        cellname = safeurl(cellname)
      }
      let key = path.join(fullpath, cellname + '.html')
      results[key] = {
        output: '\n\n<pre class="' + newCache[j].language + '"><code>' + newCache[j].code + '</code></pre>\n\n'
      }
      results[key].output += languageTemplate.code.replaceAll('${LANGUAGE}', newCache[j].language)

      let title = newCache[j].questions[0]
      if(!title) {
        title = 'Cell ' + j
      }
      results[key].index = index
      results[key].title = title
      results[key].parent = '<a href="../' +  safeurl(namespace) + '/index.html">' + namespace + '</a>'
      results[index].output += '<a href="./' +  cellname + '.html">' + title + '</a>' + '\n<br /><br />\n'
      results[index].indexOutput += '<a href="./' +  cellname + '.html">' + title + '</a>' + '\n<br /><br />\n'

      const description = functionCache[notebooks[i] + '[' + j + ']']
      if(!description) {
        continue
      }

      results[index].output += md.render(description.summary)
      results[key].output = md.render(description.summary) + results[key].output
      results[key].output = results[key].output + md.render(description.description)
    }

    // TODO: generate parameter, return type descriptions
    

    // TODO: export all the markdown

  }


  const paths = Object.keys(results)
  for (let i = 0; i < paths.length; i++) {
    // TODO: add navigation and full template
    let output = javadocTemplate.code.replaceAll('${OUTPUT}', results[paths[i]].output)
    output = output.replaceAll('export documentation', results[paths[i]].title)
    output = output.replaceAll('<a href="../documentation/index.html">documentation</a>', results[paths[i]].parent)
    if(results[paths[i]].index)
      output = output.replaceAll('<a href="./convert_notebook_to_open_api.html">convert notebook to open api</a>
<br /><br />
<a href="./test_convert_notebook_api.html">test convert notebook api</a>
<br /><br />
<a href="./convert_google_discovery_to_documentation.html">convert google discovery to documentation</a>
<br /><br />
<a href="./discover_well-known_apis.html">discover well-known apis</a>
<br /><br />
<a href="./export_documentation.html">export documentation</a>
<br /><br />
<a href="./highlight_js.html">highlight js</a>
<br /><br />
<a href="./javadoc_template.html">javadoc template</a>
<br /><br />
', results[results[paths[i]].index].indexOutput)
    else
      output = output.replaceAll('<a href="./convert_notebook_to_open_api.html">convert notebook to open api</a>
<br /><br />
<a href="./test_convert_notebook_api.html">test convert notebook api</a>
<br /><br />
<a href="./convert_google_discovery_to_documentation.html">convert google discovery to documentation</a>
<br /><br />
<a href="./discover_well-known_apis.html">discover well-known apis</a>
<br /><br />
<a href="./export_documentation.html">export documentation</a>
<br /><br />
<a href="./highlight_js.html">highlight js</a>
<br /><br />
<a href="./javadoc_template.html">javadoc template</a>
<br /><br />
', '')
    fs.writeFileSync(paths[i], output)
  }

}

module.exports = exportAll
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

<script>hljs.highlightAll();</script>

<p><strong>Code Breakdown</strong></p>
<h3>Requires and Imports</h3>
<p>The code starts by requiring several modules:</p>
<ul>
<li><code>fs</code> (File System) for file system interactions</li>
<li><code>path</code> for path manipulation</li>
<li><code>importer</code> for importing functions from other modules</li>
<li><code>remarkable</code> for Markdown rendering</li>
</ul>
<h3>Constants and Function Definitions</h3>
<p>The code defines several constants and functions:</p>
<ul>
<li><code>PROJECT_PATH</code>: the path to the project directory</li>
<li><code>md</code>: an instance of <code>Remarkable</code> for Markdown rendering</li>
<li><code>exportAll(query)</code>: an asynchronous function for exporting content</li>
</ul>
<h3>ExportAll Function</h3>
<p>The <code>exportAll</code> function does the following:</p>
<ol>
<li><strong>Create Project Directory</strong>: If the project directory does not exist, create it using <code>fs.mkdirSync</code>.</li>
<li><strong>Get Notebooks</strong>: List all notebooks in the project directory using <code>listInProject</code>.</li>
<li><strong>Initialize Results Object</strong>: Create a results object to store the generated content.</li>
<li><strong>Loop Through Notebooks</strong>:
<ul>
<li>Get the relative path of the notebook.</li>
<li>Extract the category from the relative path.</li>
<li>If the category is not already in the <code>categories</code> array, add it and generate a link to the category page.</li>
<li>Create a directory for the category if it does not exist.</li>
<li>Generate an index page for the category (not implemented).</li>
</ul></li>
<li><strong>Generate Index Page</strong>: Generate an index page for the project directory (not implemented).</li>
</ol>
<h3>TODOs and Unclear Code</h3>
<p>The code has several TODOs and unclear sections:</p>
<ul>
<li>Implement generating index pages for categories and projects.</li>
<li>Implement generating links to specific notebooks.</li>
<li>Clarify the purpose of the <code>query</code> parameter in the <code>exportAll</code> function.</li>
<li>Unclear how the <code>cacheCells</code> and <code>safeurl</code> functions are used.</li>
</ul>
<p>Overall, the code appears to be part of a larger project for generating documentation from Jupyter notebooks.</p>

</body>

</html>