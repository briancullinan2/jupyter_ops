<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>antlr tree visitor</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    html {
      padding: 0;
      margin: 0;
    }

    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
      padding: 10px;
    }

    body {
      padding: 0 0 0 200px;
      margin: 0;
    }

    .gold pre code,
    .gold pre code span,
    .gold code pre,
    .gold code pre span {
      color: gold;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <h3><a href="../antlr/index.html">antlr</a></h3>
    <a href="./cell_0.html">Cell 0</a>
<br /><br />
<a href="./select_antlr_tree.html">select antlr tree</a>
<br /><br />
<a href="./test_select_jison_on_some_quake_3_C_code.html">test select jison on some quake 3 C code</a>
<br /><br />
<a href="./get_antlr_tool.html">get antlr tool</a>
<br /><br />
<a href="./antlr_to_html.html">antlr to html</a>
<br /><br />
<a href="./antlr_tree_visitor.html">antlr tree visitor</a>
<br /><br />
<a href="./cell_6.html">Cell 6</a>
<br /><br />
<a href="./cell_7.html">Cell 7</a>
<br /><br />
<a href="./antlr_tree_to_es.html">antlr tree to es</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./cell_10.html">Cell 10</a>
<br /><br />
<a href="./ext_to_lang.html">ext to lang</a>
<br /><br />
<a href="./generate_antlr_parsers.html">generate antlr parsers</a>
<br /><br />

  </nav>
  <header>
    <a href="../antlr/index.html">antlr</a> | <a href="./antlr_to_html.html">antlr to html</a> | <a href="./cell_6.html">Cell 6</a> | <a href="../../search.html">Search</a>
  </header>

  <p>This code defines four functions for working with Abstract Syntax Trees (ASTs) generated by the ANTLR4TS parser generator, including functions for converting object types to strings, creating generic tokens and contexts, and generating generic visitors. The code exports a module containing a generic visitor function.</p>
<h2>Run example</h2>

<pre language="bash"><code>npm run import -- "antlr tree visitor"</code></pre><h1>antlr tree visitor</h1>



<pre class="javascript"><code>var {Interval} = require('antlr4ts/misc')

function typeToString(node) {
    if(node === 'object' &amp;&amp; node) {
        return Object.getPrototypeOf(node).constructor.name;
    } else {
        return typeof node;
    }
}

function getGenericToken(parser, token) {
    if(!token) return
    return {
        type: 'TerminalNode',
    //    type2: parser.ruleNames[child._stop._type],
        value: token.source.stream.getText(Interval.of(token.start, token.stop)),
        range: [token.start, token.stop]
    }
}

function getGenericContext(ctx) {
    var exclude = [
        'constructor',
        'ruleIndex',
        'enterRule',
        'exitRule',
        'accept'
    ]
    var allTokens = Object.getOwnPropertyNames(Object.getPrototypeOf(ctx))
        .filter(t =&gt; exclude.indexOf(t) === -1)
    return allTokens.reduce((obj, cur) =&gt; {
        obj[cur] = ctx[cur]()
        return obj
    }, {})
}


function getGenericVisitor({parser, visitor}) {
    function GenericVisitor() {
    //    visitor.apply(this, arguments)
    }
    GenericVisitor.prototype = Object.create(visitor.prototype)
    GenericVisitor.prototype.constructor = GenericVisitor
    GenericVisitor.prototype.defaultResult = function () {
        return {children: []}
    }
    GenericVisitor.prototype.aggregateResult = (ctx, child) =&gt; {
        if(!Array.isArray(ctx)) ctx = ctx.children
        ctx[ctx.length] = child
        return ctx
    }
    GenericVisitor.prototype.visit = function (tree) {
        return tree.accept(this)
    }
    // TODO: combine range with return valuess
    GenericVisitor.prototype.visitTerminal = function (node) {
        return getGenericToken(parser, node._symbol)
    }
    GenericVisitor.prototype.visitChildren = function (ctx) {
        var result = visitor.prototype.visitChildren.apply(this, [ctx])
        return {
            type: Object.getPrototypeOf(ctx).constructor.name,
            children: result
        }
    }
    return {
        GenericVisitor
    }
}

module.exports = getGenericVisitor
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="../../mergehtml.js"></script>

<script>
hljs.addPlugin(mergeHTMLPlugin);
hljs.highlightAll();
</script>

<div class="gold"><h2>What the code could have been:</h2>
<pre class="javascript"><code>const { Interval } = require('antlr4ts/misc');

/**
 * Returns the string representation of the provided node type.
 * If the node is an object, it returns the constructor name of the object's prototype.
 * Otherwise, it returns the type of the node.
 *
 * @param {object|string} node - The node to get the type string for.
 * @returns {string} The type string of the node.
 */
function typeToString(node) {
  return Object.prototype.toString.call(node).replace(/\[object\s/, '').replace(/\]/, '');
}

/**
 * Returns a generic token object from the provided parser and token.
 * If the token is null or undefined, it returns null.
 *
 * @param {object} parser - The parser to get the token from.
 * @param {object} token - The token to get the generic token object for.
 * @returns {object|null} The generic token object, or null if the token is null or undefined.
 */
function getGenericToken(parser, token) {
  if (!token) return null;
  return {
    type: 'TerminalNode',
    value: token.source.stream.getText(Interval.of(token.start, token.stop)),
    range: [token.start, token.stop]
  };
}

/**
 * Returns a generic context object from the provided context.
 * The generic context object includes all properties of the context that are not excluded.
 *
 * @param {object} ctx - The context to get the generic context object for.
 * @returns {object} The generic context object.
 */
function getGenericContext(ctx) {
  const exclude = [
    'constructor',
    'ruleIndex',
    'enterRule',
    'exitRule',
    'accept'
  ];
  return Object.getOwnPropertyNames(Object.getPrototypeOf(ctx))
   .filter((property) =&gt; exclude.indexOf(property) === -1)
   .reduce((obj, property) =&gt; {
      obj[property] = ctx[property] &amp;&amp; typeof ctx[property] === 'function'? ctx[property]() : ctx[property];
      return obj;
    }, {});
}

/**
 * Returns a generic visitor object from the provided parser and visitor.
 * The generic visitor object includes a visit method that calls the accept method on the provided tree,
 * and a visitTerminal method that returns a generic token object.
 *
 * @param {object} options - The options object with parser and visitor properties.
 * @param {object} options.parser - The parser to get the generic token object from.
 * @param {object} options.visitor - The visitor to create a generic visitor from.
 * @returns {object} The generic visitor object.
 */
function getGenericVisitor({ parser, visitor }) {
  class GenericVisitor extends visitor.constructor {
    constructor(...args) {
      super(...args);
    }

    defaultResult() {
      return { children: [] };
    }

    aggregateResult(ctx, child) {
      if (!Array.isArray(ctx)) ctx = ctx.children;
      ctx.push(child);
      return ctx;
    }

    visit(tree) {
      return tree.accept(this);
    }

    visitTerminal(node) {
      return getGenericToken(parser, node._symbol);
    }

    visitChildren(ctx) {
      const result = visitor.constructor.prototype.visitChildren.apply(this, [ctx]);
      return {
        type: Object.prototype.toString.call(ctx).replace(/\[object\s/, '').replace(/\]/, ''),
        children: result
      };
    }
  }

  return { GenericVisitor };
}

module.exports = getGenericVisitor;</code></pre></div><p><strong>Overview</strong></p>
<p>This code defines several functions for working with Abstract Syntax Trees (ASTs) generated by the ANTLR4TS parser generator.</p>
<h3>Function 1: <code>typeToString</code></h3>
<p>This function takes an object as input and returns its type as a string. If the input is an object, it returns the name of the constructor it inherits from. Otherwise, it returns the type of the input using <code>typeof</code>.</p>
<h3>Function 2: <code>getGenericToken</code></h3>
<p>This function takes a parser and a token as input and returns a generic token object. If the token is null or undefined, it returns null. Otherwise, it returns an object with the following properties:</p>
<ul>
<li><code>type</code>: set to <code>'TerminalNode'</code></li>
<li><code>value</code>: the text of the token's source stream, extracted using <code>ANTLR4TS.misc.Interval</code></li>
<li><code>range</code>: an array representing the start and stop positions of the token</li>
</ul>
<h3>Function 3: <code>getGenericContext</code></h3>
<p>This function takes a context object as input and returns an object with all its properties. It excludes certain properties (e.g., <code>constructor</code>, <code>ruleIndex</code>) from the output.</p>
<h3>Function 4: <code>getGenericVisitor</code></h3>
<p>This function takes an object with <code>parser</code> and <code>visitor</code> properties as input and returns a generic visitor object. The visitor object has several methods:</p>
<ul>
<li><code>defaultResult</code>: returns an object with an empty array as its <code>children</code> property</li>
<li><code>aggregateResult</code>: appends a child node to the <code>children</code> array of the current context</li>
<li><code>visit</code>: calls the <code>accept</code> method on the current tree with the visitor as an argument</li>
<li><code>visitTerminal</code>: calls <code>getGenericToken</code> to get the token object for a terminal node</li>
<li><code>visitChildren</code>: calls the <code>visitChildren</code> method on the visitor's <code>prototype</code> and returns an object with the type of the current context and its children</li>
</ul>
<p>The <code>getGenericVisitor</code> function returns an object with the generic visitor as its only property.</p>
<h3>Export</h3>
<p>The code exports the <code>getGenericVisitor</code> function as a module.</p>

</body>

</html>