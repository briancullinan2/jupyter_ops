

<pre><code>
// make sure this format works both directions
// from PHP to javascript
var fromPhpToJavascropt = {
    '//CallExpression[@name="array_shift"]': {
        
    }
}

var fromJavascriptToPhp = {
    
}

var phpToJs = [
    [() => array_shift(arr), () => arr.shift()],
    [() => strpos(str, match), () => { // has parameters so call this function instead?
        var i = str.indexOf(match);
        return i > -1 ? i : false}],
    [() => substr(str, start, length), () => str.substr(start, length)],
    [() => is_numeric(num), () => !isNaN(parseInt(num)) || !isNaN(parseFloat(num))],
    [() => abs(), () => Math.abs()], // doesn't mess with parameters
    // Call Identifier name match done automatically
    //[['abs', 'sin', 'cos', 'pow', 'floor', 'ceil', 'round', 'max', 'min'], {
    //    `//*[contains(@type, "Call")`: (id) => Math.id(), // optional ()
    //}]
    // above is shorthand for this:
    [(id = ['abs', 'sin', 'cos',
            'pow', 'floor', 'ceil',
            'round', 'max', 'min']) => id(), {
                '//*[contains(@type, "Call")': (id) => Math.id(), // optional ()
    }],

]

// this will work as long as PHP syntax is also called a Call or Member or Indentifier
var jsToPhp = phpToJs.map(d => [d[1], d[0]])
</code></pre>

