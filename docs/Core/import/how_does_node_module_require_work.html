<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>how does node module require work</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    html {
      padding: 0;
      margin: 0;
    }

    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
      padding: 10px;
    }

    body {
      padding: 0 0 0 200px;
      margin: 0;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <h3><a href="../import/index.html">import</a></h3>
    <a href="./import_notebook.html">import notebook</a>
<br /><br />
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<a href="./cell_13.html">Cell 13</a>
<br /><br />

  </nav>
  <header>
    <a href="../import/index.html">import</a> | <a href="./import_notebook.html">import notebook</a> | <a href="./cell_2.html">Cell 2</a> | <a href="../../search.html">Search</a>
  </header>

  <p>The <code>getCached</code> function checks if a cached version of a module exists at a given filepath and returns it if it's newer than the current file's modification time. The <code>makeModule</code> function creates or retrieves a module based on the given path and global context, using caching to reuse existing modules and store new ones for future use.</p>
<h2>Run example</h2>

<pre language="bash"><code>npm run import -- "how does node module require work"</code></pre><h1>how does node module require work</h1>



<pre class="javascript"><code>const Module = require('module').Module
const path = require('path')
const fs = require('fs')

function getCached(filepath) {
    // must have a new name for every generation otherwise cache will be returned
    var mtime = fs.statSync(filepath
        // TODO: find a better way to serve notebook names
        .replace(/\.ipynb(\[[0-9]+\]).*$/ig, '.ipynb')).mtime.getTime();

    // TODO: don't use cache of parent modules that have includes that have changed
    var cachedModule = Module._cache[filepath];
    if (cachedModule &amp;&amp; mtime &lt; cachedModule.buildTime) {
        return cachedModule;
    }
}

function makeModule(code, pathToCode, ctxGlobal) {
    const {CONSOLE} = require('../Core')
    var filepath = path.resolve(process.cwd(), pathToCode);

    ctxGlobal = ctxGlobal || {}
    ctxGlobal.module = getCached(filepath)
    if (ctxGlobal.module) {
        if (!ctxGlobal.module.loaded) {
            return ((module) =&gt; new Promise(resolve =&gt; {
                let inter = setInterval(() =&gt; {
                    if (module.loaded) {
                        clearInterval(inter)
                        resolve()
                    }
                }, 100)
            }).then(() =&gt; module.exports))(ctxGlobal.module)
        }
        return ctxGlobal.module.exports
    }
    delete require.cache[filepath]
    Object.assign(ctxGlobal, {
        importer: require('../Core'),
        module: new Module(filepath, module),
        exports: { original: true },
        __dirname: path.dirname(pathToCode),
        __filename: pathToCode.split('[')[0],
        $: void 0,
        console: CONSOLE,
        global: ctxGlobal,
        //require: require,
    })
    Object.assign(ctxGlobal.module, {
        module: ctxGlobal.module,
        exports: ctxGlobal.exports,
        parent: module,
        buildTime: (new Date()).getTime(),
        filename: pathToCode,
        paths: Module._nodeModulePaths(path.dirname(filepath))
    })
    Module._cache[filepath] = ctxGlobal.module;

    // this is basically the magic of the 'rewire' module, reuse this?
    const validVars = Object.keys(ctxGlobal)
        .filter(k =&gt; k.match(/^(\$\$|[a-z_][a-z0-9_]*)$/i))
        .join(',');

    if (!pathToCode.includes('Core')) {
        CONSOLE.info(`compiling ${pathToCode} with ${validVars}`);
    }

    // TODO: use the transpiler or kernels here
    try {
        ctxGlobal.module._compile(`
        module.exports = (({${validVars}}) =&gt; {
        ${code}
        return module.exports || exports || {}
        })`, filepath);

        // assign the actual imports internally by calling the func export
        var wrapperContext = ctxGlobal.module.exports;
        var result = wrapperContext(ctxGlobal);
        ctxGlobal.module.loaded = true;
        ctxGlobal.module.exports = result;
        return result;
    } catch (err) {
        if (err.code === 'ERR_REQUIRE_ESM') {
            const { makeESModule } = require('../Core')
            CONSOLE.error('ES module required', err)
            return makeESModule(code, filepath, ctxGlobal)
        } else {
            throw err
        }
    }
}

module.exports.makeModule = makeModule;
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="../../mergehtml.js"></script>

<script>
hljs.addPlugin(mergeHTMLPlugin);
hljs.highlightAll();
</script>

<p><strong>Code Breakdown</strong></p>
<h3>getCached Function</h3>
<pre><code class="language-javascript">function getCached(filepath) {
    //...
}
</code></pre>
<p>This function checks if there is a cached version of the module at the given <code>filepath</code>. It:</p>
<ol>
<li>Retrieves the last modification time (mtime) of the file.</li>
<li>Checks if a cached version of the module exists in the <code>Module._cache</code> object.</li>
<li>If a cached version exists and its build time is newer than the current file's mtime, it returns the cached version.</li>
</ol>
<h3>makeModule Function</h3>
<pre><code class="language-javascript">function makeModule(code, pathToCode, ctxGlobal) {
    //...
}
</code></pre>
<p>This function creates or retrieves a module based on the given <code>pathToCode</code> and <code>ctxGlobal</code> object. It:</p>
<ol>
<li>Resolves the <code>pathToCode</code> to an absolute filepath.</li>
<li>Checks if a cached version of the module exists using the <code>getCached</code> function.</li>
<li>If a cached version exists and is loaded, it returns the module's exports.</li>
<li>If the cached version is not loaded or doesn't exist, it creates a new module instance.</li>
<li>Configures the new module with various properties (e.g., <code>importer</code>, <code>module</code>, <code>exports</code>, etc.).</li>
<li>Stores the new module in the <code>Module._cache</code> object for future use.</li>
</ol>
<p>Note that this function also includes a TODO comment suggesting a potential optimization.</p>

</body>

</html>