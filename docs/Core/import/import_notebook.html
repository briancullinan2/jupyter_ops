<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>import notebook</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    html {
      padding: 0;
      margin: 0;
    }

    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
      padding: 10px;
    }

    body {
      padding: 0 0 0 200px;
      margin: 0;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <h3><a href="../import/index.html">import</a></h3>
    <a href="./import_notebook.html">import notebook</a>
<br /><br />
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<a href="./cell_13.html">Cell 13</a>
<br /><br />

  </nav>
  <header>
    <a href="../import/index.html">import</a> |  | <a href="./how_does_node_module_require_work.html">how does node module require work</a> | <a href="../../search.html">Search</a>
  </header>

  <p>The <code>getCellPath(cell)</code> function generates a unique file path for a cell in a notebook by appending the cell ID and question (if present) to the notebook directory. The <code>importNotebook(notebook, ctx = {})</code> function imports a notebook and returns an object containing modules for each cell in the notebook, created using language-specific functions.</p>
<h2>Run example</h2>

<pre language="bash"><code>npm run import -- "import notebook"</code></pre><h1>import notebook</h1>



<pre class="javascript"><code>var path = require('path');

// TODO: combine with id2 from rpc and nicename from notebook export
// TODO: insert niceName and getExports here?
// must have a unique id for each unique cell so that
// individual cells can serve as modules as well as notebooks
// adding the cell id as a part of the filename
function getCellPath(cell) {
    var question = cell.questions &amp;&amp; cell.questions[0]
        ? (' aka ' + cell.questions[0].substr(0, 50))
        : ''
    return path.join(path.dirname(path.resolve(cell.filename)), cell.id) + question
}

const ACCUMULATOR = {
    info: [],
    error: [],
    log: [],
}

const CONSOLE = {
    info: function (...args) {
        ACCUMULATOR.info.push(args.map(a =&gt; String(a)).join(' '))
        console.info(...args)
    },
    error: function (...args) {
        ACCUMULATOR.error.push(args.map(a =&gt; String(a)).join(' '))
        console.error(...args)
    },
    log: function (...args) {
        ACCUMULATOR.log.push(args.map(a =&gt; String(a)).join(' '))
        console.log(...args)
    },
}

// How to test if a notebook has already been imported
function importNotebook(notebook, ctx = {}) {
    var {interpret, makeModule, makeESModule, makeDylib, makeDLL, makePythonModule} = require('../Core')
    // accept all arguments as the list of queries
    if(arguments.length &gt; 2) {
        notebook = Array.from(arguments)
        if(typeof arugments[arguments.length - 1] === 'object'
          &amp;&amp; !Array.isArray(arugments[arguments.length - 1])) {
            notebook = notebook.slice(0, arguments.length - 1)
            ctx = arugments[arguments.length - 1]
        }
    }

    if (typeof notebook === 'undefined') {
        return Promise.resolve({})
    }
    
    // TODO: move this sort of thing to cache
    var cells = interpret(notebook)
    
    if(typeof cells.code !== 'undefined') {
        if(!cells.filename.includes('Core')) {
            CONSOLE.log(`importing ${notebook} - 1 cell - ${cells.id}`)
        }

        if(cells.language == 'python') {

            return makePythonModule(cells.source.join(''),
                cells.id,
                ctx)

        } else

        if(cells.language == 'csharp') {

            return makeDLL(cells.source.join(''), cells.id)

        } else

        if(cells.language == 'c' || cells.language == 'cpp' || cells.language == 'objective-c') {

            return makeDylib(cells.source.join(''), cells.id)

        } else

        if (!cells.filename.match(/Core\//gi) &amp;&amp; !cells.filename.match(/cache/gi) 
            &amp;&amp; cells.source.join('').match(/^import\s|^export\s/gmi)
        ) {
            CONSOLE.error('ES module matched')
            return Promise.resolve(makeESModule(cells.source.join(''), cells.filename, ctx))
        } else
        
        return makeModule(cells.source.join(''),
                          getCellPath(cells),
                          ctx)
    }
    
    CONSOLE.log(`importing ${notebook} - ${cells.length} cells - ${cells.map(c =&gt; c.id)}`)
    var package = {}

    for(let i = 0; i &lt; cells.length; i++) {

        let result

        if(cells.language == 'python') {

            result = makePythonModule(cells[i].source.join(''),
                cells[i].id,
                ctx)

        } else

        if(cells[i].language == 'csharp') {

            result = makeDLL(cells[i].source.join(''), cells[i].id)

        } else

        if(cells[i].language == 'c' || cells[i].language == 'cpp' || cells[i].language == 'objective-c') {

            result = makeDylib(cells[i].source.join(''), cells[i].id)

        } else
        if (!cells[i].filename.match(/Core\//gi) &amp;&amp; !cells[i].filename.match(/cache/gi) 
            &amp;&amp; cells[i].source.join('').match(/^import\s|^export\s/gi)
        ) {
            result = Promise.resolve(makeESModule(cells[i].source.join(''), cells[i].filename, ctx))
        } else
            result = makeModule(cells[i].source.join(''),
                                      getCellPath(cells[i]),
                                      ctx)

        if(typeof result === 'object') {
            // TODO: handle promises and merge them if they are objects?
            if(typeof result[Object.keys(result)[0]] === 'function') {
                const func = result[Object.keys(result)[0]]
                package[cells[i].id] = func
                package[func.name] = func
            }
            Object.assign(package, result)
        }
        if (typeof result === 'function') {
            package[cells[i].id] = result
            package[result.name] = result
        }
        package[i] = result
        Object.assign(ctx, package)
    }

    return package
}

module.exports.importNotebook = importNotebook;
module.exports.import = importNotebook;
module.exports.CONSOLE = CONSOLE
module.exports.ACCUMULATOR = ACCUMULATOR</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>

<script>hljs.highlightAll();</script>

<h1><strong>Function Breakdown</strong></h1>
<h3>getCellPath(cell)</h3>
<p>This function generates a unique file path for a cell in a notebook.</p>
<ul>
<li>It takes a single argument <code>cell</code>, which is expected to have the following properties:
<ul>
<li><code>filename</code>: the path to the notebook file</li>
<li><code>id</code>: a unique identifier for the cell</li>
<li><code>questions</code>: an array of questions, which is used to generate a string to append to the file path</li>
</ul></li>
<li>It returns a string representing the file path, with the cell ID and question (if present) appended to the notebook directory.</li>
</ul>
<h3>importNotebook(notebook, ctx = {})</h3>
<p>This function imports a notebook and returns a promise that resolves to an object.</p>
<ul>
<li>It takes two arguments:
<ul>
<li><code>notebook</code>: the notebook to import, which can be a single notebook or an array of notebooks</li>
<li><code>ctx</code>: an optional object containing context information</li>
</ul></li>
<li>It checks if <code>notebook</code> is <code>undefined</code> and returns an empty object if so.</li>
<li>It uses the <code>interpret</code> function to get the cells in the notebook.</li>
<li>It then checks the language of each cell and calls the corresponding function to create a module:
<ul>
<li>For Python cells, it calls <code>makePythonModule</code>.</li>
<li>For C# cells, it calls <code>makeDLL</code>.</li>
<li>For C, C++, or Objective-C cells, it calls <code>makeDylib</code>.</li>
<li>If the language is unknown, it logs a message and returns an empty object.</li>
</ul></li>
</ul>
<p><strong>Notes</strong></p>
<ul>
<li>The function assumes that the <code>interpret</code> function returns an object with a <code>code</code> property that contains the cell's source code.</li>
<li>The <code>makePythonModule</code>, <code>makeDLL</code>, and <code>makeDylib</code> functions are not defined in this code snippet, but they are expected to take the cell's source code, ID, and context as arguments.</li>
<li>The function logs a message when importing a notebook with a single cell that is not in the <code>Core</code> directory.</li>
</ul>

</body>

</html>