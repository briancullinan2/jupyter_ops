<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>compile an es module</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    html {
      padding: 0;
      margin: 0;
    }

    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
      padding: 10px;
    }

    body {
      padding: 0 0 0 200px;
      margin: 0;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <h3><a href="../import/index.html">import</a></h3>
    <a href="./import_notebook.html">import notebook</a>
<br /><br />
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<a href="./cell_13.html">Cell 13</a>
<br /><br />

  </nav>
  <header>
    <a href="../import/index.html">import</a> | <a href="./cell_2.html">Cell 2</a> | <a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
  </header>

  <p>The code imports dependencies and defines an asynchronous <code>makeESModule</code> function that creates a virtual machine context and compiles code using the <code>vm</code> module. The function also defines a linker function that resolves and imports modules dynamically, allowing the code to be executed and exported as a virtual machine module.</p>
<h2>Run example</h2>

<pre language="bash"><code>npm run import -- "compile an es module"</code></pre><h1>compile an es module</h1>



<pre class="javascript"><code>const Module = require('module').Module
const path = require('path')
const vm = require('vm')

async function makeESModule(code, filename, context) {
  const filepath = path.resolve(process.cwd(), filename);
  const {CONSOLE} = require('../Core')

  if (typeof Module._cache[filepath] != 'undefined') {
    if (Module._cache[filepath].namespace.default) {
      return Module._cache[filepath].namespace.default
    }
    return Module._cache[filepath].namespace
  }

  context = context || {}
  Object.assign(context, {
    importer: require('../Core'),
    __dirname: path.dirname(filename),
    __filename: filename.split('[')[0],
    global: context,
    console: CONSOLE,
  })
  const vmModule = new vm.SourceTextModule(code, {
      identifier: filename,
      context: await vm.createContext(context),
      initializeImportMeta(meta) {
          meta.url = filename
      },
      // @ts-expect-error: wrong type definition
      async importModuleDynamically(specifier) {
          return await import(resolveModuleSpecifier(specifier, dirname))
      }
  })
  context['__INTERNAL_IMPORTS_FROM_STRING'] = {}
  Module._cache[filepath] = vmModule;
  Module._cache[filepath].exports = {}
  
  if (!filename.includes('Core')) {
    CONSOLE.info(`compiling ES ${filename} with ${Object.keys(context)}`);
  }

  const linker = async (specifier) =&gt; {
      const resolvedSpecifier = specifier //resolveModuleSpecifier(specifier, dirname)
      const targetModule = await import(resolvedSpecifier)
      context['__INTERNAL_IMPORTS_FROM_STRING'][specifier] = targetModule

      const stringifiedSpecifier = JSON.stringify(specifier)
      const exportedNames = Object.keys(targetModule)
      const targetModuleContent = `${exportedNames.includes('default')
              ? `export default __INTERNAL_IMPORTS_FROM_STRING[${stringifiedSpecifier}].default;\n`
              : ''
          }export const { ${exportedNames
              .filter(exportedName =&gt; exportedName !== 'default')
              .join(', ')} } = __INTERNAL_IMPORTS_FROM_STRING[${stringifiedSpecifier}];`

      return new vm.SourceTextModule(targetModuleContent, {
          identifier: resolvedSpecifier,
          context
      })
  }

  await vmModule.link(linker)
  await vmModule.evaluate()
  Object.assign(Module._cache[filepath].exports, vmModule.namespace.default)
  Module._cache[filepath].loaded = true
  if (vmModule.namespace.default) {
      return vmModule.namespace.default
  }
  return vmModule.namespace
}

module.exports.makeESModule = makeESModule
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>

<script>hljs.highlightAll();</script>

<p><strong>Code Breakdown</strong></p>
<h3>Importing Dependencies</h3>
<p>The code starts by importing the required modules:</p>
<ul>
<li><code>Module</code> from the built-in <code>module</code> module</li>
<li><code>path</code> module for working with file paths</li>
<li><code>vm</code> module for working with virtual machines</li>
</ul>
<h3>makeESModule Function</h3>
<p>The <code>makeESModule</code> function is an asynchronous function that takes three parameters:</p>
<ul>
<li><code>code</code>: The code to be executed</li>
<li><code>filename</code>: The filename of the code</li>
<li><code>context</code>: An optional context object</li>
</ul>
<h3>File Caching</h3>
<p>The code checks if a module with the given <code>filename</code> is already cached in the <code>Module._cache</code> object. If it is, the cached module is returned.</p>
<h3>Creating a Virtual Machine Context</h3>
<p>If the module is not cached, a new virtual machine context is created using <code>vm.createContext</code>. The context is initialized with the following properties:</p>
<ul>
<li><code>importer</code>: a reference to the <code>../Core</code> module</li>
<li><code>__dirname</code>: the directory path of the current file</li>
<li><code>__filename</code>: the filename of the current file</li>
<li><code>global</code>: a reference to the global object</li>
</ul>
<h3>Creating a Virtual Machine Module</h3>
<p>A new virtual machine module is created using <code>vm.SourceTextModule</code>. The module is configured with the following properties:</p>
<ul>
<li><code>identifier</code>: the filename of the code</li>
<li><code>context</code>: the virtual machine context created earlier</li>
<li><code>initializeImportMeta</code>: a function that sets the <code>url</code> property of the import meta object</li>
<li><code>importModuleDynamically</code>: an asynchronous function that imports a module dynamically using the <code>import</code> function</li>
</ul>
<h3>Compiling the Code</h3>
<p>The code is compiled using the virtual machine module. If the filename does not include &quot;Core&quot;, a message is logged to the console indicating that the code is being compiled.</p>
<h3>Defining a Linker Function</h3>
<p>A linker function is defined that takes a specifier (a module name) as input. The linker function:</p>
<ul>
<li>Resolves the specifier using a function called <code>resolveModuleSpecifier</code></li>
<li>Imports the specified module using the <code>import</code> function</li>
<li>Stores the imported module in the <code>__INTERNAL_IMPORTS_FROM_STRING</code> object</li>
<li>Creates a string that exports the imported module's properties</li>
<li>Returns a new virtual machine module that exports the imported module's properties.</li>
</ul>
<h3>Returning the Module</h3>
<p>The compiled module is stored in the <code>Module._cache</code> object and returned.</p>

</body>

</html>