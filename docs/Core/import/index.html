<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>import</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    html {
      padding: 0;
      margin: 0;
    }

    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
      padding: 10px;
    }

    body {
      padding: 0 0 0 200px;
      margin: 0;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <h3><a href="../../Core/index.html">Core</a></h3>
    <a href="../aspects/index.html">aspects</a>
<br /><br />
<a href="../cache/index.html">cache</a>
<br /><br />
<a href="../compile/index.html">compile</a>
<br /><br />
<a href="../files/index.html">files</a>
<br /><br />
<a href="../import/index.html">import</a>
<br /><br />
<a href="../intent/index.html">intent</a>
<br /><br />
<a href="../kernels/index.html">kernels</a>
<br /><br />
<a href="../languages/index.html">languages</a>
<br /><br />
<a href="../notebook/index.html">notebook</a>
<br /><br />
<a href="../patterns/index.html">patterns</a>
<br /><br />
<a href="../pyimport/index.html">pyimport</a>
<br /><br />
<a href="../rpc/index.html">rpc</a>
<br /><br />
<a href="../syntax/index.html">syntax</a>
<br /><br />

  </nav>
  <header>
    <a href="../../Core/index.html">Core</a> | <a href="../files/index.html">files</a> | <a href="../intent/index.html">intent</a>
  </header>

  <h1>import</h1>

<a href="./import_notebook.html">import notebook</a>
<br /><br />
<p>The <code>getCellPath(cell)</code> function generates a unique file path for a cell in a notebook by appending the cell ID and question (if present) to the notebook directory. The <code>importNotebook(notebook, ctx = {})</code> function imports a notebook and returns an object containing modules for each cell in the notebook, created using language-specific functions.</p>
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<p>The <code>getCached</code> function checks if a cached version of a module exists at a given filepath and returns it if it's newer than the current file's modification time. The <code>makeModule</code> function creates or retrieves a module based on the given path and global context, using caching to reuse existing modules and store new ones for future use.</p>
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<p>The <code>runPythonModule</code> function runs a Python module with given parameters, while the <code>makePythonModule</code> function creates and executes a Python module from provided code. A cache is used to store compiled Python modules and avoid recompilation, and notebook parameters are imported using the <code>importNotebook</code> function.</p>
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<p>The code imports dependencies and defines an asynchronous <code>makeESModule</code> function that creates a virtual machine context and compiles code using the <code>vm</code> module. The function also defines a linker function that resolves and imports modules dynamically, allowing the code to be executed and exported as a virtual machine module.</p>
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<p>This Node.js module builds and loads Dynamic Link Libraries (DLLs) from source code by interpreting, compiling, and caching DLLs based on source code changes. It utilizes various Node.js modules, custom modules, and notebooks to perform tasks such as interpreting source code, selecting ANTLR trees, and extracting class information.</p>
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<p>This JavaScript code generates dynamic libraries using functions <code>generateCallback</code> and <code>makeDylib</code>, which create callbacks for library functions and compile code into dynamic libraries, respectively. The code relies on external dependencies such as <code>ffi-rs</code> and a core module, and includes unclear or missing parts indicated by <code>TODO</code> comments.</p>
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<p>The code consists of two functions, <code>resultMarkdown</code> and <code>displayCell</code>, which convert arrays of results into strings in Markdown format. The <code>displayCell</code> function handles both single-cell and multi-cell results, reducing them into a single string using the <code>resultMarkdown</code> function.</p>
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<p>This code initializes and configures a database search system using Fuse.js or an alternative search function, creating two instances with tokenization enabled and disabled. It also exports functions to query the database with a search query and look up cells in the cache by their ID, allowing for seamless integration into other applications.</p>
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<p>The code initializes a cache by retrieving and caching cells from specified notebooks and creating a database, then defines the <code>interpret</code> function to process queries by filtering local files, searching notebooks, and querying the database. The <code>interpret</code> function checks if the cache has already been initialized and processes the queries accordingly, storing the results in the <code>searchResults</code> variable.</p>
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<p>This code provides four functions for filtering and searching Jupyter Notebook files (.ipynb) in a local environment, allowing users to search by filename, cell number, or query. The functions include <code>filterLocal</code>, <code>filterFilename</code>, <code>searchFiles</code>, and <code>searchQueryFiles</code>, which are exported as module exports for use in other applications.</p>
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<p>The <code>regexToArray</code> function takes a regular expression object, a string to search, and an optional parameter to customize the return value. It returns an array of matches based on the provided parameters, such as the start position and length of each match, all match groups, or a specific match group.</p>
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<p>The <code>runAllPromises</code> function executes an array of functions that return promises, resolving and concatenating the results of each promise chain into a single array.</p>
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<p>The <code>getCells</code> function extracts cells from a Jupyter Notebook file, filtering and mapping cells based on specified types, and returns an array of extracted cells with additional metadata. The function is exported as a module using <code>module.exports.getCells = getCells;</code>, making it available for use in other Node.js applications.</p>
<a href="./cell_13.html">Cell 13</a>
<br /><br />
<p>The <code>run</code> function is an asynchronous command-line tool that processes command-line arguments to execute a result's <code>apply</code> method, returning the result after execution.</p>
<p>The <code>run</code> function is an asynchronous command-line tool that processes command-line arguments and executes a result's <code>apply</code> method. It returns the result of the execution, unless the result is the global object, in which case it returns immediately.</p>

</body>

</html>