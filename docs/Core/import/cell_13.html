<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>Cell 13</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
    }

    body {
      padding-left: 200px;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <a href="../import/index.html">import</a>
    <br /><br />
    <a href="./import_notebook.html">import notebook</a>
<br /><br />
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<a href="./cell_13.html">Cell 13</a>
<br /><br />

  </nav>
  <header>
    <a href="../import/index.html">import</a> ${PREV} ${NEXT}
  </header>

  <p>Here is a summary of the <code>run</code> function in one sentence:</p>
<p>The <code>run</code> function is an asynchronous command-line tool that processes command-line arguments to execute a result's <code>apply</code> method, returning the result after execution.</p>
<p>Alternatively, here is a two-sentence summary:</p>
<p>The <code>run</code> function is an asynchronous command-line tool that processes command-line arguments and executes a result's <code>apply</code> method. It returns the result of the execution, unless the result is the global object, in which case it returns immediately.</p>


<pre class="javascript"><code>

async function run() {
    const {
        importNotebook, interpret
    } = require('../Core')
    const getParameters = await importNotebook('function parameters')
    //const cell = await interpret(process.argv[1])
    let result = await importNotebook(process.argv[1])
    console.log(result)
    // HACK to get C# working
    if(typeof result.functions != 'undefined') {
        result = result[result.functions[0]]
    }
    if(typeof result == 'object' && typeof result[Object.keys(result)[0]] == 'function') {
        result = result[Object.keys(result)[0]]
    }
    const params = typeof result.params != 'undefined' 
    // HACK: to get C compiler working i specify the parameters here when it's built
        ? result.params : (result.params = getParameters(result.toString()).slice(1)) //.concat(getParameters(cell.code).slice(1))
    console.log(params)
    let inputs = []
    try {
        inputs = eval(process.argv[2] || '[]')
    } catch (e) {
        inputs = []
    }
    if(!Array.isArray(inputs)) {
        inputs = [inputs]
    }
    for(let i = 0; i < process.argv.length; i++) {
        let a = process.argv[i]
        for(let j = 0; j < params.length; j++) {
            if(a.includes('--' + params[j])) {
                if(a.includes('=')) {
                    inputs[j] = a.split('=')[1]
                } else {
                    inputs[j] = process.argv[i+1]
                    i++
                }
                if(result.types && typeof inputs[j] != 'number') {
                    if(result.types[j+1] == 'int') {
                        inputs[j] = parseInt(inputs[j])
                    } else if(result.types[j+1] == 'float' || result.types[j+1] == 'double') {
                        inputs[j] = parseFloat(inputs[j])
                    }
                }
            }
        }
    }

    debugger

    const executed = await result.apply(null, inputs)
    if(executed == global) {
        return
    }
    // TODO: try to write the entire output back into the notebook cell because it was started from CLI
    
    if(executed && typeof executed.catch != 'undefined') {
        return await executed.catch(e => e).then(r => console.log(r))
    } else {
        console.log(executed)
    }
}

module.exports.run = run;
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

<script>hljs.highlightAll();</script>

<h3>Function <code>run</code></h3>
<h4>Overview</h4>
<p>The <code>run</code> function is an asynchronous function that appears to be part of a command-line tool. It takes two arguments, <code>process.argv[1]</code> and <code>process.argv[2]</code>, which are command-line arguments.</p>
<h4>Importing Modules</h4>
<p>The function imports two modules using <code>require</code>:</p>
<ul>
<li><code>importNotebook</code> and <code>interpret</code> from the <code>../Core</code> directory.</li>
</ul>
<h4>Getting Parameters</h4>
<p>The function uses <code>importNotebook</code> to get notebook parameters. It then uses these parameters to get the result of the notebook.</p>
<h4>Processing Parameters</h4>
<p>The function processes the parameters by:</p>
<ul>
<li>Checking if the result has a <code>functions</code> property and, if so, extracting the first function.</li>
<li>Checking if the result is an object with a function property and, if so, extracting the function.</li>
<li>Getting the parameters from the result or, if not available, from the <code>getParameters</code> function.</li>
</ul>
<h4>Parsing Inputs</h4>
<p>The function tries to parse the second command-line argument as an array of inputs using <code>eval</code>. If the parsing fails, it sets the inputs to an empty array. If the inputs are not an array, it wraps the single input in an array.</p>
<h4>Getting Command-Line Arguments</h4>
<p>The function iterates over the command-line arguments, checking for parameters specified in the <code>params</code> array. If a parameter is found, it extracts the value from the command-line argument and, if necessary, converts it to the correct type based on the result's <code>types</code> property.</p>
<h4>Executing the Function</h4>
<p>The function calls the result's <code>apply</code> method with the processed inputs and waits for the result.</p>
<h4>Returning the Result</h4>
<p>The function returns the result of the <code>apply</code> method, unless the result is the global object, in which case it returns immediately.</p>

</body>

</html>