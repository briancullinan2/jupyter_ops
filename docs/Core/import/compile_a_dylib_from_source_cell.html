<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>compile a dylib from source cell</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
    }

    body {
      padding-left: 200px;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <a href="../import/index.html">import</a>
    <br /><br />
    <a href="./import_notebook.html">import notebook</a>
<br /><br />
<a href="./how_does_node_module_require_work.html">how does node module require work</a>
<br /><br />
<a href="./cell_2.html">Cell 2</a>
<br /><br />
<a href="./compile_an_es_module.html">compile an es module</a>
<br /><br />
<a href="./compile_a_csharp_file_into_a_DLL.html">compile a csharp file into a DLL</a>
<br /><br />
<a href="./compile_a_dylib_from_source_cell.html">compile a dylib from source cell</a>
<br /><br />
<a href="./display_interpreted_results_in_markdown.html">display interpreted results in markdown</a>
<br /><br />
<a href="./search_jupter_notebooks_for_questions_and_answers.html">search jupter notebooks for questions and answers</a>
<br /><br />
<a href="./search_notebook_questions.html">search notebook questions</a>
<br /><br />
<a href="./cell_9.html">Cell 9</a>
<br /><br />
<a href="./convert_regexp_matches_to_an_array.html">convert regexp matches to an array</a>
<br /><br />
<a href="./run_all_promises_sequentially.html">run all promises sequentially</a>
<br /><br />
<a href="./parse_cells_from_a_notebook.html">parse cells from a notebook</a>
<br /><br />
<a href="./cell_13.html">Cell 13</a>
<br /><br />

  </nav>
  <header>
    <a href="../import/index.html">import</a> ${PREV} ${NEXT}
  </header>

  <p>Here's a 2-sentence summary of the code:</p>
<p>This JavaScript code generates dynamic libraries using functions <code>generateCallback</code> and <code>makeDylib</code>, which create callbacks for library functions and compile code into dynamic libraries, respectively. The code relies on external dependencies such as <code>ffi-rs</code> and a core module, and includes unclear or missing parts indicated by <code>TODO</code> comments.</p>


<pre class="javascript"><code>const path = require('path')
const { Module } = require('module')

const BUILD_DIRECTORY = path.join(__dirname, '../.build')

let typeToDataType
function generateCallback(libName, i, types, params) {
  const { importNotebook } = require('../Core')
  const { load } = require('ffi-rs')
  if(!typeToDataType)
    typeToDataType = importNotebook('c type to data type')

  return function internalCallback(returnLength, ...paramValues) {
    //console.log(paramValues, types)
    let returnType = typeToDataType(returnLength, types[0])
    return load({
      library: libName, // path to the dynamic library file
      funcName: params[i][0], // the name of the function to call
      retType: returnType, // the return value type
      paramsType: types.slice(1).map((t, i) => typeToDataType(typeof paramValues[i] == 'undefined' ? 0 : typeof paramValues == 'object' && paramValues[i].constructor.name == 'Array' ? paramValues[i].length : 1, t)), // the parameter types
      paramsValue: paramValues.length < 2 && types.length && types.length <= 2 && types[1] == 'void' && typeof paramValues[0] == 'undefined' ? [void 0] : paramValues // the actual parameter values
      // freeResultMemory: true, // whether or not need to free the result of return value memory automatically, default is false
    })
  }
}


async function makeDylib(code, pathToCode, ctx) {
  const {
    importNotebook, interpret
  } = require('../Core')
  const { open } = require('ffi-rs')

  if (Module._cache[pathToCode]) {
    return Module._cache[pathToCode].exports
  }
  const buildDylib = importNotebook('build dylib')
  // TODO: await module loaded
  buildDylib(code, pathToCode, ctx)

  const codeCell = interpret(pathToCode)
  // TODO: compare file times for dylib module recompile
  const { safeurl } = importNotebook('domain cache tools')
  let libName = safeurl(codeCell.questions[0])

  open({
    library: libName, // key
    path: path.join(BUILD_DIRECTORY, libName + '.dylib') // path
  })

  // TODO: turn this into a sort of prepFunction(...types) that takes a types argument instead
  //const selectCode = await importNotebook('select antlr tree')
  //console.log(selectCode)
  const selectCode = await importNotebook('select antlr tree')
  const rootNode = (await selectCode(['//*'], code.toString(), 'cpp'))[0]
  //console.log('###########################', rootNode.tagName)
  const getParameters = await importNotebook('get c parameters')
  const params = await getParameters(rootNode)
  console.log(params)
  const getTypes = await importNotebook('get c types')
  // TODO: make functions out of all exports
  let resources = {}
  for (let i = 0; i < params.length; i++) {
    if(typeof params[i] == 'string') {
      params[i] = [params[i]]
    }
    const types = await getTypes(rootNode, params[i][0])
    //console.log(types)
    // TODO: make a version of this function that can load all data types from parameters
    let newCallback = generateCallback(libName, i, types, params)
    resources[params[i][0]] = ((i, types) => function (...paramValues) {
      return resources[params[i][0] + 'Ret'](1, ...paramValues)
    })(i, types)
    resources[params[i][0] + 'Ret'] = newCallback

    resources[params[i][0]].name = params[0]
    resources[params[i][0] + 'Ret'].name = params[0] + 'Ret'
    resources[params[i][0]].params = params[i].slice(1)
    resources[params[i][0] + 'Ret'].params = ['ret'].concat(params[i].slice(1))
    resources[params[i][0]].types = types
    resources[params[i][0] + 'Ret'].types = types

  }
  Module._cache[pathToCode] = {}
  Module._cache[pathToCode].exports = resources
  Module._cache[pathToCode].loaded = true
  //close(libName)
  return resources
}

module.exports.makeDylib = makeDylib
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

<script>hljs.highlightAll();</script>

<p><strong>Breakdown of the Code</strong></p>
<p>The code is written in JavaScript and appears to be a part of a larger project that generates dynamic libraries. Here's a brief explanation of the code:</p>
<h3>Functions</h3>
<h4><code>generateCallback(libName, i, types, params)</code></h4>
<p>This function generates a callback function that can be used to call a dynamic library function. It takes the following parameters:</p>
<ul>
<li><code>libName</code>: the name of the dynamic library</li>
<li><code>i</code>: the index of the function to call</li>
<li><code>types</code>: an array of function parameter types</li>
<li><code>params</code>: an array of function parameter names</li>
</ul>
<p>The function returns a callback function that takes the return value length and parameter values as arguments.</p>
<h4><code>makeDylib(code, pathToCode, ctx)</code></h4>
<p>This function generates a dynamic library from a given code and saves it to a file. It takes the following parameters:</p>
<ul>
<li><code>code</code>: the code to compile</li>
<li><code>pathToCode</code>: the path to the code file</li>
<li><code>ctx</code>: the context</li>
</ul>
<p>The function imports functions from a core module and returns the dynamic library.</p>
<h3>Constants</h3>
<h4><code>BUILD_DIRECTORY</code></h4>
<p>This constant defines the directory where the dynamic libraries are built.</p>
<h4><code>typeToDataType</code></h4>
<p>This variable stores the <code>c type to data type</code> function imported from the core module.</p>
<h3>External Dependencies</h3>
<p>The code uses the following external dependencies:</p>
<ul>
<li><code>path</code>: for path manipulation</li>
<li><code>module</code>: for module loading</li>
<li><code>ffi-rs</code>: for dynamic library loading and interaction</li>
<li><code>../Core</code>: for importing core functions</li>
<li><code>../Core</code>: for importing core functions</li>
</ul>
<h3>Unclear or Missing Code</h3>
<p>Some parts of the code are unclear or missing, including the <code>TODO</code> comments. These comments suggest that the code is still in development and may need to be completed or modified in the future.</p>

</body>

</html>