<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge'>
  <title>ask llm about categories</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
  <style>
    nav {
      position: fixed;
      overflow: auto;
      top: 0;
      left: 0;
      right: auto;
      bottom: 0;
      width: 200px;
    }

    header {
      background-color: #EEE;
    }

    body {
      padding-left: 200px;
    }

    @media screen and (max-width: 600px) {
      body {
        padding-left: 0;
      }

      nav {
        display: none;
      }
    }
  </style>
</head>

<body>
  <nav>
    <a href="../llama/index.html">llama</a>
    <br /><br />
    <a href="./search_llama.html">search llama</a>
<br /><br />
<a href="./ask_llm_about_categories.html">ask llm about categories</a>
<br /><br />
<a href="./ask_llm_to_generalize_categories.html">ask llm to generalize categories</a>
<br /><br />
<a href="./ask_llm_for_a_shorter_list_of_categories.html">ask llm for a shorter list of categories</a>
<br /><br />
<a href="./ask_llm_about_functions.html">ask llm about functions</a>
<br /><br />
<a href="./ask_llm_about_code.html">ask llm about code</a>
<br /><br />
<a href="./ask_llm_about_notebooks.html">ask llm about notebooks</a>
<br /><br />
<a href="./ask_llm_to_summerize.html">ask llm to summerize</a>
<br /><br />
<a href="./store_llama_function.html">store llama function</a>
<br /><br />
<a href="./store_all_notebook_llm_functions.html">store all notebook llm functions</a>
<br /><br />
<a href="./create_llm_session.html">create llm session</a>
<br /><br />

  </nav>
  <header>
    <a href="../llama/index.html">llama</a> ${PREV} ${NEXT}
  </header>

  <p>Here is a two-sentence summary of the code breakdown:</p>
<p>The <code>askLlamaAboutCategories</code> function is an asynchronous function that extracts categories from a cache object, asks the LLM about these categories in batches, and returns notebook filenames that contain matching categories. The function consists of three main steps: extracting categories, asking the LLM about the categories, and returning matching notebook filenames based on the LLM's responses.</p>


<pre class="javascript"><code>const { functionCache } = importer.import('cache rpc functions with llm descriptions')
const {askLlamaAboutFunctions} = importer.import('ask llm about functions')


async function askLlamaAboutCategories(query) {
  // TODO: list all categories in database
  let keys = Object.keys(functionCache)
  let categorys = keys.map(k => functionCache[k].categories)
    .concat(keys.map(k => functionCache[k].category))
    .filter((a, i, arr) => a && arr.indexOf(a) == i && !a.includes('\n'))

  // TODO: ask llm if any of the categories match, don't choose best one, choose all matches
  let returnValues = []
  let functions = []
  for(let i = 0; i < categorys.length; i++) {
    let category = categorys[i]
    functions[functions.length] = category

    if(functions.length == 20) {
      let result = await askLlamaAboutFunctions(query, functions, [], true)
      functions = []
      if(result)
        returnValues = returnValues.concat(result)
    }
  }
  if(functions.length > 0) {
      let result = await askLlamaAboutFunctions(query, functions, [], true)
      functions = []
      if(result)
        returnValues = returnValues.concat(result)
  }

  // TODO: return notebook filenames that contain matching categories
  let matching = keys.filter(k => returnValues.includes(functionCache[k].category) || returnValues.includes(functionCache[k].categories))
    .map(k => k.replace(/\[[0-9]*\]/, ''))
    .filter((a, i, arr) => a && arr.indexOf(a) == i)
  return matching
}

module.exports = {
  askLlamaAboutCategories
}
</code></pre>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

<script>hljs.highlightAll();</script>

<h2>Code Breakdown</h2>
<h3>Importing Modules</h3>
<p>The code starts by importing two modules using the <code>importer.import()</code> function:</p>
<pre><code class="language-markdown">const { functionCache } = importer.import('cache rpc functions with llm descriptions')
const {askLlamaAboutFunctions} = importer.import('ask llm about functions')
</code></pre>
<p>These imports are assigning the exported objects <code>functionCache</code> and <code>askLlamaAboutFunctions</code> from the respective imported modules.</p>
<h3>askLlamaAboutCategories Function</h3>
<p>The <code>askLlamaAboutCategories</code> function is an asynchronous function that takes a <code>query</code> parameter:</p>
<pre><code class="language-markdown">async function askLlamaAboutCategories(query) {
</code></pre>
<p>This function appears to be responsible for finding categories in a database (implemented in <code>functionCache</code>), asking the LLM (using <code>askLlamaAboutFunctions</code>) about these categories, and returning notebook filenames that contain matching categories.</p>
<h3>Function Steps</h3>
<ol>
<li><strong>Extracting categories</strong>: The function extracts categories from the <code>functionCache</code> object and filters out any duplicates or newline characters (<code>\n</code>).</li>
</ol>
<pre><code class="language-markdown">let keys = Object.keys(functionCache)
let categorys = keys.map(k =&gt; functionCache[k].categories)
 .concat(keys.map(k =&gt; functionCache[k].category))
 .filter((a, i, arr) =&gt; a &amp;&amp; arr.indexOf(a) == i &amp;&amp;!a.includes('\n'))
</code></pre>
<ol start="2">
<li><strong>Asking LLM about categories</strong>: The function asks the LLM about the extracted categories in batches of 20. For each batch, it calls <code>askLlamaAboutFunctions</code> with the <code>query</code>, <code>functions</code> (the batch of categories), and other parameters. It then concatenates the results.</li>
</ol>
<pre><code class="language-markdown">for(let i = 0; i &lt; categorys.length; i++) {
  let category = categorys[i]
  functions[functions.length] = category

  if(functions.length == 20) {
    let result = await askLlamaAboutFunctions(query, functions, [], true)
    functions = []
    if(result)
      returnValues = returnValues.concat(result)
  }
}
</code></pre>
<ol start="3">
<li><strong>Returning matching notebook filenames</strong>: Finally, the function returns notebook filenames that contain the matching categories.</li>
</ol>
<pre><code class="language-markdown">let matching = keys.filter(k =&gt; returnValues.includes(functionCache[k].category) || returnValues.includes(functionCache[k].categories))
 .map(k =&gt; k.replace(/\[[0-9]*\]/, ''))
 .filter((a, i, arr) =&gt; a &amp;&amp; arr.indexOf(a) == i)
return matching
</code></pre>
<h3>Exporting the Function</h3>
<p>The <code>askLlamaAboutCategories</code> function is exported as a module:</p>
<pre><code class="language-markdown">module.exports = {
  askLlamaAboutCategories
}
</code></pre>

</body>

</html>