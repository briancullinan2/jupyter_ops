// Generated from Resources/Parsers/haskell/HaskellParser.g4 by ANTLR 4.10.1
// jshint ignore: start
import antlr4 from 'antlr4';
import HaskellParserListener from './HaskellParserListener.js';
const serializedATN = [4,1,141,2949,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,
7,4,2,5,7,5,2,6,7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,
2,13,7,13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,
7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,
34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,
2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,
49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,
2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,
78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,85,
7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,91,2,92,7,
92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,98,2,99,7,99,
2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,7,104,2,105,7,105,
2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,7,110,2,111,7,111,
2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,7,116,2,117,7,117,
2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,7,122,2,123,7,123,
2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,
2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,
2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,
2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,7,153,
2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,2,159,7,159,
2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,7,164,2,165,7,165,
2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,7,170,2,171,7,171,
2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,7,176,2,177,7,177,
2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,7,182,2,183,7,183,
2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,7,188,2,189,7,189,
2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,
2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,
2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,
2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,7,219,
2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,2,225,7,225,
2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,7,230,2,231,7,231,
2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,7,236,2,237,7,237,
2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,7,242,2,243,7,243,
2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,7,248,2,249,7,249,
2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,7,254,2,255,7,255,
1,0,3,0,514,8,0,1,0,5,0,517,8,0,10,0,12,0,520,9,0,1,0,3,0,523,8,0,1,0,5,
0,526,8,0,10,0,12,0,529,9,0,1,0,1,0,3,0,533,8,0,1,0,3,0,536,8,0,1,0,3,0,
539,8,0,1,0,1,0,1,1,1,1,1,1,3,1,546,8,1,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,3,
1,3,5,3,557,8,3,10,3,12,3,560,9,3,1,4,4,4,563,8,4,11,4,12,4,564,1,5,1,5,
1,5,3,5,570,8,5,1,6,1,6,1,6,1,6,1,6,5,6,577,8,6,10,6,12,6,580,9,6,1,6,1,
6,3,6,584,8,6,1,7,1,7,1,7,1,7,1,7,3,7,591,8,7,5,7,593,8,7,10,7,12,7,596,
9,7,1,7,1,7,3,7,600,8,7,1,8,1,8,1,8,1,8,1,8,3,8,607,8,8,5,8,609,8,8,10,8,
12,8,612,9,8,1,8,1,8,3,8,616,8,8,1,9,1,9,1,10,1,10,1,10,1,10,1,10,3,10,625,
8,10,1,11,1,11,1,11,4,11,630,8,11,11,11,12,11,631,1,12,1,12,1,12,1,12,5,
12,638,8,12,10,12,12,12,641,9,12,3,12,643,8,12,1,12,3,12,646,8,12,1,12,1,
12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,5,13,659,8,13,10,13,12,13,
662,9,13,3,13,664,8,13,1,13,3,13,667,8,13,1,13,1,13,1,13,1,13,1,13,1,13,
1,13,1,13,5,13,677,8,13,10,13,12,13,680,9,13,3,13,682,8,13,1,13,3,13,685,
8,13,1,13,1,13,3,13,689,8,13,1,14,1,14,3,14,693,8,14,1,14,1,14,1,14,3,14,
698,8,14,1,14,3,14,701,8,14,1,14,4,14,704,8,14,11,14,12,14,705,1,15,1,15,
1,15,1,15,5,15,712,8,15,10,15,12,15,715,9,15,1,15,3,15,718,8,15,3,15,720,
8,15,1,15,1,15,1,15,1,15,1,15,1,15,5,15,728,8,15,10,15,12,15,731,9,15,1,
15,3,15,734,8,15,3,15,736,8,15,1,15,3,15,739,8,15,1,16,1,16,1,16,1,16,1,
16,1,16,1,16,1,16,1,16,5,16,750,8,16,10,16,12,16,753,9,16,3,16,755,8,16,
1,16,3,16,758,8,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,766,8,16,1,16,3,16,
769,8,16,3,16,771,8,16,1,17,1,17,3,17,775,8,17,1,18,1,18,1,19,1,19,1,19,
5,19,782,8,19,10,19,12,19,785,9,19,1,20,1,20,4,20,789,8,20,11,20,12,20,790,
1,20,1,20,4,20,795,8,20,11,20,12,20,796,1,21,1,21,1,21,1,21,1,21,1,21,1,
21,1,21,1,21,3,21,808,8,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,816,8,21,1,
21,1,21,1,21,1,21,3,21,822,8,21,1,21,1,21,1,21,1,21,3,21,828,8,21,1,21,1,
21,1,21,1,21,3,21,834,8,21,1,22,1,22,1,22,3,22,839,8,22,1,22,3,22,842,8,
22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,853,8,23,1,23,3,23,
856,8,23,1,23,3,23,859,8,23,1,23,1,23,3,23,863,8,23,1,23,1,23,1,23,3,23,
868,8,23,1,23,1,23,3,23,872,8,23,1,23,1,23,1,23,3,23,877,8,23,1,23,1,23,
3,23,881,8,23,1,23,1,23,3,23,885,8,23,1,23,3,23,888,8,23,1,23,3,23,891,8,
23,1,23,1,23,3,23,895,8,23,1,23,1,23,3,23,899,8,23,1,23,3,23,902,8,23,1,
23,3,23,905,8,23,1,23,1,23,1,23,1,23,3,23,911,8,23,3,23,913,8,23,1,24,1,
24,1,24,1,24,1,24,1,25,1,25,1,25,5,25,923,8,25,10,25,12,25,926,9,25,1,26,
1,26,3,26,930,8,26,1,26,1,26,3,26,934,8,26,1,26,1,26,1,26,1,26,1,26,1,26,
3,26,942,8,26,1,26,1,26,3,26,946,8,26,1,26,1,26,1,26,3,26,951,8,26,1,26,
1,26,3,26,955,8,26,1,26,1,26,1,26,3,26,960,8,26,1,26,1,26,3,26,964,8,26,
1,26,3,26,967,8,26,1,26,3,26,970,8,26,1,26,1,26,1,26,3,26,975,8,26,1,26,
1,26,3,26,979,8,26,1,26,3,26,982,8,26,1,26,3,26,985,8,26,3,26,987,8,26,1,
27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,1001,8,27,
1,28,1,28,1,29,1,29,1,29,1,30,1,30,1,30,1,30,3,30,1012,8,30,1,31,1,31,1,
31,1,32,1,32,1,32,1,32,1,33,4,33,1022,8,33,11,33,12,33,1023,1,34,1,34,1,
34,1,35,1,35,3,35,1031,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,
3,35,1042,8,35,1,36,1,36,4,36,1046,8,36,11,36,12,36,1047,1,36,1,36,5,36,
1052,8,36,10,36,12,36,1055,9,36,1,36,5,36,1058,8,36,10,36,12,36,1061,9,36,
1,37,1,37,3,37,1065,8,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,
37,1076,8,37,1,38,1,38,3,38,1080,8,38,1,38,1,38,3,38,1084,8,38,1,38,1,38,
3,38,1088,8,38,1,38,1,38,3,38,1092,8,38,1,38,1,38,3,38,1096,8,38,1,38,3,
38,1099,8,38,1,39,1,39,3,39,1103,8,39,1,39,1,39,1,39,3,39,1108,8,39,1,39,
3,39,1111,8,39,1,39,1,39,1,39,3,39,1116,8,39,1,39,1,39,3,39,1120,8,39,1,
39,3,39,1123,8,39,1,39,1,39,1,39,3,39,1128,8,39,1,39,1,39,3,39,1132,8,39,
1,39,3,39,1135,8,39,1,39,1,39,3,39,1139,8,39,1,39,3,39,1142,8,39,1,39,3,
39,1145,8,39,1,39,1,39,3,39,1149,8,39,1,39,3,39,1152,8,39,1,39,1,39,3,39,
1156,8,39,1,39,3,39,1159,8,39,1,39,3,39,1162,8,39,3,39,1164,8,39,1,40,1,
40,1,40,1,41,1,41,1,41,1,42,1,42,1,42,1,42,3,42,1176,8,42,1,43,1,43,1,43,
1,43,1,43,1,43,1,43,3,43,1185,8,43,1,44,1,44,1,44,1,44,1,44,3,44,1192,8,
44,1,45,1,45,3,45,1196,8,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,1205,
8,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,1214,8,45,1,46,1,46,1,46,1,
46,1,46,1,46,1,46,1,46,1,46,3,46,1225,8,46,1,47,1,47,3,47,1229,8,47,1,47,
1,47,3,47,1233,8,47,1,47,1,47,1,48,1,48,1,48,1,48,3,48,1241,8,48,1,49,4,
49,1244,8,49,11,49,12,49,1245,1,50,1,50,3,50,1250,8,50,1,51,1,51,1,51,1,
51,1,51,1,51,1,51,1,51,1,51,1,51,3,51,1262,8,51,3,51,1264,8,51,1,52,1,52,
3,52,1268,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,52,1279,8,
52,1,53,4,53,1282,8,53,11,53,12,53,1283,1,54,1,54,1,54,5,54,1289,8,54,10,
54,12,54,1292,9,54,1,55,1,55,1,55,3,55,1297,8,55,1,55,1,55,1,56,1,56,1,56,
1,56,1,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,1313,8,57,1,58,1,58,4,
58,1317,8,58,11,58,12,58,1318,1,58,1,58,5,58,1323,8,58,10,58,12,58,1326,
9,58,1,58,5,58,1329,8,58,10,58,12,58,1332,9,58,1,59,1,59,3,59,1336,8,59,
1,59,1,59,1,60,1,60,1,60,1,61,1,61,3,61,1345,8,61,1,62,1,62,4,62,1349,8,
62,11,62,12,62,1350,1,62,1,62,5,62,1355,8,62,10,62,12,62,1358,9,62,1,62,
5,62,1361,8,62,10,62,12,62,1364,9,62,1,63,1,63,3,63,1368,8,63,1,63,1,63,
1,64,1,64,1,64,1,65,1,65,4,65,1377,8,65,11,65,12,65,1378,1,65,1,65,5,65,
1383,8,65,10,65,12,65,1386,9,65,1,65,5,65,1389,8,65,10,65,12,65,1392,9,65,
1,66,1,66,3,66,1396,8,66,1,66,1,66,1,67,1,67,1,67,3,67,1403,8,67,1,67,1,
67,3,67,1407,8,67,1,68,1,68,1,68,1,69,1,69,1,69,1,69,5,69,1416,8,69,10,69,
12,69,1419,9,69,1,69,3,69,1422,8,69,1,70,1,70,3,70,1426,8,70,1,70,3,70,1429,
8,70,1,70,1,70,1,70,1,70,1,71,1,71,3,71,1437,8,71,1,72,1,72,1,72,1,72,1,
72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,1452,8,72,1,73,1,73,3,73,
1456,8,73,1,73,1,73,1,73,3,73,1461,8,73,1,73,3,73,1464,8,73,1,74,4,74,1467,
8,74,11,74,12,74,1468,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1478,8,75,
1,76,1,76,1,76,1,76,5,76,1484,8,76,10,76,12,76,1487,9,76,1,76,3,76,1490,
8,76,1,77,1,77,1,77,1,78,1,78,1,78,1,78,5,78,1499,8,78,10,78,12,78,1502,
9,78,1,78,3,78,1505,8,78,1,79,1,79,1,79,1,80,1,80,1,80,3,80,1513,8,80,1,
80,3,80,1516,8,80,1,81,1,81,1,81,5,81,1521,8,81,10,81,12,81,1524,9,81,1,
82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,
1,82,1,82,1,82,3,82,1544,8,82,1,83,1,83,1,83,3,83,1549,8,83,1,83,1,83,1,
83,1,83,1,83,1,83,3,83,1557,8,83,1,84,1,84,1,85,1,85,1,86,3,86,1564,8,86,
1,86,1,86,1,86,1,86,1,87,1,87,1,87,1,88,1,88,1,88,1,89,1,89,1,90,1,90,1,
91,1,91,1,91,5,91,1583,8,91,10,91,12,91,1586,9,91,1,92,1,92,1,92,5,92,1591,
8,92,10,92,12,92,1594,9,92,1,93,1,93,1,93,1,93,1,93,1,93,3,93,1602,8,93,
1,94,1,94,1,95,1,95,1,95,1,95,1,95,3,95,1611,8,95,1,96,1,96,1,96,1,96,1,
96,3,96,1618,8,96,1,97,1,97,3,97,1622,8,97,1,97,1,97,1,97,1,97,1,97,1,97,
1,97,1,97,1,97,1,97,1,97,1,97,3,97,1636,8,97,1,98,1,98,3,98,1640,8,98,1,
98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,3,98,1654,8,98,
1,99,1,99,1,100,1,100,1,101,1,101,1,101,1,101,1,101,3,101,1665,8,101,1,102,
1,102,1,102,1,102,1,102,3,102,1672,8,102,1,103,1,103,1,104,4,104,1677,8,
104,11,104,12,104,1678,1,105,1,105,1,106,1,106,1,107,4,107,1686,8,107,11,
107,12,107,1687,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,
108,3,108,1700,8,108,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,
3,109,1711,8,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,
109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,
109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,
109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,1754,8,109,1,109,1,109,
1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,1768,8,
109,1,110,1,110,1,111,1,111,1,111,5,111,1775,8,111,10,111,12,111,1778,9,
111,1,112,1,112,1,112,5,112,1783,8,112,10,112,12,112,1786,9,112,1,113,1,
113,1,113,1,113,1,113,5,113,1793,8,113,10,113,12,113,1796,9,113,1,114,4,
114,1799,8,114,11,114,12,114,1800,1,115,1,115,1,115,1,115,1,115,1,115,1,
115,1,115,1,115,1,115,1,115,3,115,1814,8,115,1,116,1,116,1,116,1,116,1,116,
1,116,1,116,3,116,1823,8,116,1,117,1,117,1,117,1,118,1,118,1,118,5,118,1831,
8,118,10,118,12,118,1834,9,118,1,119,3,119,1837,8,119,1,119,1,119,3,119,
1841,8,119,1,120,4,120,1844,8,120,11,120,12,120,1845,1,121,1,121,1,122,1,
122,1,122,3,122,1853,8,122,1,122,5,122,1856,8,122,10,122,12,122,1859,9,122,
1,122,1,122,1,123,1,123,1,123,1,123,5,123,1867,8,123,10,123,12,123,1870,
9,123,1,124,1,124,1,125,1,125,1,125,1,125,1,126,1,126,1,126,1,127,1,127,
1,127,5,127,1884,8,127,10,127,12,127,1887,9,127,1,128,3,128,1890,8,128,1,
128,1,128,1,128,3,128,1895,8,128,1,128,1,128,1,129,1,129,3,129,1901,8,129,
1,129,1,129,1,130,1,130,1,131,1,131,1,131,5,131,1910,8,131,10,131,12,131,
1913,9,131,1,132,1,132,1,132,1,132,1,133,4,133,1920,8,133,11,133,12,133,
1921,1,134,1,134,1,134,1,134,1,134,1,134,1,134,1,134,1,134,1,134,3,134,1934,
8,134,1,135,1,135,1,135,1,135,1,135,1,135,1,135,3,135,1943,8,135,1,136,1,
136,1,136,3,136,1948,8,136,1,136,1,136,1,136,1,136,4,136,1954,8,136,11,136,
12,136,1955,3,136,1958,8,136,1,137,1,137,1,137,4,137,1963,8,137,11,137,12,
137,1964,3,137,1967,8,137,1,138,1,138,1,138,3,138,1972,8,138,1,138,1,138,
3,138,1976,8,138,3,138,1978,8,138,1,139,4,139,1981,8,139,11,139,12,139,1982,
1,140,1,140,1,140,1,140,1,140,1,141,1,141,1,141,1,141,1,141,1,141,1,141,
1,141,1,141,1,141,1,141,1,141,3,141,2002,8,141,1,141,1,141,1,141,1,141,1,
141,1,141,1,141,3,141,2011,8,141,1,141,1,141,1,141,1,141,1,141,3,141,2018,
8,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,3,141,2027,8,141,1,141,1,
141,1,141,1,141,1,141,3,141,2034,8,141,1,141,1,141,1,141,1,141,1,141,1,141,
1,141,1,141,3,141,2044,8,141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,1,
141,1,141,1,141,1,141,1,141,1,141,1,141,1,141,3,141,2061,8,141,1,141,1,141,
4,141,2065,8,141,11,141,12,141,2066,3,141,2069,8,141,1,142,1,142,1,142,1,
142,1,142,1,142,1,142,1,142,1,142,3,142,2080,8,142,1,143,1,143,1,143,1,143,
1,144,1,144,1,144,1,144,1,145,1,145,3,145,2092,8,145,1,146,1,146,1,146,1,
146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,146,1,
146,1,146,1,146,1,146,1,146,1,146,3,146,2115,8,146,1,147,1,147,1,147,1,147,
5,147,2121,8,147,10,147,12,147,2124,9,147,1,148,1,148,1,149,3,149,2129,8,
149,1,149,1,149,1,150,4,150,2134,8,150,11,150,12,150,2135,1,150,1,150,3,
150,2140,8,150,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,
1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,
1,151,3,151,2165,8,151,1,151,1,151,1,151,3,151,2170,8,151,1,151,1,151,1,
151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,
151,3,151,2187,8,151,1,152,1,152,1,152,3,152,2192,8,152,1,152,5,152,2195,
8,152,10,152,12,152,2198,9,152,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,3,153,2263,8,153,1,153,1,
153,3,153,2267,8,153,1,154,1,154,3,154,2271,8,154,1,155,1,155,1,155,1,156,
1,156,1,156,1,157,4,157,2280,8,157,11,157,12,157,2281,1,158,1,158,1,159,
1,159,3,159,2288,8,159,1,159,1,159,1,160,1,160,5,160,2294,8,160,10,160,12,
160,2297,9,160,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,1,161,
1,161,3,161,2310,8,161,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,3,
162,2320,8,162,1,162,1,162,1,162,3,162,2325,8,162,3,162,2327,8,162,1,163,
1,163,3,163,2331,8,163,1,164,1,164,1,164,1,164,3,164,2337,8,164,1,165,1,
165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,
165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,1,165,3,165,2363,
8,165,1,166,1,166,1,166,1,166,1,166,5,166,2370,8,166,10,166,12,166,2373,
9,166,1,167,1,167,1,168,1,168,1,168,5,168,2380,8,168,10,168,12,168,2383,
9,168,1,169,1,169,1,169,5,169,2388,8,169,10,169,12,169,2391,9,169,1,169,
1,169,1,169,5,169,2396,8,169,10,169,12,169,2399,9,169,1,169,1,169,1,169,
5,169,2404,8,169,10,169,12,169,2407,9,169,1,169,1,169,1,169,5,169,2412,8,
169,10,169,12,169,2415,9,169,3,169,2417,8,169,1,170,1,170,1,170,1,170,1,
170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,170,1,
170,1,170,3,170,2437,8,170,1,171,1,171,1,171,5,171,2442,8,171,10,171,12,
171,2445,9,171,1,172,1,172,1,172,1,172,1,172,1,172,1,172,3,172,2454,8,172,
1,173,1,173,1,173,5,173,2459,8,173,10,173,12,173,2462,9,173,4,173,2464,8,
173,11,173,12,173,2465,1,173,1,173,1,173,1,173,1,173,3,173,2473,8,173,1,
174,1,174,1,174,1,175,1,175,3,175,2480,8,175,1,176,1,176,1,176,3,176,2485,
8,176,1,177,4,177,2488,8,177,11,177,12,177,2489,1,178,1,178,1,178,1,178,
1,178,3,178,2497,8,178,1,179,1,179,1,179,1,179,1,179,1,180,1,180,1,181,1,
181,1,182,1,182,1,183,4,183,2511,8,183,11,183,12,183,2512,1,184,1,184,1,
184,1,184,1,185,1,185,3,185,2521,8,185,1,185,1,185,1,186,1,186,4,186,2527,
8,186,11,186,12,186,2528,1,186,1,186,5,186,2533,8,186,10,186,12,186,2536,
9,186,1,186,5,186,2539,8,186,10,186,12,186,2542,9,186,1,187,1,187,1,187,
1,187,4,187,2548,8,187,11,187,12,187,2549,3,187,2552,8,187,1,188,1,188,1,
188,1,188,1,188,1,188,1,188,3,188,2561,8,188,1,189,1,189,1,189,5,189,2566,
8,189,10,189,12,189,2569,9,189,1,189,3,189,2572,8,189,1,190,1,190,1,190,
1,190,1,190,3,190,2579,8,190,1,191,1,191,4,191,2583,8,191,11,191,12,191,
2584,1,191,1,191,1,191,5,191,2590,8,191,10,191,12,191,2593,9,191,1,192,1,
192,1,192,1,192,1,193,1,193,1,193,5,193,2602,8,193,10,193,12,193,2605,9,
193,1,194,1,194,1,195,1,195,1,195,5,195,2612,8,195,10,195,12,195,2615,9,
195,1,196,1,196,1,196,1,196,1,196,3,196,2622,8,196,1,197,1,197,1,197,5,197,
2627,8,197,10,197,12,197,2630,9,197,1,198,1,198,3,198,2634,8,198,1,199,1,
199,3,199,2638,8,199,1,200,1,200,3,200,2642,8,200,1,201,1,201,1,201,1,201,
1,201,3,201,2649,8,201,1,202,1,202,1,202,1,202,1,202,1,202,3,202,2657,8,
202,1,203,1,203,1,203,5,203,2662,8,203,10,203,12,203,2665,9,203,1,204,1,
204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,3,204,2679,
8,204,1,205,1,205,1,205,3,205,2684,8,205,1,206,1,206,1,206,1,206,1,206,3,
206,2691,8,206,1,207,1,207,1,207,1,207,1,207,3,207,2698,8,207,1,208,1,208,
3,208,2702,8,208,1,209,1,209,1,209,1,209,1,209,3,209,2709,8,209,1,210,1,
210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,
210,3,210,2725,8,210,1,211,1,211,1,211,1,211,1,211,3,211,2732,8,211,1,212,
1,212,1,212,1,212,1,212,3,212,2739,8,212,1,213,1,213,1,213,3,213,2744,8,
213,1,213,1,213,1,214,1,214,1,215,1,215,1,215,3,215,2753,8,215,1,216,1,216,
1,216,1,216,1,216,3,216,2760,8,216,1,217,1,217,3,217,2764,8,217,1,218,1,
218,1,218,1,218,1,218,3,218,2771,8,218,1,219,1,219,3,219,2775,8,219,1,220,
1,220,1,220,3,220,2780,8,220,1,221,1,221,1,221,1,221,1,222,1,222,1,222,1,
222,1,222,3,222,2791,8,222,1,223,1,223,1,223,1,223,1,223,3,223,2798,8,223,
1,224,1,224,1,225,1,225,1,225,1,225,1,226,1,226,1,226,1,226,1,226,3,226,
2811,8,226,1,227,1,227,1,228,1,228,1,228,3,228,2818,8,228,1,228,1,228,1,
229,1,229,1,229,1,229,1,229,3,229,2827,8,229,1,230,1,230,1,230,1,230,1,230,
3,230,2834,8,230,1,231,1,231,1,231,3,231,2839,8,231,1,231,1,231,1,232,1,
232,3,232,2845,8,232,1,232,5,232,2848,8,232,10,232,12,232,2851,9,232,1,233,
1,233,1,233,3,233,2856,8,233,1,233,1,233,1,234,1,234,3,234,2862,8,234,1,
235,1,235,3,235,2866,8,235,1,236,4,236,2869,8,236,11,236,12,236,2870,1,237,
1,237,1,238,1,238,1,238,3,238,2878,8,238,1,238,1,238,1,239,1,239,5,239,2884,
8,239,10,239,12,239,2887,9,239,1,240,1,240,1,240,3,240,2892,8,240,1,240,
1,240,1,241,1,241,5,241,2898,8,241,10,241,12,241,2901,9,241,1,242,1,242,
1,242,1,242,3,242,2907,8,242,1,243,1,243,1,244,1,244,1,245,1,245,1,246,1,
246,1,246,5,246,2918,8,246,10,246,12,246,2921,9,246,1,246,1,246,1,247,4,
247,2926,8,247,11,247,12,247,2927,1,248,4,248,2931,8,248,11,248,12,248,2932,
1,249,1,249,1,250,1,250,1,251,1,251,1,252,1,252,1,253,1,253,1,254,1,254,
1,255,1,255,1,255,0,0,256,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,
34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,
124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,
160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,
196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,
232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,
268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,
304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,
340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,
376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,
412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,
448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,
484,486,488,490,492,494,496,498,500,502,504,506,508,510,0,12,1,0,16,18,2,
0,22,22,48,49,2,0,38,39,41,42,1,0,32,34,2,0,76,76,99,99,7,0,4,4,12,12,24,
24,31,31,38,40,42,42,48,50,2,0,132,132,134,134,2,0,133,133,135,135,2,0,100,
100,136,136,5,0,100,100,102,102,108,108,120,123,132,133,7,0,82,89,91,95,
97,97,99,99,101,101,103,104,107,107,1,0,137,139,3200,0,513,1,0,0,0,2,542,
1,0,0,0,4,549,1,0,0,0,6,552,1,0,0,0,8,562,1,0,0,0,10,569,1,0,0,0,12,571,
1,0,0,0,14,585,1,0,0,0,16,601,1,0,0,0,18,617,1,0,0,0,20,624,1,0,0,0,22,629,
1,0,0,0,24,633,1,0,0,0,26,688,1,0,0,0,28,690,1,0,0,0,30,738,1,0,0,0,32,770,
1,0,0,0,34,774,1,0,0,0,36,776,1,0,0,0,38,778,1,0,0,0,40,794,1,0,0,0,42,833,
1,0,0,0,44,835,1,0,0,0,46,912,1,0,0,0,48,914,1,0,0,0,50,919,1,0,0,0,52,986,
1,0,0,0,54,1000,1,0,0,0,56,1002,1,0,0,0,58,1004,1,0,0,0,60,1011,1,0,0,0,
62,1013,1,0,0,0,64,1016,1,0,0,0,66,1021,1,0,0,0,68,1025,1,0,0,0,70,1041,
1,0,0,0,72,1043,1,0,0,0,74,1075,1,0,0,0,76,1098,1,0,0,0,78,1163,1,0,0,0,
80,1165,1,0,0,0,82,1168,1,0,0,0,84,1175,1,0,0,0,86,1184,1,0,0,0,88,1191,
1,0,0,0,90,1213,1,0,0,0,92,1224,1,0,0,0,94,1226,1,0,0,0,96,1236,1,0,0,0,
98,1243,1,0,0,0,100,1249,1,0,0,0,102,1263,1,0,0,0,104,1278,1,0,0,0,106,1281,
1,0,0,0,108,1285,1,0,0,0,110,1293,1,0,0,0,112,1300,1,0,0,0,114,1312,1,0,
0,0,116,1314,1,0,0,0,118,1333,1,0,0,0,120,1339,1,0,0,0,122,1344,1,0,0,0,
124,1346,1,0,0,0,126,1365,1,0,0,0,128,1371,1,0,0,0,130,1374,1,0,0,0,132,
1393,1,0,0,0,134,1406,1,0,0,0,136,1408,1,0,0,0,138,1411,1,0,0,0,140,1423,
1,0,0,0,142,1436,1,0,0,0,144,1451,1,0,0,0,146,1453,1,0,0,0,148,1466,1,0,
0,0,150,1477,1,0,0,0,152,1479,1,0,0,0,154,1491,1,0,0,0,156,1494,1,0,0,0,
158,1506,1,0,0,0,160,1515,1,0,0,0,162,1517,1,0,0,0,164,1543,1,0,0,0,166,
1556,1,0,0,0,168,1558,1,0,0,0,170,1560,1,0,0,0,172,1563,1,0,0,0,174,1569,
1,0,0,0,176,1572,1,0,0,0,178,1575,1,0,0,0,180,1577,1,0,0,0,182,1579,1,0,
0,0,184,1587,1,0,0,0,186,1601,1,0,0,0,188,1603,1,0,0,0,190,1610,1,0,0,0,
192,1617,1,0,0,0,194,1635,1,0,0,0,196,1653,1,0,0,0,198,1655,1,0,0,0,200,
1657,1,0,0,0,202,1664,1,0,0,0,204,1671,1,0,0,0,206,1673,1,0,0,0,208,1676,
1,0,0,0,210,1680,1,0,0,0,212,1682,1,0,0,0,214,1685,1,0,0,0,216,1699,1,0,
0,0,218,1767,1,0,0,0,220,1769,1,0,0,0,222,1771,1,0,0,0,224,1779,1,0,0,0,
226,1787,1,0,0,0,228,1798,1,0,0,0,230,1813,1,0,0,0,232,1822,1,0,0,0,234,
1824,1,0,0,0,236,1827,1,0,0,0,238,1836,1,0,0,0,240,1843,1,0,0,0,242,1847,
1,0,0,0,244,1849,1,0,0,0,246,1862,1,0,0,0,248,1871,1,0,0,0,250,1873,1,0,
0,0,252,1877,1,0,0,0,254,1880,1,0,0,0,256,1889,1,0,0,0,258,1898,1,0,0,0,
260,1904,1,0,0,0,262,1906,1,0,0,0,264,1914,1,0,0,0,266,1919,1,0,0,0,268,
1933,1,0,0,0,270,1942,1,0,0,0,272,1957,1,0,0,0,274,1966,1,0,0,0,276,1977,
1,0,0,0,278,1980,1,0,0,0,280,1984,1,0,0,0,282,2068,1,0,0,0,284,2079,1,0,
0,0,286,2081,1,0,0,0,288,2085,1,0,0,0,290,2091,1,0,0,0,292,2114,1,0,0,0,
294,2116,1,0,0,0,296,2125,1,0,0,0,298,2128,1,0,0,0,300,2133,1,0,0,0,302,
2186,1,0,0,0,304,2188,1,0,0,0,306,2266,1,0,0,0,308,2270,1,0,0,0,310,2272,
1,0,0,0,312,2275,1,0,0,0,314,2279,1,0,0,0,316,2283,1,0,0,0,318,2285,1,0,
0,0,320,2291,1,0,0,0,322,2309,1,0,0,0,324,2326,1,0,0,0,326,2328,1,0,0,0,
328,2336,1,0,0,0,330,2362,1,0,0,0,332,2364,1,0,0,0,334,2374,1,0,0,0,336,
2376,1,0,0,0,338,2416,1,0,0,0,340,2436,1,0,0,0,342,2438,1,0,0,0,344,2453,
1,0,0,0,346,2472,1,0,0,0,348,2474,1,0,0,0,350,2477,1,0,0,0,352,2484,1,0,
0,0,354,2487,1,0,0,0,356,2496,1,0,0,0,358,2498,1,0,0,0,360,2503,1,0,0,0,
362,2505,1,0,0,0,364,2507,1,0,0,0,366,2510,1,0,0,0,368,2514,1,0,0,0,370,
2518,1,0,0,0,372,2524,1,0,0,0,374,2551,1,0,0,0,376,2560,1,0,0,0,378,2571,
1,0,0,0,380,2578,1,0,0,0,382,2580,1,0,0,0,384,2594,1,0,0,0,386,2598,1,0,
0,0,388,2606,1,0,0,0,390,2608,1,0,0,0,392,2621,1,0,0,0,394,2623,1,0,0,0,
396,2633,1,0,0,0,398,2637,1,0,0,0,400,2641,1,0,0,0,402,2648,1,0,0,0,404,
2656,1,0,0,0,406,2658,1,0,0,0,408,2678,1,0,0,0,410,2683,1,0,0,0,412,2690,
1,0,0,0,414,2697,1,0,0,0,416,2701,1,0,0,0,418,2708,1,0,0,0,420,2724,1,0,
0,0,422,2731,1,0,0,0,424,2738,1,0,0,0,426,2743,1,0,0,0,428,2747,1,0,0,0,
430,2752,1,0,0,0,432,2759,1,0,0,0,434,2763,1,0,0,0,436,2770,1,0,0,0,438,
2774,1,0,0,0,440,2779,1,0,0,0,442,2781,1,0,0,0,444,2790,1,0,0,0,446,2797,
1,0,0,0,448,2799,1,0,0,0,450,2801,1,0,0,0,452,2810,1,0,0,0,454,2812,1,0,
0,0,456,2817,1,0,0,0,458,2826,1,0,0,0,460,2833,1,0,0,0,462,2838,1,0,0,0,
464,2844,1,0,0,0,466,2855,1,0,0,0,468,2861,1,0,0,0,470,2865,1,0,0,0,472,
2868,1,0,0,0,474,2872,1,0,0,0,476,2877,1,0,0,0,478,2881,1,0,0,0,480,2891,
1,0,0,0,482,2895,1,0,0,0,484,2906,1,0,0,0,486,2908,1,0,0,0,488,2910,1,0,
0,0,490,2912,1,0,0,0,492,2919,1,0,0,0,494,2925,1,0,0,0,496,2930,1,0,0,0,
498,2934,1,0,0,0,500,2936,1,0,0,0,502,2938,1,0,0,0,504,2940,1,0,0,0,506,
2942,1,0,0,0,508,2944,1,0,0,0,510,2946,1,0,0,0,512,514,5,132,0,0,513,512,
1,0,0,0,513,514,1,0,0,0,514,518,1,0,0,0,515,517,3,490,245,0,516,515,1,0,
0,0,517,520,1,0,0,0,518,516,1,0,0,0,518,519,1,0,0,0,519,522,1,0,0,0,520,
518,1,0,0,0,521,523,3,8,4,0,522,521,1,0,0,0,522,523,1,0,0,0,523,527,1,0,
0,0,524,526,3,490,245,0,525,524,1,0,0,0,526,529,1,0,0,0,527,525,1,0,0,0,
527,528,1,0,0,0,528,532,1,0,0,0,529,527,1,0,0,0,530,533,3,2,1,0,531,533,
3,20,10,0,532,530,1,0,0,0,532,531,1,0,0,0,533,535,1,0,0,0,534,536,5,133,
0,0,535,534,1,0,0,0,535,536,1,0,0,0,536,538,1,0,0,0,537,539,3,490,245,0,
538,537,1,0,0,0,538,539,1,0,0,0,539,540,1,0,0,0,540,541,5,0,0,1,541,1,1,
0,0,0,542,543,5,21,0,0,543,545,3,492,246,0,544,546,3,24,12,0,545,544,1,0,
0,0,545,546,1,0,0,0,546,547,1,0,0,0,547,548,3,4,2,0,548,3,1,0,0,0,549,550,
5,27,0,0,550,551,3,6,3,0,551,5,1,0,0,0,552,553,3,486,243,0,553,554,3,20,
10,0,554,558,3,488,244,0,555,557,3,490,245,0,556,555,1,0,0,0,557,560,1,0,
0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,7,1,0,0,0,560,558,1,0,0,0,561,563,
3,10,5,0,562,561,1,0,0,0,563,564,1,0,0,0,564,562,1,0,0,0,564,565,1,0,0,0,
565,9,1,0,0,0,566,570,3,12,6,0,567,570,3,14,7,0,568,570,3,16,8,0,569,566,
1,0,0,0,569,567,1,0,0,0,569,568,1,0,0,0,570,11,1,0,0,0,571,572,5,128,0,0,
572,573,5,51,0,0,573,578,3,18,9,0,574,575,5,102,0,0,575,577,3,18,9,0,576,
574,1,0,0,0,577,580,1,0,0,0,578,576,1,0,0,0,578,579,1,0,0,0,579,581,1,0,
0,0,580,578,1,0,0,0,581,583,5,129,0,0,582,584,3,490,245,0,583,582,1,0,0,
0,583,584,1,0,0,0,584,13,1,0,0,0,585,586,5,128,0,0,586,594,5,52,0,0,587,
590,5,90,0,0,588,591,3,464,232,0,589,591,3,478,239,0,590,588,1,0,0,0,590,
589,1,0,0,0,591,593,1,0,0,0,592,587,1,0,0,0,593,596,1,0,0,0,594,592,1,0,
0,0,594,595,1,0,0,0,595,597,1,0,0,0,596,594,1,0,0,0,597,599,5,129,0,0,598,
600,3,490,245,0,599,598,1,0,0,0,599,600,1,0,0,0,600,15,1,0,0,0,601,602,5,
128,0,0,602,610,5,53,0,0,603,606,5,90,0,0,604,607,3,464,232,0,605,607,3,
478,239,0,606,604,1,0,0,0,606,605,1,0,0,0,607,609,1,0,0,0,608,603,1,0,0,
0,609,612,1,0,0,0,610,608,1,0,0,0,610,611,1,0,0,0,611,613,1,0,0,0,612,610,
1,0,0,0,613,615,5,129,0,0,614,616,3,490,245,0,615,614,1,0,0,0,615,616,1,
0,0,0,616,17,1,0,0,0,617,618,5,127,0,0,618,19,1,0,0,0,619,620,3,22,11,0,
620,621,3,40,20,0,621,625,1,0,0,0,622,625,3,22,11,0,623,625,3,40,20,0,624,
619,1,0,0,0,624,622,1,0,0,0,624,623,1,0,0,0,625,21,1,0,0,0,626,630,3,28,
14,0,627,630,5,1,0,0,628,630,3,490,245,0,629,626,1,0,0,0,629,627,1,0,0,0,
629,628,1,0,0,0,630,631,1,0,0,0,631,629,1,0,0,0,631,632,1,0,0,0,632,23,1,
0,0,0,633,642,5,120,0,0,634,639,3,26,13,0,635,636,5,102,0,0,636,638,3,26,
13,0,637,635,1,0,0,0,638,641,1,0,0,0,639,637,1,0,0,0,639,640,1,0,0,0,640,
643,1,0,0,0,641,639,1,0,0,0,642,634,1,0,0,0,642,643,1,0,0,0,643,645,1,0,
0,0,644,646,5,102,0,0,645,644,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,0,647,
648,5,121,0,0,648,25,1,0,0,0,649,689,3,460,230,0,650,666,3,426,213,0,651,
652,5,120,0,0,652,653,5,98,0,0,653,667,5,121,0,0,654,663,5,120,0,0,655,660,
3,34,17,0,656,657,5,102,0,0,657,659,3,34,17,0,658,656,1,0,0,0,659,662,1,
0,0,0,660,658,1,0,0,0,660,661,1,0,0,0,661,664,1,0,0,0,662,660,1,0,0,0,663,
655,1,0,0,0,663,664,1,0,0,0,664,665,1,0,0,0,665,667,5,121,0,0,666,651,1,
0,0,0,666,654,1,0,0,0,666,667,1,0,0,0,667,689,1,0,0,0,668,684,3,456,228,
0,669,670,5,120,0,0,670,671,5,98,0,0,671,685,5,121,0,0,672,681,5,120,0,0,
673,678,3,460,230,0,674,675,5,102,0,0,675,677,3,460,230,0,676,674,1,0,0,
0,677,680,1,0,0,0,678,676,1,0,0,0,678,679,1,0,0,0,679,682,1,0,0,0,680,678,
1,0,0,0,681,673,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,685,5,121,0,
0,684,669,1,0,0,0,684,672,1,0,0,0,684,685,1,0,0,0,685,689,1,0,0,0,686,687,
5,21,0,0,687,689,3,492,246,0,688,649,1,0,0,0,688,650,1,0,0,0,688,668,1,0,
0,0,688,686,1,0,0,0,689,27,1,0,0,0,690,692,5,14,0,0,691,693,5,24,0,0,692,
691,1,0,0,0,692,693,1,0,0,0,693,694,1,0,0,0,694,697,3,492,246,0,695,696,
5,4,0,0,696,698,3,492,246,0,697,695,1,0,0,0,697,698,1,0,0,0,698,700,1,0,
0,0,699,701,3,30,15,0,700,699,1,0,0,0,700,701,1,0,0,0,701,703,1,0,0,0,702,
704,3,490,245,0,703,702,1,0,0,0,704,705,1,0,0,0,705,703,1,0,0,0,705,706,
1,0,0,0,706,29,1,0,0,0,707,719,5,120,0,0,708,713,3,32,16,0,709,710,5,102,
0,0,710,712,3,32,16,0,711,709,1,0,0,0,712,715,1,0,0,0,713,711,1,0,0,0,713,
714,1,0,0,0,714,717,1,0,0,0,715,713,1,0,0,0,716,718,5,102,0,0,717,716,1,
0,0,0,717,718,1,0,0,0,718,720,1,0,0,0,719,708,1,0,0,0,719,720,1,0,0,0,720,
721,1,0,0,0,721,739,5,121,0,0,722,723,5,12,0,0,723,735,5,120,0,0,724,729,
3,32,16,0,725,726,5,102,0,0,726,728,3,32,16,0,727,725,1,0,0,0,728,731,1,
0,0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,733,1,0,0,0,731,729,1,0,0,0,732,
734,5,102,0,0,733,732,1,0,0,0,733,734,1,0,0,0,734,736,1,0,0,0,735,724,1,
0,0,0,735,736,1,0,0,0,736,737,1,0,0,0,737,739,5,121,0,0,738,707,1,0,0,0,
738,722,1,0,0,0,739,31,1,0,0,0,740,771,3,458,229,0,741,757,3,428,214,0,742,
743,5,120,0,0,743,744,5,98,0,0,744,758,5,121,0,0,745,754,5,120,0,0,746,751,
3,34,17,0,747,748,5,102,0,0,748,750,3,34,17,0,749,747,1,0,0,0,750,753,1,
0,0,0,751,749,1,0,0,0,751,752,1,0,0,0,752,755,1,0,0,0,753,751,1,0,0,0,754,
746,1,0,0,0,754,755,1,0,0,0,755,756,1,0,0,0,756,758,5,121,0,0,757,742,1,
0,0,0,757,745,1,0,0,0,757,758,1,0,0,0,758,771,1,0,0,0,759,768,3,454,227,
0,760,761,5,120,0,0,761,762,5,98,0,0,762,769,5,121,0,0,763,765,5,120,0,0,
764,766,3,182,91,0,765,764,1,0,0,0,765,766,1,0,0,0,766,767,1,0,0,0,767,769,
5,121,0,0,768,760,1,0,0,0,768,763,1,0,0,0,768,769,1,0,0,0,769,771,1,0,0,
0,770,740,1,0,0,0,770,741,1,0,0,0,770,759,1,0,0,0,771,33,1,0,0,0,772,775,
3,458,229,0,773,775,3,404,202,0,774,772,1,0,0,0,774,773,1,0,0,0,775,35,1,
0,0,0,776,777,7,0,0,0,777,37,1,0,0,0,778,783,3,434,217,0,779,780,5,102,0,
0,780,782,3,434,217,0,781,779,1,0,0,0,782,785,1,0,0,0,783,781,1,0,0,0,783,
784,1,0,0,0,784,39,1,0,0,0,785,783,1,0,0,0,786,788,3,42,21,0,787,789,3,490,
245,0,788,787,1,0,0,0,789,790,1,0,0,0,790,788,1,0,0,0,790,791,1,0,0,0,791,
795,1,0,0,0,792,795,5,1,0,0,793,795,3,490,245,0,794,786,1,0,0,0,794,792,
1,0,0,0,794,793,1,0,0,0,795,796,1,0,0,0,796,794,1,0,0,0,796,797,1,0,0,0,
797,41,1,0,0,0,798,834,3,44,22,0,799,834,3,46,23,0,800,834,3,48,24,0,801,
834,3,52,26,0,802,834,3,94,47,0,803,834,3,96,48,0,804,805,5,8,0,0,805,807,
5,120,0,0,806,808,3,224,112,0,807,806,1,0,0,0,807,808,1,0,0,0,808,809,1,
0,0,0,809,834,5,121,0,0,810,811,5,30,0,0,811,834,3,166,83,0,812,813,5,128,
0,0,813,815,5,61,0,0,814,816,3,156,78,0,815,814,1,0,0,0,815,816,1,0,0,0,
816,817,1,0,0,0,817,834,5,129,0,0,818,819,5,128,0,0,819,821,5,62,0,0,820,
822,3,152,76,0,821,820,1,0,0,0,821,822,1,0,0,0,822,823,1,0,0,0,823,834,5,
129,0,0,824,825,5,128,0,0,825,827,5,59,0,0,826,828,3,138,69,0,827,826,1,
0,0,0,827,828,1,0,0,0,828,829,1,0,0,0,829,834,5,129,0,0,830,834,3,164,82,
0,831,834,3,272,136,0,832,834,3,294,147,0,833,798,1,0,0,0,833,799,1,0,0,
0,833,800,1,0,0,0,833,801,1,0,0,0,833,802,1,0,0,0,833,803,1,0,0,0,833,804,
1,0,0,0,833,810,1,0,0,0,833,812,1,0,0,0,833,818,1,0,0,0,833,824,1,0,0,0,
833,830,1,0,0,0,833,831,1,0,0,0,833,832,1,0,0,0,834,43,1,0,0,0,835,836,5,
6,0,0,836,838,3,88,44,0,837,839,3,234,117,0,838,837,1,0,0,0,838,839,1,0,
0,0,839,841,1,0,0,0,840,842,3,120,60,0,841,840,1,0,0,0,841,842,1,0,0,0,842,
45,1,0,0,0,843,844,5,26,0,0,844,845,3,202,101,0,845,846,5,104,0,0,846,847,
3,192,96,0,847,913,1,0,0,0,848,849,5,26,0,0,849,850,5,36,0,0,850,852,3,202,
101,0,851,853,3,84,42,0,852,851,1,0,0,0,852,853,1,0,0,0,853,855,1,0,0,0,
854,856,3,62,31,0,855,854,1,0,0,0,855,856,1,0,0,0,856,858,1,0,0,0,857,859,
3,68,34,0,858,857,1,0,0,0,858,859,1,0,0,0,859,913,1,0,0,0,860,862,5,7,0,
0,861,863,3,92,46,0,862,861,1,0,0,0,862,863,1,0,0,0,863,864,1,0,0,0,864,
865,3,88,44,0,865,867,3,252,126,0,866,868,3,266,133,0,867,866,1,0,0,0,867,
868,1,0,0,0,868,913,1,0,0,0,869,871,5,22,0,0,870,872,3,92,46,0,871,870,1,
0,0,0,871,872,1,0,0,0,872,873,1,0,0,0,873,874,3,88,44,0,874,876,3,252,126,
0,875,877,3,266,133,0,876,875,1,0,0,0,876,877,1,0,0,0,877,913,1,0,0,0,878,
880,5,7,0,0,879,881,3,92,46,0,880,879,1,0,0,0,880,881,1,0,0,0,881,882,1,
0,0,0,882,884,3,88,44,0,883,885,3,80,40,0,884,883,1,0,0,0,884,885,1,0,0,
0,885,887,1,0,0,0,886,888,3,244,122,0,887,886,1,0,0,0,887,888,1,0,0,0,888,
890,1,0,0,0,889,891,3,266,133,0,890,889,1,0,0,0,890,891,1,0,0,0,891,913,
1,0,0,0,892,894,5,22,0,0,893,895,3,92,46,0,894,893,1,0,0,0,894,895,1,0,0,
0,895,896,1,0,0,0,896,898,3,88,44,0,897,899,3,80,40,0,898,897,1,0,0,0,898,
899,1,0,0,0,899,901,1,0,0,0,900,902,3,244,122,0,901,900,1,0,0,0,901,902,
1,0,0,0,902,904,1,0,0,0,903,905,3,266,133,0,904,903,1,0,0,0,904,905,1,0,
0,0,905,913,1,0,0,0,906,907,5,7,0,0,907,908,5,36,0,0,908,910,3,202,101,0,
909,911,3,82,41,0,910,909,1,0,0,0,910,911,1,0,0,0,911,913,1,0,0,0,912,843,
1,0,0,0,912,848,1,0,0,0,912,860,1,0,0,0,912,869,1,0,0,0,912,878,1,0,0,0,
912,892,1,0,0,0,912,906,1,0,0,0,913,47,1,0,0,0,914,915,5,26,0,0,915,916,
3,50,25,0,916,917,5,75,0,0,917,918,3,192,96,0,918,49,1,0,0,0,919,924,3,422,
211,0,920,921,5,102,0,0,921,923,3,422,211,0,922,920,1,0,0,0,923,926,1,0,
0,0,924,922,1,0,0,0,924,925,1,0,0,0,925,51,1,0,0,0,926,924,1,0,0,0,927,929,
5,19,0,0,928,930,3,54,27,0,929,928,1,0,0,0,929,930,1,0,0,0,930,931,1,0,0,
0,931,933,3,220,110,0,932,934,3,128,64,0,933,932,1,0,0,0,933,934,1,0,0,0,
934,987,1,0,0,0,935,936,5,26,0,0,936,937,5,19,0,0,937,987,3,74,37,0,938,
939,5,7,0,0,939,941,5,19,0,0,940,942,3,92,46,0,941,940,1,0,0,0,941,942,1,
0,0,0,942,943,1,0,0,0,943,945,3,90,45,0,944,946,3,266,133,0,945,944,1,0,
0,0,945,946,1,0,0,0,946,987,1,0,0,0,947,948,5,22,0,0,948,950,5,19,0,0,949,
951,3,92,46,0,950,949,1,0,0,0,950,951,1,0,0,0,951,952,1,0,0,0,952,954,3,
90,45,0,953,955,3,266,133,0,954,953,1,0,0,0,954,955,1,0,0,0,955,987,1,0,
0,0,956,957,5,7,0,0,957,959,5,19,0,0,958,960,3,92,46,0,959,958,1,0,0,0,959,
960,1,0,0,0,960,961,1,0,0,0,961,963,3,90,45,0,962,964,3,80,40,0,963,962,
1,0,0,0,963,964,1,0,0,0,964,966,1,0,0,0,965,967,3,244,122,0,966,965,1,0,
0,0,966,967,1,0,0,0,967,969,1,0,0,0,968,970,3,266,133,0,969,968,1,0,0,0,
969,970,1,0,0,0,970,987,1,0,0,0,971,972,5,22,0,0,972,974,5,19,0,0,973,975,
3,92,46,0,974,973,1,0,0,0,974,975,1,0,0,0,975,976,1,0,0,0,976,978,3,90,45,
0,977,979,3,80,40,0,978,977,1,0,0,0,978,979,1,0,0,0,979,981,1,0,0,0,980,
982,3,244,122,0,981,980,1,0,0,0,981,982,1,0,0,0,982,984,1,0,0,0,983,985,
3,266,133,0,984,983,1,0,0,0,984,985,1,0,0,0,985,987,1,0,0,0,986,927,1,0,
0,0,986,935,1,0,0,0,986,938,1,0,0,0,986,947,1,0,0,0,986,956,1,0,0,0,986,
971,1,0,0,0,987,53,1,0,0,0,988,989,5,128,0,0,989,990,5,69,0,0,990,1001,5,
129,0,0,991,992,5,128,0,0,992,993,5,68,0,0,993,1001,5,129,0,0,994,995,5,
128,0,0,995,996,5,70,0,0,996,1001,5,129,0,0,997,998,5,128,0,0,998,999,5,
71,0,0,999,1001,5,129,0,0,1000,988,1,0,0,0,1000,991,1,0,0,0,1000,994,1,0,
0,0,1000,997,1,0,0,0,1001,55,1,0,0,0,1002,1003,7,1,0,0,1003,57,1,0,0,0,1004,
1005,5,50,0,0,1005,1006,3,190,95,0,1006,59,1,0,0,0,1007,1012,5,48,0,0,1008,
1012,5,49,0,0,1009,1012,5,22,0,0,1010,1012,3,58,29,0,1011,1007,1,0,0,0,1011,
1008,1,0,0,0,1011,1009,1,0,0,0,1011,1010,1,0,0,0,1012,61,1,0,0,0,1013,1014,
5,86,0,0,1014,1015,3,64,32,0,1015,63,1,0,0,0,1016,1017,3,452,226,0,1017,
1018,5,76,0,0,1018,1019,3,66,33,0,1019,65,1,0,0,0,1020,1022,3,452,226,0,
1021,1020,1,0,0,0,1022,1023,1,0,0,0,1023,1021,1,0,0,0,1023,1024,1,0,0,0,
1024,67,1,0,0,0,1025,1026,5,27,0,0,1026,1027,3,70,35,0,1027,69,1,0,0,0,1028,
1030,3,486,243,0,1029,1031,3,72,36,0,1030,1029,1,0,0,0,1030,1031,1,0,0,0,
1031,1032,1,0,0,0,1032,1033,3,488,244,0,1033,1042,1,0,0,0,1034,1035,5,132,
0,0,1035,1036,5,98,0,0,1036,1042,5,133,0,0,1037,1038,3,486,243,0,1038,1039,
5,98,0,0,1039,1040,3,488,244,0,1040,1042,1,0,0,0,1041,1028,1,0,0,0,1041,
1034,1,0,0,0,1041,1037,1,0,0,0,1042,71,1,0,0,0,1043,1053,3,74,37,0,1044,
1046,3,490,245,0,1045,1044,1,0,0,0,1046,1047,1,0,0,0,1047,1045,1,0,0,0,1047,
1048,1,0,0,0,1048,1049,1,0,0,0,1049,1050,3,74,37,0,1050,1052,1,0,0,0,1051,
1045,1,0,0,0,1052,1055,1,0,0,0,1053,1051,1,0,0,0,1053,1054,1,0,0,0,1054,
1059,1,0,0,0,1055,1053,1,0,0,0,1056,1058,3,490,245,0,1057,1056,1,0,0,0,1058,
1061,1,0,0,0,1059,1057,1,0,0,0,1059,1060,1,0,0,0,1060,73,1,0,0,0,1061,1059,
1,0,0,0,1062,1064,5,29,0,0,1063,1065,3,228,114,0,1064,1063,1,0,0,0,1064,
1065,1,0,0,0,1065,1066,1,0,0,0,1066,1067,5,99,0,0,1067,1068,3,202,101,0,
1068,1069,5,104,0,0,1069,1070,3,190,95,0,1070,1076,1,0,0,0,1071,1072,3,202,
101,0,1072,1073,5,104,0,0,1073,1074,3,190,95,0,1074,1076,1,0,0,0,1075,1062,
1,0,0,0,1075,1071,1,0,0,0,1076,75,1,0,0,0,1077,1079,5,7,0,0,1078,1080,5,
36,0,0,1079,1078,1,0,0,0,1079,1080,1,0,0,0,1080,1081,1,0,0,0,1081,1083,3,
202,101,0,1082,1084,3,82,41,0,1083,1082,1,0,0,0,1083,1084,1,0,0,0,1084,1099,
1,0,0,0,1085,1087,5,26,0,0,1086,1088,5,36,0,0,1087,1086,1,0,0,0,1087,1088,
1,0,0,0,1088,1089,1,0,0,0,1089,1091,3,202,101,0,1090,1092,3,86,43,0,1091,
1090,1,0,0,0,1091,1092,1,0,0,0,1092,1099,1,0,0,0,1093,1095,5,26,0,0,1094,
1096,5,19,0,0,1095,1094,1,0,0,0,1095,1096,1,0,0,0,1096,1097,1,0,0,0,1097,
1099,3,74,37,0,1098,1077,1,0,0,0,1098,1085,1,0,0,0,1098,1093,1,0,0,0,1099,
77,1,0,0,0,1100,1102,5,26,0,0,1101,1103,5,19,0,0,1102,1101,1,0,0,0,1102,
1103,1,0,0,0,1103,1104,1,0,0,0,1104,1164,3,74,37,0,1105,1107,5,7,0,0,1106,
1108,5,19,0,0,1107,1106,1,0,0,0,1107,1108,1,0,0,0,1108,1110,1,0,0,0,1109,
1111,3,92,46,0,1110,1109,1,0,0,0,1110,1111,1,0,0,0,1111,1112,1,0,0,0,1112,
1113,3,90,45,0,1113,1115,3,252,126,0,1114,1116,3,266,133,0,1115,1114,1,0,
0,0,1115,1116,1,0,0,0,1116,1164,1,0,0,0,1117,1119,5,22,0,0,1118,1120,5,19,
0,0,1119,1118,1,0,0,0,1119,1120,1,0,0,0,1120,1122,1,0,0,0,1121,1123,3,92,
46,0,1122,1121,1,0,0,0,1122,1123,1,0,0,0,1123,1124,1,0,0,0,1124,1125,3,90,
45,0,1125,1127,3,252,126,0,1126,1128,3,266,133,0,1127,1126,1,0,0,0,1127,
1128,1,0,0,0,1128,1164,1,0,0,0,1129,1131,5,7,0,0,1130,1132,5,19,0,0,1131,
1130,1,0,0,0,1131,1132,1,0,0,0,1132,1134,1,0,0,0,1133,1135,3,92,46,0,1134,
1133,1,0,0,0,1134,1135,1,0,0,0,1135,1136,1,0,0,0,1136,1138,3,90,45,0,1137,
1139,3,80,40,0,1138,1137,1,0,0,0,1138,1139,1,0,0,0,1139,1141,1,0,0,0,1140,
1142,3,244,122,0,1141,1140,1,0,0,0,1141,1142,1,0,0,0,1142,1144,1,0,0,0,1143,
1145,3,266,133,0,1144,1143,1,0,0,0,1144,1145,1,0,0,0,1145,1164,1,0,0,0,1146,
1148,5,22,0,0,1147,1149,5,19,0,0,1148,1147,1,0,0,0,1148,1149,1,0,0,0,1149,
1151,1,0,0,0,1150,1152,3,92,46,0,1151,1150,1,0,0,0,1151,1152,1,0,0,0,1152,
1153,1,0,0,0,1153,1155,3,90,45,0,1154,1156,3,80,40,0,1155,1154,1,0,0,0,1155,
1156,1,0,0,0,1156,1158,1,0,0,0,1157,1159,3,244,122,0,1158,1157,1,0,0,0,1158,
1159,1,0,0,0,1159,1161,1,0,0,0,1160,1162,3,266,133,0,1161,1160,1,0,0,0,1161,
1162,1,0,0,0,1162,1164,1,0,0,0,1163,1100,1,0,0,0,1163,1105,1,0,0,0,1163,
1117,1,0,0,0,1163,1129,1,0,0,0,1163,1146,1,0,0,0,1164,79,1,0,0,0,1165,1166,
5,75,0,0,1166,1167,3,242,121,0,1167,81,1,0,0,0,1168,1169,5,75,0,0,1169,1170,
3,242,121,0,1170,83,1,0,0,0,1171,1172,5,75,0,0,1172,1176,3,242,121,0,1173,
1174,5,104,0,0,1174,1176,3,230,115,0,1175,1171,1,0,0,0,1175,1173,1,0,0,0,
1176,85,1,0,0,0,1177,1178,5,75,0,0,1178,1185,3,242,121,0,1179,1180,5,104,
0,0,1180,1181,3,232,116,0,1181,1182,5,86,0,0,1182,1183,3,64,32,0,1183,1185,
1,0,0,0,1184,1177,1,0,0,0,1184,1179,1,0,0,0,1185,87,1,0,0,0,1186,1187,3,
198,99,0,1187,1188,5,74,0,0,1188,1189,3,202,101,0,1189,1192,1,0,0,0,1190,
1192,3,202,101,0,1191,1186,1,0,0,0,1191,1190,1,0,0,0,1192,89,1,0,0,0,1193,
1195,5,29,0,0,1194,1196,3,228,114,0,1195,1194,1,0,0,0,1195,1196,1,0,0,0,
1196,1197,1,0,0,0,1197,1198,5,99,0,0,1198,1199,3,198,99,0,1199,1200,5,74,
0,0,1200,1201,3,202,101,0,1201,1214,1,0,0,0,1202,1204,5,29,0,0,1203,1205,
3,228,114,0,1204,1203,1,0,0,0,1204,1205,1,0,0,0,1205,1206,1,0,0,0,1206,1207,
5,99,0,0,1207,1214,3,202,101,0,1208,1209,3,198,99,0,1209,1210,5,74,0,0,1210,
1211,3,202,101,0,1211,1214,1,0,0,0,1212,1214,3,202,101,0,1213,1193,1,0,0,
0,1213,1202,1,0,0,0,1213,1208,1,0,0,0,1213,1212,1,0,0,0,1214,91,1,0,0,0,
1215,1216,5,128,0,0,1216,1217,5,67,0,0,1217,1218,5,125,0,0,1218,1219,5,125,
0,0,1219,1225,5,129,0,0,1220,1221,5,128,0,0,1221,1222,5,67,0,0,1222,1223,
5,125,0,0,1223,1225,5,129,0,0,1224,1215,1,0,0,0,1224,1220,1,0,0,0,1225,93,
1,0,0,0,1226,1228,5,9,0,0,1227,1229,3,60,30,0,1228,1227,1,0,0,0,1228,1229,
1,0,0,0,1229,1230,1,0,0,0,1230,1232,5,19,0,0,1231,1233,3,54,27,0,1232,1231,
1,0,0,0,1232,1233,1,0,0,0,1233,1234,1,0,0,0,1234,1235,3,220,110,0,1235,95,
1,0,0,0,1236,1237,5,26,0,0,1237,1238,5,37,0,0,1238,1240,3,422,211,0,1239,
1241,3,98,49,0,1240,1239,1,0,0,0,1240,1241,1,0,0,0,1241,97,1,0,0,0,1242,
1244,3,100,50,0,1243,1242,1,0,0,0,1244,1245,1,0,0,0,1245,1243,1,0,0,0,1245,
1246,1,0,0,0,1246,99,1,0,0,0,1247,1250,3,464,232,0,1248,1250,5,28,0,0,1249,
1247,1,0,0,0,1249,1248,1,0,0,0,1250,101,1,0,0,0,1251,1252,5,47,0,0,1252,
1253,3,104,52,0,1253,1254,5,104,0,0,1254,1255,3,360,180,0,1255,1264,1,0,
0,0,1256,1257,5,47,0,0,1257,1258,3,104,52,0,1258,1259,5,77,0,0,1259,1261,
3,360,180,0,1260,1262,3,110,55,0,1261,1260,1,0,0,0,1261,1262,1,0,0,0,1262,
1264,1,0,0,0,1263,1251,1,0,0,0,1263,1256,1,0,0,0,1264,103,1,0,0,0,1265,1267,
3,404,202,0,1266,1268,3,106,53,0,1267,1266,1,0,0,0,1267,1268,1,0,0,0,1268,
1279,1,0,0,0,1269,1270,3,464,232,0,1270,1271,3,412,206,0,1271,1272,3,464,
232,0,1272,1279,1,0,0,0,1273,1274,3,404,202,0,1274,1275,5,132,0,0,1275,1276,
3,108,54,0,1276,1277,5,133,0,0,1277,1279,1,0,0,0,1278,1265,1,0,0,0,1278,
1269,1,0,0,0,1278,1273,1,0,0,0,1279,105,1,0,0,0,1280,1282,3,464,232,0,1281,
1280,1,0,0,0,1282,1283,1,0,0,0,1283,1281,1,0,0,0,1283,1284,1,0,0,0,1284,
107,1,0,0,0,1285,1290,3,458,229,0,1286,1287,5,102,0,0,1287,1289,3,458,229,
0,1288,1286,1,0,0,0,1289,1292,1,0,0,0,1290,1288,1,0,0,0,1290,1291,1,0,0,
0,1291,109,1,0,0,0,1292,1290,1,0,0,0,1293,1294,5,27,0,0,1294,1296,3,486,
243,0,1295,1297,3,130,65,0,1296,1295,1,0,0,0,1296,1297,1,0,0,0,1297,1298,
1,0,0,0,1298,1299,3,488,244,0,1299,111,1,0,0,0,1300,1301,5,47,0,0,1301,1302,
3,406,203,0,1302,1303,5,75,0,0,1303,1304,3,180,90,0,1304,113,1,0,0,0,1305,
1313,3,76,38,0,1306,1313,3,274,137,0,1307,1308,5,8,0,0,1308,1309,3,294,147,
0,1309,1310,5,75,0,0,1310,1311,3,180,90,0,1311,1313,1,0,0,0,1312,1305,1,
0,0,0,1312,1306,1,0,0,0,1312,1307,1,0,0,0,1313,115,1,0,0,0,1314,1324,3,114,
57,0,1315,1317,3,490,245,0,1316,1315,1,0,0,0,1317,1318,1,0,0,0,1318,1316,
1,0,0,0,1318,1319,1,0,0,0,1319,1320,1,0,0,0,1320,1321,3,114,57,0,1321,1323,
1,0,0,0,1322,1316,1,0,0,0,1323,1326,1,0,0,0,1324,1322,1,0,0,0,1324,1325,
1,0,0,0,1325,1330,1,0,0,0,1326,1324,1,0,0,0,1327,1329,3,490,245,0,1328,1327,
1,0,0,0,1329,1332,1,0,0,0,1330,1328,1,0,0,0,1330,1331,1,0,0,0,1331,117,1,
0,0,0,1332,1330,1,0,0,0,1333,1335,3,486,243,0,1334,1336,3,116,58,0,1335,
1334,1,0,0,0,1335,1336,1,0,0,0,1336,1337,1,0,0,0,1337,1338,3,488,244,0,1338,
119,1,0,0,0,1339,1340,5,27,0,0,1340,1341,3,118,59,0,1341,121,1,0,0,0,1342,
1345,3,78,39,0,1343,1345,3,274,137,0,1344,1342,1,0,0,0,1344,1343,1,0,0,0,
1345,123,1,0,0,0,1346,1356,3,122,61,0,1347,1349,3,490,245,0,1348,1347,1,
0,0,0,1349,1350,1,0,0,0,1350,1348,1,0,0,0,1350,1351,1,0,0,0,1351,1352,1,
0,0,0,1352,1353,3,122,61,0,1353,1355,1,0,0,0,1354,1348,1,0,0,0,1355,1358,
1,0,0,0,1356,1354,1,0,0,0,1356,1357,1,0,0,0,1357,1362,1,0,0,0,1358,1356,
1,0,0,0,1359,1361,3,490,245,0,1360,1359,1,0,0,0,1361,1364,1,0,0,0,1362,1360,
1,0,0,0,1362,1363,1,0,0,0,1363,125,1,0,0,0,1364,1362,1,0,0,0,1365,1367,3,
486,243,0,1366,1368,3,124,62,0,1367,1366,1,0,0,0,1367,1368,1,0,0,0,1368,
1369,1,0,0,0,1369,1370,3,488,244,0,1370,127,1,0,0,0,1371,1372,5,27,0,0,1372,
1373,3,126,63,0,1373,129,1,0,0,0,1374,1384,3,274,137,0,1375,1377,3,490,245,
0,1376,1375,1,0,0,0,1377,1378,1,0,0,0,1378,1376,1,0,0,0,1378,1379,1,0,0,
0,1379,1380,1,0,0,0,1380,1381,3,274,137,0,1381,1383,1,0,0,0,1382,1376,1,
0,0,0,1383,1386,1,0,0,0,1384,1382,1,0,0,0,1384,1385,1,0,0,0,1385,1390,1,
0,0,0,1386,1384,1,0,0,0,1387,1389,3,490,245,0,1388,1387,1,0,0,0,1389,1392,
1,0,0,0,1390,1388,1,0,0,0,1390,1391,1,0,0,0,1391,131,1,0,0,0,1392,1390,1,
0,0,0,1393,1395,3,486,243,0,1394,1396,3,130,65,0,1395,1394,1,0,0,0,1395,
1396,1,0,0,0,1396,1397,1,0,0,0,1397,1398,3,488,244,0,1398,133,1,0,0,0,1399,
1407,3,132,66,0,1400,1402,3,486,243,0,1401,1403,3,382,191,0,1402,1401,1,
0,0,0,1402,1403,1,0,0,0,1403,1404,1,0,0,0,1404,1405,3,488,244,0,1405,1407,
1,0,0,0,1406,1399,1,0,0,0,1406,1400,1,0,0,0,1407,135,1,0,0,0,1408,1409,5,
27,0,0,1409,1410,3,134,67,0,1410,137,1,0,0,0,1411,1417,3,140,70,0,1412,1413,
3,490,245,0,1413,1414,3,140,70,0,1414,1416,1,0,0,0,1415,1412,1,0,0,0,1416,
1419,1,0,0,0,1417,1415,1,0,0,0,1417,1418,1,0,0,0,1418,1421,1,0,0,0,1419,
1417,1,0,0,0,1420,1422,3,490,245,0,1421,1420,1,0,0,0,1421,1422,1,0,0,0,1422,
139,1,0,0,0,1423,1425,3,510,255,0,1424,1426,3,144,72,0,1425,1424,1,0,0,0,
1425,1426,1,0,0,0,1426,1428,1,0,0,0,1427,1429,3,146,73,0,1428,1427,1,0,0,
0,1428,1429,1,0,0,0,1429,1430,1,0,0,0,1430,1431,3,294,147,0,1431,1432,5,
104,0,0,1432,1433,3,292,146,0,1433,141,1,0,0,0,1434,1437,5,94,0,0,1435,1437,
3,470,235,0,1436,1434,1,0,0,0,1436,1435,1,0,0,0,1437,143,1,0,0,0,1438,1439,
5,122,0,0,1439,1440,3,504,252,0,1440,1441,5,123,0,0,1441,1452,1,0,0,0,1442,
1443,5,122,0,0,1443,1444,3,142,71,0,1444,1445,3,504,252,0,1445,1446,5,123,
0,0,1446,1452,1,0,0,0,1447,1448,5,122,0,0,1448,1449,3,142,71,0,1449,1450,
5,123,0,0,1450,1452,1,0,0,0,1451,1438,1,0,0,0,1451,1442,1,0,0,0,1451,1447,
1,0,0,0,1452,145,1,0,0,0,1453,1455,5,29,0,0,1454,1456,3,148,74,0,1455,1454,
1,0,0,0,1455,1456,1,0,0,0,1456,1457,1,0,0,0,1457,1463,5,99,0,0,1458,1460,
5,29,0,0,1459,1461,3,148,74,0,1460,1459,1,0,0,0,1460,1461,1,0,0,0,1461,1462,
1,0,0,0,1462,1464,5,99,0,0,1463,1458,1,0,0,0,1463,1464,1,0,0,0,1464,147,
1,0,0,0,1465,1467,3,150,75,0,1466,1465,1,0,0,0,1467,1468,1,0,0,0,1468,1466,
1,0,0,0,1468,1469,1,0,0,0,1469,149,1,0,0,0,1470,1478,3,464,232,0,1471,1472,
5,120,0,0,1472,1473,3,464,232,0,1473,1474,5,75,0,0,1474,1475,3,194,97,0,
1475,1476,5,121,0,0,1476,1478,1,0,0,0,1477,1470,1,0,0,0,1477,1471,1,0,0,
0,1478,151,1,0,0,0,1479,1485,3,154,77,0,1480,1481,3,490,245,0,1481,1482,
3,154,77,0,1482,1484,1,0,0,0,1483,1480,1,0,0,0,1484,1487,1,0,0,0,1485,1483,
1,0,0,0,1485,1486,1,0,0,0,1486,1489,1,0,0,0,1487,1485,1,0,0,0,1488,1490,
3,490,245,0,1489,1488,1,0,0,0,1489,1490,1,0,0,0,1490,153,1,0,0,0,1491,1492,
3,394,197,0,1492,1493,3,160,80,0,1493,155,1,0,0,0,1494,1500,3,158,79,0,1495,
1496,3,490,245,0,1496,1497,3,158,79,0,1497,1499,1,0,0,0,1498,1495,1,0,0,
0,1499,1502,1,0,0,0,1500,1498,1,0,0,0,1500,1501,1,0,0,0,1501,1504,1,0,0,
0,1502,1500,1,0,0,0,1503,1505,3,490,245,0,1504,1503,1,0,0,0,1504,1505,1,
0,0,0,1505,157,1,0,0,0,1506,1507,3,394,197,0,1507,1508,3,160,80,0,1508,159,
1,0,0,0,1509,1516,3,510,255,0,1510,1512,5,122,0,0,1511,1513,3,162,81,0,1512,
1511,1,0,0,0,1512,1513,1,0,0,0,1513,1514,1,0,0,0,1514,1516,5,123,0,0,1515,
1509,1,0,0,0,1515,1510,1,0,0,0,1516,161,1,0,0,0,1517,1522,3,510,255,0,1518,
1519,5,102,0,0,1519,1521,3,510,255,0,1520,1518,1,0,0,0,1521,1524,1,0,0,0,
1522,1520,1,0,0,0,1522,1523,1,0,0,0,1523,163,1,0,0,0,1524,1522,1,0,0,0,1525,
1526,5,128,0,0,1526,1527,5,65,0,0,1527,1528,3,396,198,0,1528,1529,3,302,
151,0,1529,1530,5,129,0,0,1530,1544,1,0,0,0,1531,1532,5,128,0,0,1532,1533,
5,65,0,0,1533,1534,3,428,214,0,1534,1535,3,302,151,0,1535,1536,5,129,0,0,
1536,1544,1,0,0,0,1537,1538,5,128,0,0,1538,1539,5,65,0,0,1539,1540,5,21,
0,0,1540,1541,3,302,151,0,1541,1542,5,129,0,0,1542,1544,1,0,0,0,1543,1525,
1,0,0,0,1543,1531,1,0,0,0,1543,1537,1,0,0,0,1544,165,1,0,0,0,1545,1546,5,
14,0,0,1546,1548,3,168,84,0,1547,1549,3,170,85,0,1548,1547,1,0,0,0,1548,
1549,1,0,0,0,1549,1550,1,0,0,0,1550,1551,3,172,86,0,1551,1557,1,0,0,0,1552,
1553,5,31,0,0,1553,1554,3,168,84,0,1554,1555,3,172,86,0,1555,1557,1,0,0,
0,1556,1545,1,0,0,0,1556,1552,1,0,0,0,1557,167,1,0,0,0,1558,1559,7,2,0,0,
1559,169,1,0,0,0,1560,1561,7,3,0,0,1561,171,1,0,0,0,1562,1564,3,510,255,
0,1563,1562,1,0,0,0,1563,1564,1,0,0,0,1564,1565,1,0,0,0,1565,1566,3,458,
229,0,1566,1567,5,75,0,0,1567,1568,3,180,90,0,1568,173,1,0,0,0,1569,1570,
5,75,0,0,1570,1571,3,178,89,0,1571,175,1,0,0,0,1572,1573,5,75,0,0,1573,1574,
3,418,209,0,1574,177,1,0,0,0,1575,1576,3,194,97,0,1576,179,1,0,0,0,1577,
1578,3,196,98,0,1578,181,1,0,0,0,1579,1584,3,458,229,0,1580,1581,5,102,0,
0,1581,1583,3,458,229,0,1582,1580,1,0,0,0,1583,1586,1,0,0,0,1584,1582,1,
0,0,0,1584,1585,1,0,0,0,1585,183,1,0,0,0,1586,1584,1,0,0,0,1587,1592,3,178,
89,0,1588,1589,5,102,0,0,1589,1591,3,178,89,0,1590,1588,1,0,0,0,1591,1594,
1,0,0,0,1592,1590,1,0,0,0,1592,1593,1,0,0,0,1593,185,1,0,0,0,1594,1592,1,
0,0,0,1595,1596,5,128,0,0,1596,1597,5,63,0,0,1597,1602,5,129,0,0,1598,1599,
5,128,0,0,1599,1600,5,64,0,0,1600,1602,5,129,0,0,1601,1595,1,0,0,0,1601,
1598,1,0,0,0,1602,187,1,0,0,0,1603,1604,7,4,0,0,1604,189,1,0,0,0,1605,1611,
3,194,97,0,1606,1607,3,194,97,0,1607,1608,5,75,0,0,1608,1609,3,242,121,0,
1609,1611,1,0,0,0,1610,1605,1,0,0,0,1610,1606,1,0,0,0,1611,191,1,0,0,0,1612,
1618,3,196,98,0,1613,1614,3,196,98,0,1614,1615,5,75,0,0,1615,1616,3,242,
121,0,1616,1618,1,0,0,0,1617,1612,1,0,0,0,1617,1613,1,0,0,0,1618,193,1,0,
0,0,1619,1621,5,29,0,0,1620,1622,3,228,114,0,1621,1620,1,0,0,0,1621,1622,
1,0,0,0,1622,1623,1,0,0,0,1623,1624,3,188,94,0,1624,1625,3,194,97,0,1625,
1636,1,0,0,0,1626,1627,3,212,106,0,1627,1628,5,74,0,0,1628,1629,3,194,97,
0,1629,1636,1,0,0,0,1630,1631,3,458,229,0,1631,1632,5,75,0,0,1632,1633,3,
202,101,0,1633,1636,1,0,0,0,1634,1636,3,202,101,0,1635,1619,1,0,0,0,1635,
1626,1,0,0,0,1635,1630,1,0,0,0,1635,1634,1,0,0,0,1636,195,1,0,0,0,1637,1639,
5,29,0,0,1638,1640,3,228,114,0,1639,1638,1,0,0,0,1639,1640,1,0,0,0,1640,
1641,1,0,0,0,1641,1642,3,188,94,0,1642,1643,3,196,98,0,1643,1654,1,0,0,0,
1644,1645,3,198,99,0,1645,1646,5,74,0,0,1646,1647,3,196,98,0,1647,1654,1,
0,0,0,1648,1649,3,458,229,0,1649,1650,5,75,0,0,1650,1651,3,202,101,0,1651,
1654,1,0,0,0,1652,1654,3,204,102,0,1653,1637,1,0,0,0,1653,1644,1,0,0,0,1653,
1648,1,0,0,0,1653,1652,1,0,0,0,1654,197,1,0,0,0,1655,1656,3,212,106,0,1656,
199,1,0,0,0,1657,1658,3,206,103,0,1658,201,1,0,0,0,1659,1665,3,212,106,0,
1660,1661,3,212,106,0,1661,1662,5,76,0,0,1662,1663,3,194,97,0,1663,1665,
1,0,0,0,1664,1659,1,0,0,0,1664,1660,1,0,0,0,1665,203,1,0,0,0,1666,1672,3,
212,106,0,1667,1668,3,212,106,0,1668,1669,5,76,0,0,1669,1670,3,196,98,0,
1670,1672,1,0,0,0,1671,1666,1,0,0,0,1671,1667,1,0,0,0,1672,205,1,0,0,0,1673,
1674,3,208,104,0,1674,207,1,0,0,0,1675,1677,3,210,105,0,1676,1675,1,0,0,
0,1677,1678,1,0,0,0,1678,1676,1,0,0,0,1678,1679,1,0,0,0,1679,209,1,0,0,0,
1680,1681,3,216,108,0,1681,211,1,0,0,0,1682,1683,3,214,107,0,1683,213,1,
0,0,0,1684,1686,3,216,108,0,1685,1684,1,0,0,0,1686,1687,1,0,0,0,1687,1685,
1,0,0,0,1687,1688,1,0,0,0,1688,215,1,0,0,0,1689,1700,3,218,109,0,1690,1691,
5,95,0,0,1691,1700,3,218,109,0,1692,1700,3,424,212,0,1693,1700,3,450,225,
0,1694,1695,5,105,0,0,1695,1700,3,414,207,0,1696,1697,5,105,0,0,1697,1700,
3,436,218,0,1698,1700,3,186,93,0,1699,1689,1,0,0,0,1699,1690,1,0,0,0,1699,
1692,1,0,0,0,1699,1693,1,0,0,0,1699,1694,1,0,0,0,1699,1696,1,0,0,0,1699,
1698,1,0,0,0,1700,217,1,0,0,0,1701,1768,3,420,210,0,1702,1768,3,448,224,
0,1703,1768,5,91,0,0,1704,1705,5,94,0,0,1705,1768,3,218,109,0,1706,1707,
5,87,0,0,1707,1768,3,218,109,0,1708,1710,5,132,0,0,1709,1711,3,262,131,0,
1710,1709,1,0,0,0,1710,1711,1,0,0,0,1711,1712,1,0,0,0,1712,1768,5,133,0,
0,1713,1714,5,120,0,0,1714,1768,5,121,0,0,1715,1716,5,120,0,0,1716,1717,
3,190,95,0,1717,1718,5,102,0,0,1718,1719,3,224,112,0,1719,1720,5,121,0,0,
1720,1768,1,0,0,0,1721,1722,5,118,0,0,1722,1768,5,119,0,0,1723,1724,5,118,
0,0,1724,1725,3,224,112,0,1725,1726,5,119,0,0,1726,1768,1,0,0,0,1727,1728,
5,118,0,0,1728,1729,3,226,113,0,1729,1730,5,119,0,0,1730,1768,1,0,0,0,1731,
1732,5,122,0,0,1732,1733,3,190,95,0,1733,1734,5,123,0,0,1734,1768,1,0,0,
0,1735,1736,5,120,0,0,1736,1737,3,190,95,0,1737,1738,5,121,0,0,1738,1768,
1,0,0,0,1739,1768,3,290,145,0,1740,1768,3,310,155,0,1741,1742,5,105,0,0,
1742,1768,3,398,199,0,1743,1744,5,105,0,0,1744,1745,5,120,0,0,1745,1746,
3,190,95,0,1746,1747,5,102,0,0,1747,1748,3,224,112,0,1748,1749,5,121,0,0,
1749,1768,1,0,0,0,1750,1751,5,105,0,0,1751,1753,5,122,0,0,1752,1754,3,224,
112,0,1753,1752,1,0,0,0,1753,1754,1,0,0,0,1754,1755,1,0,0,0,1755,1768,5,
123,0,0,1756,1757,5,105,0,0,1757,1768,3,458,229,0,1758,1759,5,122,0,0,1759,
1760,3,190,95,0,1760,1761,5,102,0,0,1761,1762,3,224,112,0,1762,1763,5,123,
0,0,1763,1768,1,0,0,0,1764,1768,3,504,252,0,1765,1768,3,510,255,0,1766,1768,
5,28,0,0,1767,1701,1,0,0,0,1767,1702,1,0,0,0,1767,1703,1,0,0,0,1767,1704,
1,0,0,0,1767,1706,1,0,0,0,1767,1708,1,0,0,0,1767,1713,1,0,0,0,1767,1715,
1,0,0,0,1767,1721,1,0,0,0,1767,1723,1,0,0,0,1767,1727,1,0,0,0,1767,1731,
1,0,0,0,1767,1735,1,0,0,0,1767,1739,1,0,0,0,1767,1740,1,0,0,0,1767,1741,
1,0,0,0,1767,1743,1,0,0,0,1767,1750,1,0,0,0,1767,1756,1,0,0,0,1767,1758,
1,0,0,0,1767,1764,1,0,0,0,1767,1765,1,0,0,0,1767,1766,1,0,0,0,1768,219,1,
0,0,0,1769,1770,3,178,89,0,1770,221,1,0,0,0,1771,1776,3,192,96,0,1772,1773,
5,102,0,0,1773,1775,3,192,96,0,1774,1772,1,0,0,0,1775,1778,1,0,0,0,1776,
1774,1,0,0,0,1776,1777,1,0,0,0,1777,223,1,0,0,0,1778,1776,1,0,0,0,1779,1784,
3,190,95,0,1780,1781,5,102,0,0,1781,1783,3,190,95,0,1782,1780,1,0,0,0,1783,
1786,1,0,0,0,1784,1782,1,0,0,0,1784,1785,1,0,0,0,1785,225,1,0,0,0,1786,1784,
1,0,0,0,1787,1788,3,190,95,0,1788,1789,5,86,0,0,1789,1794,3,190,95,0,1790,
1791,5,86,0,0,1791,1793,3,190,95,0,1792,1790,1,0,0,0,1793,1796,1,0,0,0,1794,
1792,1,0,0,0,1794,1795,1,0,0,0,1795,227,1,0,0,0,1796,1794,1,0,0,0,1797,1799,
3,230,115,0,1798,1797,1,0,0,0,1799,1800,1,0,0,0,1800,1798,1,0,0,0,1800,1801,
1,0,0,0,1801,229,1,0,0,0,1802,1814,3,232,116,0,1803,1804,5,132,0,0,1804,
1805,3,448,224,0,1805,1806,5,133,0,0,1806,1814,1,0,0,0,1807,1808,5,132,0,
0,1808,1809,3,448,224,0,1809,1810,5,75,0,0,1810,1811,3,242,121,0,1811,1812,
5,133,0,0,1812,1814,1,0,0,0,1813,1802,1,0,0,0,1813,1803,1,0,0,0,1813,1807,
1,0,0,0,1814,231,1,0,0,0,1815,1823,3,448,224,0,1816,1817,5,120,0,0,1817,
1818,3,448,224,0,1818,1819,5,75,0,0,1819,1820,3,242,121,0,1820,1821,5,121,
0,0,1821,1823,1,0,0,0,1822,1815,1,0,0,0,1822,1816,1,0,0,0,1823,233,1,0,0,
0,1824,1825,5,86,0,0,1825,1826,3,236,118,0,1826,235,1,0,0,0,1827,1832,3,
238,119,0,1828,1829,5,102,0,0,1829,1831,3,238,119,0,1830,1828,1,0,0,0,1831,
1834,1,0,0,0,1832,1830,1,0,0,0,1832,1833,1,0,0,0,1833,237,1,0,0,0,1834,1832,
1,0,0,0,1835,1837,3,240,120,0,1836,1835,1,0,0,0,1836,1837,1,0,0,0,1837,1838,
1,0,0,0,1838,1840,5,76,0,0,1839,1841,3,240,120,0,1840,1839,1,0,0,0,1840,
1841,1,0,0,0,1841,239,1,0,0,0,1842,1844,3,448,224,0,1843,1842,1,0,0,0,1844,
1845,1,0,0,0,1845,1843,1,0,0,0,1845,1846,1,0,0,0,1846,241,1,0,0,0,1847,1848,
3,194,97,0,1848,243,1,0,0,0,1849,1850,5,27,0,0,1850,1852,3,486,243,0,1851,
1853,3,246,123,0,1852,1851,1,0,0,0,1852,1853,1,0,0,0,1853,1857,1,0,0,0,1854,
1856,3,490,245,0,1855,1854,1,0,0,0,1856,1859,1,0,0,0,1857,1855,1,0,0,0,1857,
1858,1,0,0,0,1858,1860,1,0,0,0,1859,1857,1,0,0,0,1860,1861,3,488,244,0,1861,
245,1,0,0,0,1862,1868,3,248,124,0,1863,1864,3,490,245,0,1864,1865,3,248,
124,0,1865,1867,1,0,0,0,1866,1863,1,0,0,0,1867,1870,1,0,0,0,1868,1866,1,
0,0,0,1868,1869,1,0,0,0,1869,247,1,0,0,0,1870,1868,1,0,0,0,1871,1872,3,250,
125,0,1872,249,1,0,0,0,1873,1874,3,406,203,0,1874,1875,5,75,0,0,1875,1876,
3,180,90,0,1876,251,1,0,0,0,1877,1878,5,104,0,0,1878,1879,3,254,127,0,1879,
253,1,0,0,0,1880,1885,3,256,128,0,1881,1882,5,86,0,0,1882,1884,3,256,128,
0,1883,1881,1,0,0,0,1884,1887,1,0,0,0,1885,1883,1,0,0,0,1885,1886,1,0,0,
0,1886,255,1,0,0,0,1887,1885,1,0,0,0,1888,1890,3,258,129,0,1889,1888,1,0,
0,0,1889,1890,1,0,0,0,1890,1894,1,0,0,0,1891,1892,3,200,100,0,1892,1893,
5,74,0,0,1893,1895,1,0,0,0,1894,1891,1,0,0,0,1894,1895,1,0,0,0,1895,1896,
1,0,0,0,1896,1897,3,260,130,0,1897,257,1,0,0,0,1898,1900,5,29,0,0,1899,1901,
3,228,114,0,1900,1899,1,0,0,0,1900,1901,1,0,0,0,1901,1902,1,0,0,0,1902,1903,
5,99,0,0,1903,259,1,0,0,0,1904,1905,3,208,104,0,1905,261,1,0,0,0,1906,1911,
3,264,132,0,1907,1908,5,102,0,0,1908,1910,3,264,132,0,1909,1907,1,0,0,0,
1910,1913,1,0,0,0,1911,1909,1,0,0,0,1911,1912,1,0,0,0,1912,263,1,0,0,0,1913,
1911,1,0,0,0,1914,1915,3,182,91,0,1915,1916,5,75,0,0,1916,1917,3,194,97,
0,1917,265,1,0,0,0,1918,1920,3,268,134,0,1919,1918,1,0,0,0,1920,1921,1,0,
0,0,1921,1919,1,0,0,0,1921,1922,1,0,0,0,1922,267,1,0,0,0,1923,1924,5,9,0,
0,1924,1934,3,270,135,0,1925,1926,5,9,0,0,1926,1927,3,56,28,0,1927,1928,
3,270,135,0,1928,1934,1,0,0,0,1929,1930,5,9,0,0,1930,1931,3,270,135,0,1931,
1932,3,58,29,0,1932,1934,1,0,0,0,1933,1923,1,0,0,0,1933,1925,1,0,0,0,1933,
1929,1,0,0,0,1934,269,1,0,0,0,1935,1943,3,426,213,0,1936,1937,5,120,0,0,
1937,1943,5,121,0,0,1938,1939,5,120,0,0,1939,1940,3,222,111,0,1940,1941,
5,121,0,0,1941,1943,1,0,0,0,1942,1935,1,0,0,0,1942,1936,1,0,0,0,1942,1938,
1,0,0,0,1943,271,1,0,0,0,1944,1958,3,282,141,0,1945,1947,3,294,147,0,1946,
1948,3,174,87,0,1947,1946,1,0,0,0,1947,1948,1,0,0,0,1948,1949,1,0,0,0,1949,
1950,3,276,138,0,1950,1958,1,0,0,0,1951,1958,3,102,51,0,1952,1954,3,490,
245,0,1953,1952,1,0,0,0,1954,1955,1,0,0,0,1955,1953,1,0,0,0,1955,1956,1,
0,0,0,1956,1958,1,0,0,0,1957,1944,1,0,0,0,1957,1945,1,0,0,0,1957,1951,1,
0,0,0,1957,1953,1,0,0,0,1958,273,1,0,0,0,1959,1967,3,272,136,0,1960,1967,
3,308,154,0,1961,1963,3,490,245,0,1962,1961,1,0,0,0,1963,1964,1,0,0,0,1964,
1962,1,0,0,0,1964,1965,1,0,0,0,1965,1967,1,0,0,0,1966,1959,1,0,0,0,1966,
1960,1,0,0,0,1966,1962,1,0,0,0,1967,275,1,0,0,0,1968,1969,5,104,0,0,1969,
1971,3,292,146,0,1970,1972,3,136,68,0,1971,1970,1,0,0,0,1971,1972,1,0,0,
0,1972,1978,1,0,0,0,1973,1975,3,278,139,0,1974,1976,3,136,68,0,1975,1974,
1,0,0,0,1975,1976,1,0,0,0,1976,1978,1,0,0,0,1977,1968,1,0,0,0,1977,1973,
1,0,0,0,1978,277,1,0,0,0,1979,1981,3,280,140,0,1980,1979,1,0,0,0,1981,1982,
1,0,0,0,1982,1980,1,0,0,0,1982,1983,1,0,0,0,1983,279,1,0,0,0,1984,1985,5,
86,0,0,1985,1986,3,342,171,0,1986,1987,5,104,0,0,1987,1988,3,292,146,0,1988,
281,1,0,0,0,1989,1990,3,294,147,0,1990,1991,5,75,0,0,1991,1992,3,180,90,
0,1992,2069,1,0,0,0,1993,1994,3,458,229,0,1994,1995,5,102,0,0,1995,1996,
3,182,91,0,1996,1997,5,75,0,0,1997,1998,3,180,90,0,1998,2069,1,0,0,0,1999,
2001,3,36,18,0,2000,2002,3,504,252,0,2001,2000,1,0,0,0,2001,2002,1,0,0,0,
2002,2003,1,0,0,0,2003,2004,3,38,19,0,2004,2069,1,0,0,0,2005,2069,3,112,
56,0,2006,2007,5,128,0,0,2007,2008,5,72,0,0,2008,2010,3,406,203,0,2009,2011,
3,176,88,0,2010,2009,1,0,0,0,2010,2011,1,0,0,0,2011,2012,1,0,0,0,2012,2013,
5,129,0,0,2013,2069,1,0,0,0,2014,2015,5,128,0,0,2015,2017,5,54,0,0,2016,
2018,3,284,142,0,2017,2016,1,0,0,0,2017,2018,1,0,0,0,2018,2019,1,0,0,0,2019,
2020,3,460,230,0,2020,2021,5,129,0,0,2021,2069,1,0,0,0,2022,2023,5,128,0,
0,2023,2024,5,60,0,0,2024,2026,3,460,230,0,2025,2027,3,510,255,0,2026,2025,
1,0,0,0,2026,2027,1,0,0,0,2027,2028,1,0,0,0,2028,2029,5,129,0,0,2029,2069,
1,0,0,0,2030,2031,5,128,0,0,2031,2033,5,56,0,0,2032,2034,3,284,142,0,2033,
2032,1,0,0,0,2033,2034,1,0,0,0,2034,2035,1,0,0,0,2035,2036,3,460,230,0,2036,
2037,5,75,0,0,2037,2038,3,184,92,0,2038,2039,5,129,0,0,2039,2069,1,0,0,0,
2040,2041,5,128,0,0,2041,2043,5,57,0,0,2042,2044,3,284,142,0,2043,2042,1,
0,0,0,2043,2044,1,0,0,0,2044,2045,1,0,0,0,2045,2046,3,460,230,0,2046,2047,
5,75,0,0,2047,2048,3,184,92,0,2048,2049,5,129,0,0,2049,2069,1,0,0,0,2050,
2051,5,128,0,0,2051,2052,5,56,0,0,2052,2053,5,19,0,0,2053,2054,3,220,110,
0,2054,2055,5,129,0,0,2055,2069,1,0,0,0,2056,2057,5,128,0,0,2057,2058,5,
66,0,0,2058,2060,5,129,0,0,2059,2061,3,386,193,0,2060,2059,1,0,0,0,2060,
2061,1,0,0,0,2061,2062,1,0,0,0,2062,2069,5,129,0,0,2063,2065,3,490,245,0,
2064,2063,1,0,0,0,2065,2066,1,0,0,0,2066,2064,1,0,0,0,2066,2067,1,0,0,0,
2067,2069,1,0,0,0,2068,1989,1,0,0,0,2068,1993,1,0,0,0,2068,1999,1,0,0,0,
2068,2005,1,0,0,0,2068,2006,1,0,0,0,2068,2014,1,0,0,0,2068,2022,1,0,0,0,
2068,2030,1,0,0,0,2068,2040,1,0,0,0,2068,2050,1,0,0,0,2068,2056,1,0,0,0,
2068,2064,1,0,0,0,2069,283,1,0,0,0,2070,2071,5,122,0,0,2071,2072,3,504,252,
0,2072,2073,5,123,0,0,2073,2080,1,0,0,0,2074,2075,5,122,0,0,2075,2076,3,
142,71,0,2076,2077,3,504,252,0,2077,2078,5,123,0,0,2078,2080,1,0,0,0,2079,
2070,1,0,0,0,2079,2074,1,0,0,0,2080,285,1,0,0,0,2081,2082,5,122,0,0,2082,
2083,3,464,232,0,2083,2084,5,86,0,0,2084,287,1,0,0,0,2085,2086,5,122,0,0,
2086,2087,3,462,231,0,2087,2088,5,86,0,0,2088,289,1,0,0,0,2089,2092,3,286,
143,0,2090,2092,3,288,144,0,2091,2089,1,0,0,0,2091,2090,1,0,0,0,2092,291,
1,0,0,0,2093,2094,3,294,147,0,2094,2095,5,75,0,0,2095,2096,3,178,89,0,2096,
2115,1,0,0,0,2097,2098,3,294,147,0,2098,2099,5,78,0,0,2099,2100,3,292,146,
0,2100,2115,1,0,0,0,2101,2102,3,294,147,0,2102,2103,5,79,0,0,2103,2104,3,
292,146,0,2104,2115,1,0,0,0,2105,2106,3,294,147,0,2106,2107,5,80,0,0,2107,
2108,3,292,146,0,2108,2115,1,0,0,0,2109,2110,3,294,147,0,2110,2111,5,81,
0,0,2111,2112,3,292,146,0,2112,2115,1,0,0,0,2113,2115,3,294,147,0,2114,2093,
1,0,0,0,2114,2097,1,0,0,0,2114,2101,1,0,0,0,2114,2105,1,0,0,0,2114,2109,
1,0,0,0,2114,2113,1,0,0,0,2115,293,1,0,0,0,2116,2122,3,298,149,0,2117,2118,
3,438,219,0,2118,2119,3,296,148,0,2119,2121,1,0,0,0,2120,2117,1,0,0,0,2121,
2124,1,0,0,0,2122,2120,1,0,0,0,2122,2123,1,0,0,0,2123,295,1,0,0,0,2124,2122,
1,0,0,0,2125,2126,3,298,149,0,2126,297,1,0,0,0,2127,2129,5,90,0,0,2128,2127,
1,0,0,0,2128,2129,1,0,0,0,2129,2130,1,0,0,0,2130,2131,3,300,150,0,2131,299,
1,0,0,0,2132,2134,3,302,151,0,2133,2132,1,0,0,0,2134,2135,1,0,0,0,2135,2133,
1,0,0,0,2135,2136,1,0,0,0,2136,2139,1,0,0,0,2137,2138,5,95,0,0,2138,2140,
3,218,109,0,2139,2137,1,0,0,0,2139,2140,1,0,0,0,2140,301,1,0,0,0,2141,2142,
3,460,230,0,2142,2143,5,95,0,0,2143,2144,3,302,151,0,2144,2187,1,0,0,0,2145,
2146,5,94,0,0,2146,2187,3,302,151,0,2147,2148,5,87,0,0,2148,2187,3,302,151,
0,2149,2150,5,107,0,0,2150,2151,3,366,183,0,2151,2152,5,76,0,0,2152,2153,
3,292,146,0,2153,2187,1,0,0,0,2154,2155,5,20,0,0,2155,2156,3,132,66,0,2156,
2157,5,15,0,0,2157,2158,3,292,146,0,2158,2187,1,0,0,0,2159,2160,5,73,0,0,
2160,2187,3,346,173,0,2161,2162,5,13,0,0,2162,2164,3,292,146,0,2163,2165,
3,490,245,0,2164,2163,1,0,0,0,2164,2165,1,0,0,0,2165,2166,1,0,0,0,2166,2167,
5,25,0,0,2167,2169,3,292,146,0,2168,2170,3,490,245,0,2169,2168,1,0,0,0,2169,
2170,1,0,0,0,2170,2171,1,0,0,0,2171,2172,5,11,0,0,2172,2173,3,292,146,0,
2173,2187,1,0,0,0,2174,2175,5,13,0,0,2175,2187,3,356,178,0,2176,2177,5,5,
0,0,2177,2178,3,292,146,0,2178,2179,5,23,0,0,2179,2180,3,346,173,0,2180,
2187,1,0,0,0,2181,2182,5,10,0,0,2182,2187,3,370,185,0,2183,2184,5,35,0,0,
2184,2187,3,370,185,0,2185,2187,3,304,152,0,2186,2141,1,0,0,0,2186,2145,
1,0,0,0,2186,2147,1,0,0,0,2186,2149,1,0,0,0,2186,2154,1,0,0,0,2186,2159,
1,0,0,0,2186,2161,1,0,0,0,2186,2174,1,0,0,0,2186,2176,1,0,0,0,2186,2181,
1,0,0,0,2186,2183,1,0,0,0,2186,2185,1,0,0,0,2187,303,1,0,0,0,2188,2196,3,
306,153,0,2189,2191,5,132,0,0,2190,2192,3,378,189,0,2191,2190,1,0,0,0,2191,
2192,1,0,0,0,2192,2193,1,0,0,0,2193,2195,5,133,0,0,2194,2189,1,0,0,0,2195,
2198,1,0,0,0,2196,2194,1,0,0,0,2196,2197,1,0,0,0,2197,305,1,0,0,0,2198,2196,
1,0,0,0,2199,2267,3,460,230,0,2200,2267,3,400,200,0,2201,2267,3,464,232,
0,2202,2267,3,484,242,0,2203,2267,3,510,255,0,2204,2267,3,504,252,0,2205,
2267,3,506,253,0,2206,2207,5,120,0,0,2207,2208,3,322,161,0,2208,2209,5,121,
0,0,2209,2267,1,0,0,0,2210,2211,5,120,0,0,2211,2212,3,324,162,0,2212,2213,
5,121,0,0,2213,2267,1,0,0,0,2214,2215,5,118,0,0,2215,2216,3,322,161,0,2216,
2217,5,119,0,0,2217,2267,1,0,0,0,2218,2219,5,118,0,0,2219,2220,3,324,162,
0,2220,2221,5,119,0,0,2221,2267,1,0,0,0,2222,2223,5,122,0,0,2223,2224,3,
330,165,0,2224,2225,5,123,0,0,2225,2267,1,0,0,0,2226,2267,5,28,0,0,2227,
2267,3,310,155,0,2228,2267,3,312,156,0,2229,2230,5,105,0,0,2230,2267,3,460,
230,0,2231,2232,5,105,0,0,2232,2267,3,400,200,0,2233,2234,5,106,0,0,2234,
2267,3,448,224,0,2235,2236,5,106,0,0,2236,2267,3,418,209,0,2237,2267,5,106,
0,0,2238,2239,5,113,0,0,2239,2240,3,292,146,0,2240,2241,5,117,0,0,2241,2267,
1,0,0,0,2242,2243,5,111,0,0,2243,2244,3,292,146,0,2244,2245,5,112,0,0,2245,
2267,1,0,0,0,2246,2247,5,115,0,0,2247,2248,3,190,95,0,2248,2249,5,117,0,
0,2249,2267,1,0,0,0,2250,2251,5,114,0,0,2251,2252,3,294,147,0,2252,2253,
5,117,0,0,2253,2267,1,0,0,0,2254,2255,5,116,0,0,2255,2256,3,318,159,0,2256,
2257,5,117,0,0,2257,2267,1,0,0,0,2258,2267,3,290,145,0,2259,2260,5,109,0,
0,2260,2262,3,302,151,0,2261,2263,3,314,157,0,2262,2261,1,0,0,0,2262,2263,
1,0,0,0,2263,2264,1,0,0,0,2264,2265,5,109,0,0,2265,2267,1,0,0,0,2266,2199,
1,0,0,0,2266,2200,1,0,0,0,2266,2201,1,0,0,0,2266,2202,1,0,0,0,2266,2203,
1,0,0,0,2266,2204,1,0,0,0,2266,2205,1,0,0,0,2266,2206,1,0,0,0,2266,2210,
1,0,0,0,2266,2214,1,0,0,0,2266,2218,1,0,0,0,2266,2222,1,0,0,0,2266,2226,
1,0,0,0,2266,2227,1,0,0,0,2266,2228,1,0,0,0,2266,2229,1,0,0,0,2266,2231,
1,0,0,0,2266,2233,1,0,0,0,2266,2235,1,0,0,0,2266,2237,1,0,0,0,2266,2238,
1,0,0,0,2266,2242,1,0,0,0,2266,2246,1,0,0,0,2266,2250,1,0,0,0,2266,2254,
1,0,0,0,2266,2258,1,0,0,0,2266,2259,1,0,0,0,2267,307,1,0,0,0,2268,2271,3,
312,156,0,2269,2271,3,310,155,0,2270,2268,1,0,0,0,2270,2269,1,0,0,0,2271,
309,1,0,0,0,2272,2273,5,97,0,0,2273,2274,3,302,151,0,2274,311,1,0,0,0,2275,
2276,5,96,0,0,2276,2277,3,302,151,0,2277,313,1,0,0,0,2278,2280,3,316,158,
0,2279,2278,1,0,0,0,2280,2281,1,0,0,0,2281,2279,1,0,0,0,2281,2282,1,0,0,
0,2282,315,1,0,0,0,2283,2284,3,302,151,0,2284,317,1,0,0,0,2285,2287,3,486,
243,0,2286,2288,3,320,160,0,2287,2286,1,0,0,0,2287,2288,1,0,0,0,2288,2289,
1,0,0,0,2289,2290,3,488,244,0,2290,319,1,0,0,0,2291,2295,3,40,20,0,2292,
2294,3,490,245,0,2293,2292,1,0,0,0,2294,2297,1,0,0,0,2295,2293,1,0,0,0,2295,
2296,1,0,0,0,2296,321,1,0,0,0,2297,2295,1,0,0,0,2298,2310,3,292,146,0,2299,
2300,3,294,147,0,2300,2301,3,438,219,0,2301,2310,1,0,0,0,2302,2303,3,440,
220,0,2303,2304,3,294,147,0,2304,2310,1,0,0,0,2305,2306,3,292,146,0,2306,
2307,5,76,0,0,2307,2308,3,322,161,0,2308,2310,1,0,0,0,2309,2298,1,0,0,0,
2309,2299,1,0,0,0,2309,2302,1,0,0,0,2309,2305,1,0,0,0,2310,323,1,0,0,0,2311,
2312,3,322,161,0,2312,2313,3,326,163,0,2313,2327,1,0,0,0,2314,2315,3,322,
161,0,2315,2316,3,496,248,0,2316,2327,1,0,0,0,2317,2319,3,494,247,0,2318,
2320,3,328,164,0,2319,2318,1,0,0,0,2319,2320,1,0,0,0,2320,2327,1,0,0,0,2321,
2322,3,496,248,0,2322,2324,3,322,161,0,2323,2325,3,496,248,0,2324,2323,1,
0,0,0,2324,2325,1,0,0,0,2325,2327,1,0,0,0,2326,2311,1,0,0,0,2326,2314,1,
0,0,0,2326,2317,1,0,0,0,2326,2321,1,0,0,0,2327,325,1,0,0,0,2328,2330,3,494,
247,0,2329,2331,3,328,164,0,2330,2329,1,0,0,0,2330,2331,1,0,0,0,2331,327,
1,0,0,0,2332,2333,3,322,161,0,2333,2334,3,326,163,0,2334,2337,1,0,0,0,2335,
2337,3,322,161,0,2336,2332,1,0,0,0,2336,2335,1,0,0,0,2337,329,1,0,0,0,2338,
2363,3,322,161,0,2339,2363,3,332,166,0,2340,2341,3,322,161,0,2341,2342,5,
98,0,0,2342,2363,1,0,0,0,2343,2344,3,322,161,0,2344,2345,5,102,0,0,2345,
2346,3,292,146,0,2346,2347,5,98,0,0,2347,2363,1,0,0,0,2348,2349,3,322,161,
0,2349,2350,5,98,0,0,2350,2351,3,292,146,0,2351,2363,1,0,0,0,2352,2353,3,
322,161,0,2353,2354,5,102,0,0,2354,2355,3,292,146,0,2355,2356,5,98,0,0,2356,
2357,3,292,146,0,2357,2363,1,0,0,0,2358,2359,3,322,161,0,2359,2360,5,86,
0,0,2360,2361,3,334,167,0,2361,2363,1,0,0,0,2362,2338,1,0,0,0,2362,2339,
1,0,0,0,2362,2340,1,0,0,0,2362,2343,1,0,0,0,2362,2348,1,0,0,0,2362,2352,
1,0,0,0,2362,2358,1,0,0,0,2363,331,1,0,0,0,2364,2365,3,322,161,0,2365,2366,
5,102,0,0,2366,2371,3,322,161,0,2367,2368,5,102,0,0,2368,2370,3,322,161,
0,2369,2367,1,0,0,0,2370,2373,1,0,0,0,2371,2369,1,0,0,0,2371,2372,1,0,0,
0,2372,333,1,0,0,0,2373,2371,1,0,0,0,2374,2375,3,336,168,0,2375,335,1,0,
0,0,2376,2381,3,338,169,0,2377,2378,5,86,0,0,2378,2380,3,338,169,0,2379,
2377,1,0,0,0,2380,2383,1,0,0,0,2381,2379,1,0,0,0,2381,2382,1,0,0,0,2382,
337,1,0,0,0,2383,2381,1,0,0,0,2384,2389,3,340,170,0,2385,2386,5,102,0,0,
2386,2388,3,340,170,0,2387,2385,1,0,0,0,2388,2391,1,0,0,0,2389,2387,1,0,
0,0,2389,2390,1,0,0,0,2390,2417,1,0,0,0,2391,2389,1,0,0,0,2392,2397,3,340,
170,0,2393,2394,5,102,0,0,2394,2396,3,376,188,0,2395,2393,1,0,0,0,2396,2399,
1,0,0,0,2397,2395,1,0,0,0,2397,2398,1,0,0,0,2398,2417,1,0,0,0,2399,2397,
1,0,0,0,2400,2405,3,376,188,0,2401,2402,5,102,0,0,2402,2404,3,340,170,0,
2403,2401,1,0,0,0,2404,2407,1,0,0,0,2405,2403,1,0,0,0,2405,2406,1,0,0,0,
2406,2417,1,0,0,0,2407,2405,1,0,0,0,2408,2413,3,376,188,0,2409,2410,5,102,
0,0,2410,2412,3,376,188,0,2411,2409,1,0,0,0,2412,2415,1,0,0,0,2413,2411,
1,0,0,0,2413,2414,1,0,0,0,2414,2417,1,0,0,0,2415,2413,1,0,0,0,2416,2384,
1,0,0,0,2416,2392,1,0,0,0,2416,2400,1,0,0,0,2416,2408,1,0,0,0,2417,339,1,
0,0,0,2418,2419,5,25,0,0,2419,2437,3,292,146,0,2420,2421,5,25,0,0,2421,2422,
3,292,146,0,2422,2423,5,45,0,0,2423,2424,3,292,146,0,2424,2437,1,0,0,0,2425,
2426,5,25,0,0,2426,2427,5,44,0,0,2427,2428,5,46,0,0,2428,2437,3,292,146,
0,2429,2430,5,25,0,0,2430,2431,5,44,0,0,2431,2432,5,45,0,0,2432,2433,3,292,
146,0,2433,2434,5,46,0,0,2434,2435,3,292,146,0,2435,2437,1,0,0,0,2436,2418,
1,0,0,0,2436,2420,1,0,0,0,2436,2425,1,0,0,0,2436,2429,1,0,0,0,2437,341,1,
0,0,0,2438,2443,3,344,172,0,2439,2440,5,102,0,0,2440,2442,3,344,172,0,2441,
2439,1,0,0,0,2442,2445,1,0,0,0,2443,2441,1,0,0,0,2443,2444,1,0,0,0,2444,
343,1,0,0,0,2445,2443,1,0,0,0,2446,2447,3,360,180,0,2447,2448,5,77,0,0,2448,
2449,3,294,147,0,2449,2454,1,0,0,0,2450,2451,5,20,0,0,2451,2454,3,132,66,
0,2452,2454,3,294,147,0,2453,2446,1,0,0,0,2453,2450,1,0,0,0,2453,2452,1,
0,0,0,2454,345,1,0,0,0,2455,2463,3,486,243,0,2456,2460,3,348,174,0,2457,
2459,3,490,245,0,2458,2457,1,0,0,0,2459,2462,1,0,0,0,2460,2458,1,0,0,0,2460,
2461,1,0,0,0,2461,2464,1,0,0,0,2462,2460,1,0,0,0,2463,2456,1,0,0,0,2464,
2465,1,0,0,0,2465,2463,1,0,0,0,2465,2466,1,0,0,0,2466,2467,1,0,0,0,2467,
2468,3,488,244,0,2468,2473,1,0,0,0,2469,2470,3,486,243,0,2470,2471,3,488,
244,0,2471,2473,1,0,0,0,2472,2455,1,0,0,0,2472,2469,1,0,0,0,2473,347,1,0,
0,0,2474,2475,3,360,180,0,2475,2476,3,350,175,0,2476,349,1,0,0,0,2477,2479,
3,352,176,0,2478,2480,3,136,68,0,2479,2478,1,0,0,0,2479,2480,1,0,0,0,2480,
351,1,0,0,0,2481,2482,5,76,0,0,2482,2485,3,292,146,0,2483,2485,3,354,177,
0,2484,2481,1,0,0,0,2484,2483,1,0,0,0,2485,353,1,0,0,0,2486,2488,3,358,179,
0,2487,2486,1,0,0,0,2488,2489,1,0,0,0,2489,2487,1,0,0,0,2489,2490,1,0,0,
0,2490,355,1,0,0,0,2491,2492,5,132,0,0,2492,2493,3,354,177,0,2493,2494,5,
133,0,0,2494,2497,1,0,0,0,2495,2497,3,354,177,0,2496,2491,1,0,0,0,2496,2495,
1,0,0,0,2497,357,1,0,0,0,2498,2499,5,86,0,0,2499,2500,3,342,171,0,2500,2501,
5,76,0,0,2501,2502,3,292,146,0,2502,359,1,0,0,0,2503,2504,3,292,146,0,2504,
361,1,0,0,0,2505,2506,3,292,146,0,2506,363,1,0,0,0,2507,2508,3,302,151,0,
2508,365,1,0,0,0,2509,2511,3,364,182,0,2510,2509,1,0,0,0,2511,2512,1,0,0,
0,2512,2510,1,0,0,0,2512,2513,1,0,0,0,2513,367,1,0,0,0,2514,2515,3,460,230,
0,2515,2516,5,104,0,0,2516,2517,3,360,180,0,2517,369,1,0,0,0,2518,2520,3,
486,243,0,2519,2521,3,372,186,0,2520,2519,1,0,0,0,2520,2521,1,0,0,0,2521,
2522,1,0,0,0,2522,2523,3,488,244,0,2523,371,1,0,0,0,2524,2534,3,374,187,
0,2525,2527,3,490,245,0,2526,2525,1,0,0,0,2527,2528,1,0,0,0,2528,2526,1,
0,0,0,2528,2529,1,0,0,0,2529,2530,1,0,0,0,2530,2531,3,374,187,0,2531,2533,
1,0,0,0,2532,2526,1,0,0,0,2533,2536,1,0,0,0,2534,2532,1,0,0,0,2534,2535,
1,0,0,0,2535,2540,1,0,0,0,2536,2534,1,0,0,0,2537,2539,3,490,245,0,2538,2537,
1,0,0,0,2539,2542,1,0,0,0,2540,2538,1,0,0,0,2540,2541,1,0,0,0,2541,373,1,
0,0,0,2542,2540,1,0,0,0,2543,2552,3,376,188,0,2544,2545,5,43,0,0,2545,2552,
3,370,185,0,2546,2548,3,490,245,0,2547,2546,1,0,0,0,2548,2549,1,0,0,0,2549,
2547,1,0,0,0,2549,2550,1,0,0,0,2550,2552,1,0,0,0,2551,2543,1,0,0,0,2551,
2544,1,0,0,0,2551,2547,1,0,0,0,2552,375,1,0,0,0,2553,2554,3,362,181,0,2554,
2555,5,77,0,0,2555,2556,3,292,146,0,2556,2561,1,0,0,0,2557,2561,3,292,146,
0,2558,2559,5,20,0,0,2559,2561,3,134,67,0,2560,2553,1,0,0,0,2560,2557,1,
0,0,0,2560,2558,1,0,0,0,2561,377,1,0,0,0,2562,2567,3,380,190,0,2563,2564,
5,102,0,0,2564,2566,3,380,190,0,2565,2563,1,0,0,0,2566,2569,1,0,0,0,2567,
2565,1,0,0,0,2567,2568,1,0,0,0,2568,2572,1,0,0,0,2569,2567,1,0,0,0,2570,
2572,5,98,0,0,2571,2562,1,0,0,0,2571,2570,1,0,0,0,2572,379,1,0,0,0,2573,
2574,3,460,230,0,2574,2575,5,104,0,0,2575,2576,3,292,146,0,2576,2579,1,0,
0,0,2577,2579,3,460,230,0,2578,2573,1,0,0,0,2578,2577,1,0,0,0,2579,381,1,
0,0,0,2580,2582,3,384,192,0,2581,2583,3,490,245,0,2582,2581,1,0,0,0,2583,
2584,1,0,0,0,2584,2582,1,0,0,0,2584,2585,1,0,0,0,2585,2586,1,0,0,0,2586,
2587,3,384,192,0,2587,2591,1,0,0,0,2588,2590,3,490,245,0,2589,2588,1,0,0,
0,2590,2593,1,0,0,0,2591,2589,1,0,0,0,2591,2592,1,0,0,0,2592,383,1,0,0,0,
2593,2591,1,0,0,0,2594,2595,3,464,232,0,2595,2596,5,104,0,0,2596,2597,3,
292,146,0,2597,385,1,0,0,0,2598,2603,3,388,194,0,2599,2600,5,86,0,0,2600,
2602,3,388,194,0,2601,2599,1,0,0,0,2602,2605,1,0,0,0,2603,2601,1,0,0,0,2603,
2604,1,0,0,0,2604,387,1,0,0,0,2605,2603,1,0,0,0,2606,2607,3,390,195,0,2607,
389,1,0,0,0,2608,2613,3,392,196,0,2609,2610,5,102,0,0,2610,2612,3,392,196,
0,2611,2609,1,0,0,0,2612,2615,1,0,0,0,2613,2611,1,0,0,0,2613,2614,1,0,0,
0,2614,391,1,0,0,0,2615,2613,1,0,0,0,2616,2617,5,120,0,0,2617,2618,3,386,
193,0,2618,2619,5,121,0,0,2619,2622,1,0,0,0,2620,2622,3,396,198,0,2621,2616,
1,0,0,0,2621,2620,1,0,0,0,2622,393,1,0,0,0,2623,2628,3,396,198,0,2624,2625,
5,102,0,0,2625,2627,3,396,198,0,2626,2624,1,0,0,0,2627,2630,1,0,0,0,2628,
2626,1,0,0,0,2628,2629,1,0,0,0,2629,395,1,0,0,0,2630,2628,1,0,0,0,2631,2634,
3,458,229,0,2632,2634,3,404,202,0,2633,2631,1,0,0,0,2633,2632,1,0,0,0,2634,
397,1,0,0,0,2635,2638,3,402,201,0,2636,2638,3,408,204,0,2637,2635,1,0,0,
0,2637,2636,1,0,0,0,2638,399,1,0,0,0,2639,2642,3,402,201,0,2640,2642,3,410,
205,0,2641,2639,1,0,0,0,2641,2640,1,0,0,0,2642,401,1,0,0,0,2643,2649,3,476,
238,0,2644,2645,5,120,0,0,2645,2646,3,480,240,0,2646,2647,5,121,0,0,2647,
2649,1,0,0,0,2648,2643,1,0,0,0,2648,2644,1,0,0,0,2649,403,1,0,0,0,2650,2657,
3,478,239,0,2651,2652,5,120,0,0,2652,2653,3,482,241,0,2653,2654,5,121,0,
0,2654,2657,1,0,0,0,2655,2657,3,410,205,0,2656,2650,1,0,0,0,2656,2651,1,
0,0,0,2656,2655,1,0,0,0,2657,405,1,0,0,0,2658,2663,3,404,202,0,2659,2660,
5,102,0,0,2660,2662,3,404,202,0,2661,2659,1,0,0,0,2662,2665,1,0,0,0,2663,
2661,1,0,0,0,2663,2664,1,0,0,0,2664,407,1,0,0,0,2665,2663,1,0,0,0,2666,2667,
5,120,0,0,2667,2679,5,121,0,0,2668,2669,5,120,0,0,2669,2670,3,494,247,0,
2670,2671,5,121,0,0,2671,2679,1,0,0,0,2672,2673,5,118,0,0,2673,2679,5,119,
0,0,2674,2675,5,118,0,0,2675,2676,3,494,247,0,2676,2677,5,119,0,0,2677,2679,
1,0,0,0,2678,2666,1,0,0,0,2678,2668,1,0,0,0,2678,2672,1,0,0,0,2678,2674,
1,0,0,0,2679,409,1,0,0,0,2680,2684,3,408,204,0,2681,2682,5,122,0,0,2682,
2684,5,123,0,0,2683,2680,1,0,0,0,2683,2681,1,0,0,0,2684,411,1,0,0,0,2685,
2691,3,482,241,0,2686,2687,5,108,0,0,2687,2688,3,478,239,0,2688,2689,5,108,
0,0,2689,2691,1,0,0,0,2690,2685,1,0,0,0,2690,2686,1,0,0,0,2691,413,1,0,0,
0,2692,2698,3,416,208,0,2693,2694,5,108,0,0,2694,2695,3,476,238,0,2695,2696,
5,108,0,0,2696,2698,1,0,0,0,2697,2692,1,0,0,0,2697,2693,1,0,0,0,2698,415,
1,0,0,0,2699,2702,5,103,0,0,2700,2702,3,480,240,0,2701,2699,1,0,0,0,2701,
2700,1,0,0,0,2702,417,1,0,0,0,2703,2709,3,420,210,0,2704,2705,5,120,0,0,
2705,2709,5,121,0,0,2706,2707,5,118,0,0,2707,2709,5,119,0,0,2708,2703,1,
0,0,0,2708,2704,1,0,0,0,2708,2706,1,0,0,0,2709,419,1,0,0,0,2710,2725,3,422,
211,0,2711,2712,5,120,0,0,2712,2713,3,494,247,0,2713,2714,5,121,0,0,2714,
2725,1,0,0,0,2715,2716,5,118,0,0,2716,2717,3,494,247,0,2717,2718,5,119,0,
0,2718,2725,1,0,0,0,2719,2720,5,120,0,0,2720,2721,5,76,0,0,2721,2725,5,121,
0,0,2722,2723,5,122,0,0,2723,2725,5,123,0,0,2724,2710,1,0,0,0,2724,2711,
1,0,0,0,2724,2715,1,0,0,0,2724,2719,1,0,0,0,2724,2722,1,0,0,0,2725,421,1,
0,0,0,2726,2732,3,426,213,0,2727,2728,5,120,0,0,2728,2729,3,430,215,0,2729,
2730,5,121,0,0,2730,2732,1,0,0,0,2731,2726,1,0,0,0,2731,2727,1,0,0,0,2732,
423,1,0,0,0,2733,2739,3,430,215,0,2734,2735,5,108,0,0,2735,2736,3,426,213,
0,2736,2737,5,108,0,0,2737,2739,1,0,0,0,2738,2733,1,0,0,0,2738,2734,1,0,
0,0,2739,425,1,0,0,0,2740,2741,3,492,246,0,2741,2742,5,99,0,0,2742,2744,
1,0,0,0,2743,2740,1,0,0,0,2743,2744,1,0,0,0,2744,2745,1,0,0,0,2745,2746,
3,428,214,0,2746,427,1,0,0,0,2747,2748,3,478,239,0,2748,429,1,0,0,0,2749,
2753,3,480,240,0,2750,2753,3,466,233,0,2751,2753,3,432,216,0,2752,2749,1,
0,0,0,2752,2750,1,0,0,0,2752,2751,1,0,0,0,2753,431,1,0,0,0,2754,2760,3,482,
241,0,2755,2760,3,470,235,0,2756,2760,5,103,0,0,2757,2760,5,90,0,0,2758,
2760,5,99,0,0,2759,2754,1,0,0,0,2759,2755,1,0,0,0,2759,2756,1,0,0,0,2759,
2757,1,0,0,0,2759,2758,1,0,0,0,2760,433,1,0,0,0,2761,2764,3,436,218,0,2762,
2764,3,412,206,0,2763,2761,1,0,0,0,2763,2762,1,0,0,0,2764,435,1,0,0,0,2765,
2771,3,470,235,0,2766,2767,5,108,0,0,2767,2768,3,464,232,0,2768,2769,5,108,
0,0,2769,2771,1,0,0,0,2770,2765,1,0,0,0,2770,2766,1,0,0,0,2771,437,1,0,0,
0,2772,2775,3,444,222,0,2773,2775,3,414,207,0,2774,2772,1,0,0,0,2774,2773,
1,0,0,0,2775,439,1,0,0,0,2776,2780,3,446,223,0,2777,2780,3,414,207,0,2778,
2780,3,442,221,0,2779,2776,1,0,0,0,2779,2777,1,0,0,0,2779,2778,1,0,0,0,2780,
441,1,0,0,0,2781,2782,5,108,0,0,2782,2783,5,28,0,0,2783,2784,5,108,0,0,2784,
443,1,0,0,0,2785,2791,3,466,233,0,2786,2787,5,108,0,0,2787,2788,3,462,231,
0,2788,2789,5,108,0,0,2789,2791,1,0,0,0,2790,2785,1,0,0,0,2790,2786,1,0,
0,0,2791,445,1,0,0,0,2792,2798,3,468,234,0,2793,2794,5,108,0,0,2794,2795,
3,462,231,0,2795,2796,5,108,0,0,2796,2798,1,0,0,0,2797,2792,1,0,0,0,2797,
2793,1,0,0,0,2798,447,1,0,0,0,2799,2800,3,464,232,0,2800,449,1,0,0,0,2801,
2802,5,108,0,0,2802,2803,3,452,226,0,2803,2804,5,108,0,0,2804,451,1,0,0,
0,2805,2811,3,464,232,0,2806,2811,3,474,237,0,2807,2811,5,34,0,0,2808,2811,
5,32,0,0,2809,2811,5,33,0,0,2810,2805,1,0,0,0,2810,2806,1,0,0,0,2810,2807,
1,0,0,0,2810,2808,1,0,0,0,2810,2809,1,0,0,0,2811,453,1,0,0,0,2812,2813,3,
478,239,0,2813,455,1,0,0,0,2814,2815,3,492,246,0,2815,2816,5,99,0,0,2816,
2818,1,0,0,0,2817,2814,1,0,0,0,2817,2818,1,0,0,0,2818,2819,1,0,0,0,2819,
2820,3,454,227,0,2820,457,1,0,0,0,2821,2827,3,464,232,0,2822,2823,5,120,
0,0,2823,2824,3,470,235,0,2824,2825,5,121,0,0,2825,2827,1,0,0,0,2826,2821,
1,0,0,0,2826,2822,1,0,0,0,2827,459,1,0,0,0,2828,2834,3,462,231,0,2829,2830,
5,120,0,0,2830,2831,3,466,233,0,2831,2832,5,121,0,0,2832,2834,1,0,0,0,2833,
2828,1,0,0,0,2833,2829,1,0,0,0,2834,461,1,0,0,0,2835,2836,3,492,246,0,2836,
2837,5,99,0,0,2837,2839,1,0,0,0,2838,2835,1,0,0,0,2838,2839,1,0,0,0,2839,
2840,1,0,0,0,2840,2841,3,464,232,0,2841,463,1,0,0,0,2842,2845,5,126,0,0,
2843,2845,3,474,237,0,2844,2842,1,0,0,0,2844,2843,1,0,0,0,2845,2849,1,0,
0,0,2846,2848,5,82,0,0,2847,2846,1,0,0,0,2848,2851,1,0,0,0,2849,2847,1,0,
0,0,2849,2850,1,0,0,0,2850,465,1,0,0,0,2851,2849,1,0,0,0,2852,2853,3,492,
246,0,2853,2854,5,99,0,0,2854,2856,1,0,0,0,2855,2852,1,0,0,0,2855,2856,1,
0,0,0,2856,2857,1,0,0,0,2857,2858,3,470,235,0,2858,467,1,0,0,0,2859,2862,
3,472,236,0,2860,2862,3,466,233,0,2861,2859,1,0,0,0,2861,2860,1,0,0,0,2862,
469,1,0,0,0,2863,2866,3,472,236,0,2864,2866,5,90,0,0,2865,2863,1,0,0,0,2865,
2864,1,0,0,0,2866,471,1,0,0,0,2867,2869,3,502,251,0,2868,2867,1,0,0,0,2869,
2870,1,0,0,0,2870,2868,1,0,0,0,2870,2871,1,0,0,0,2871,473,1,0,0,0,2872,2873,
7,5,0,0,2873,475,1,0,0,0,2874,2875,3,492,246,0,2875,2876,5,99,0,0,2876,2878,
1,0,0,0,2877,2874,1,0,0,0,2877,2878,1,0,0,0,2878,2879,1,0,0,0,2879,2880,
3,478,239,0,2880,477,1,0,0,0,2881,2885,5,127,0,0,2882,2884,5,82,0,0,2883,
2882,1,0,0,0,2884,2887,1,0,0,0,2885,2883,1,0,0,0,2885,2886,1,0,0,0,2886,
479,1,0,0,0,2887,2885,1,0,0,0,2888,2889,3,492,246,0,2889,2890,5,99,0,0,2890,
2892,1,0,0,0,2891,2888,1,0,0,0,2891,2892,1,0,0,0,2892,2893,1,0,0,0,2893,
2894,3,482,241,0,2894,481,1,0,0,0,2895,2899,5,103,0,0,2896,2898,3,502,251,
0,2897,2896,1,0,0,0,2898,2901,1,0,0,0,2899,2897,1,0,0,0,2899,2900,1,0,0,
0,2900,483,1,0,0,0,2901,2899,1,0,0,0,2902,2907,3,504,252,0,2903,2907,3,506,
253,0,2904,2907,3,508,254,0,2905,2907,3,510,255,0,2906,2902,1,0,0,0,2906,
2903,1,0,0,0,2906,2904,1,0,0,0,2906,2905,1,0,0,0,2907,485,1,0,0,0,2908,2909,
7,6,0,0,2909,487,1,0,0,0,2910,2911,7,7,0,0,2911,489,1,0,0,0,2912,2913,7,
8,0,0,2913,491,1,0,0,0,2914,2915,3,478,239,0,2915,2916,5,99,0,0,2916,2918,
1,0,0,0,2917,2914,1,0,0,0,2918,2921,1,0,0,0,2919,2917,1,0,0,0,2919,2920,
1,0,0,0,2920,2922,1,0,0,0,2921,2919,1,0,0,0,2922,2923,3,478,239,0,2923,493,
1,0,0,0,2924,2926,5,102,0,0,2925,2924,1,0,0,0,2926,2927,1,0,0,0,2927,2925,
1,0,0,0,2927,2928,1,0,0,0,2928,495,1,0,0,0,2929,2931,5,86,0,0,2930,2929,
1,0,0,0,2931,2932,1,0,0,0,2932,2930,1,0,0,0,2932,2933,1,0,0,0,2933,497,1,
0,0,0,2934,2935,7,9,0,0,2935,499,1,0,0,0,2936,2937,3,502,251,0,2937,501,
1,0,0,0,2938,2939,7,10,0,0,2939,503,1,0,0,0,2940,2941,7,11,0,0,2941,505,
1,0,0,0,2942,2943,5,140,0,0,2943,507,1,0,0,0,2944,2945,5,124,0,0,2945,509,
1,0,0,0,2946,2947,5,125,0,0,2947,511,1,0,0,0,343,513,518,522,527,532,535,
538,545,558,564,569,578,583,590,594,599,606,610,615,624,629,631,639,642,
645,660,663,666,678,681,684,688,692,697,700,705,713,717,719,729,733,735,
738,751,754,757,765,768,770,774,783,790,794,796,807,815,821,827,833,838,
841,852,855,858,862,867,871,876,880,884,887,890,894,898,901,904,910,912,
924,929,933,941,945,950,954,959,963,966,969,974,978,981,984,986,1000,1011,
1023,1030,1041,1047,1053,1059,1064,1075,1079,1083,1087,1091,1095,1098,1102,
1107,1110,1115,1119,1122,1127,1131,1134,1138,1141,1144,1148,1151,1155,1158,
1161,1163,1175,1184,1191,1195,1204,1213,1224,1228,1232,1240,1245,1249,1261,
1263,1267,1278,1283,1290,1296,1312,1318,1324,1330,1335,1344,1350,1356,1362,
1367,1378,1384,1390,1395,1402,1406,1417,1421,1425,1428,1436,1451,1455,1460,
1463,1468,1477,1485,1489,1500,1504,1512,1515,1522,1543,1548,1556,1563,1584,
1592,1601,1610,1617,1621,1635,1639,1653,1664,1671,1678,1687,1699,1710,1753,
1767,1776,1784,1794,1800,1813,1822,1832,1836,1840,1845,1852,1857,1868,1885,
1889,1894,1900,1911,1921,1933,1942,1947,1955,1957,1964,1966,1971,1975,1977,
1982,2001,2010,2017,2026,2033,2043,2060,2066,2068,2079,2091,2114,2122,2128,
2135,2139,2164,2169,2186,2191,2196,2262,2266,2270,2281,2287,2295,2309,2319,
2324,2326,2330,2336,2362,2371,2381,2389,2397,2405,2413,2416,2436,2443,2453,
2460,2465,2472,2479,2484,2489,2496,2512,2520,2528,2534,2540,2549,2551,2560,
2567,2571,2578,2584,2591,2603,2613,2621,2628,2633,2637,2641,2648,2656,2663,
2678,2683,2690,2697,2701,2708,2724,2731,2738,2743,2752,2759,2763,2770,2774,
2779,2790,2797,2810,2817,2826,2833,2838,2844,2849,2855,2861,2865,2870,2877,
2885,2891,2899,2906,2919,2927,2932];


const atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

const decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );

const sharedContextCache = new antlr4.PredictionContextCache();

export default class HaskellParser extends antlr4.Parser {

    static grammarFileName = "HaskellParser.g4";
    static literalNames = [ null, null, null, null, "'as'", "'case'", "'class'", 
                            "'data'", "'default'", "'deriving'", "'do'", 
                            "'else'", "'hiding'", "'if'", "'import'", "'in'", 
                            "'infix'", "'infixl'", "'infixr'", "'instance'", 
                            "'let'", "'module'", "'newtype'", "'of'", "'qualified'", 
                            "'then'", "'type'", "'where'", "'_'", "'forall'", 
                            "'foreign'", "'export'", "'safe'", "'interruptible'", 
                            "'unsafe'", "'mdo'", "'family'", "'role'", "'stdcall'", 
                            "'ccall'", "'capi'", "'cplusplus'", "'javascript'", 
                            "'rec'", "'group'", "'by'", "'using'", "'pattern'", 
                            "'stock'", "'anyclass'", "'via'", "'LANGUAGE'", 
                            "'OPTIONS_GHC'", "'OPTIONS'", "'INLINE'", "'NOINLINE'", 
                            "'SPECIALISE'", "'SPECIALISE_INLINE'", "'SOURCE'", 
                            "'RULES'", "'SCC'", "'DEPRECATED'", "'WARNING'", 
                            "'UNPACK'", "'NOUNPACK'", "'ANN'", "'MINIMAL'", 
                            "'CTYPE'", "'OVERLAPPING'", "'OVERLAPPABLE'", 
                            "'OVERLAPS'", "'INCOHERENT'", "'COMPLETE'", 
                            null, "'=>'", "'::'", "'->'", "'<-'", "'-<'", 
                            "'>-'", "'-<<'", "'>>-'", "'#'", "'<'", "'>'", 
                            "'&'", "'|'", "'!'", "'^'", "'+'", "'-'", "'*'", 
                            "'%'", "'/'", "'~'", "'@'", "'$$'", "'$'", "'..'", 
                            "'.'", "';'", "'?'", "','", "':'", "'='", "'''", 
                            "''''", "'\\'", "'`'", null, null, "'[||'", 
                            "'||]'", "'[|'", "'[p|'", "'[t|'", "'[d|'", 
                            "'|]'", "'(#'", "'#)'", "'('", "')'", "'['", 
                            "']'", null, null, null, null, "'{-#'", "'#-}'", 
                            null, null, "'{'", "'}'", "'VOCURLY'", "'VCCURLY'", 
                            "'SEMI'" ];
    static symbolicNames = [ null, "NEWLINE", "TAB", "WS", "AS", "CASE", 
                             "CLASS", "DATA", "DEFAULT", "DERIVING", "DO", 
                             "ELSE", "HIDING", "IF", "IMPORT", "IN", "INFIX", 
                             "INFIXL", "INFIXR", "INSTANCE", "LET", "MODULE", 
                             "NEWTYPE", "OF", "QUALIFIED", "THEN", "TYPE", 
                             "WHERE", "WILDCARD", "FORALL", "FOREIGN", "EXPORT", 
                             "SAFE", "INTERRUPTIBLE", "UNSAFE", "MDO", "FAMILY", 
                             "ROLE", "STDCALL", "CCALL", "CAPI", "CPPCALL", 
                             "JSCALL", "REC", "GROUP", "BY", "USING", "PATTERN", 
                             "STOCK", "ANYCLASS", "VIA", "LANGUAGE", "OPTIONS_GHC", 
                             "OPTIONS", "INLINE", "NOINLINE", "SPECIALISE", 
                             "SPECINLINE", "SOURCE", "RULES", "SCC", "DEPRECATED", 
                             "WARNING", "UNPACK", "NOUNPACK", "ANN", "MINIMAL", 
                             "CTYPE", "OVERLAPPING", "OVERLAPPABLE", "OVERLAPS", 
                             "INCOHERENT", "COMPLETE", "LCASE", "DoubleArrow", 
                             "DoubleColon", "Arrow", "Revarrow", "LarrowTail", 
                             "RarrowTail", "LLarrowTail", "RRarrowTail", 
                             "Hash", "Less", "Greater", "Ampersand", "Pipe", 
                             "Bang", "Caret", "Plus", "Minus", "Asterisk", 
                             "Percent", "Divide", "Tilde", "Atsign", "DDollar", 
                             "Dollar", "DoubleDot", "Dot", "Semi", "QuestionMark", 
                             "Comma", "Colon", "Eq", "Quote", "DoubleQuote", 
                             "ReverseSlash", "BackQuote", "AopenParen", 
                             "AcloseParen", "TopenTexpQuote", "TcloseTExpQoute", 
                             "TopenExpQuote", "TopenPatQuote", "TopenTypQoute", 
                             "TopenDecQoute", "TcloseQoute", "OpenBoxParen", 
                             "CloseBoxParen", "OpenRoundBracket", "CloseRoundBracket", 
                             "OpenSquareBracket", "CloseSquareBracket", 
                             "CHAR", "STRING", "VARID", "CONID", "OpenPragmaBracket", 
                             "ClosePragmaBracket", "COMMENT", "NCOMMENT", 
                             "OCURLY", "CCURLY", "VOCURLY", "VCCURLY", "SEMI", 
                             "DECIMAL", "OCTAL", "HEXADECIMAL", "FLOAT", 
                             "EXPONENT" ];
    static ruleNames = [ "module", "module_content", "where_module", "module_body", 
                         "pragmas", "pragma", "language_pragma", "options_ghc", 
                         "simple_options", "extension_", "body", "impdecls", 
                         "exports", "exprt", "impdecl", "impspec", "himport", 
                         "cname", "fixity", "ops", "topdecls", "topdecl", 
                         "cl_decl", "ty_decl", "standalone_kind_sig", "sks_vars", 
                         "inst_decl", "overlap_pragma", "deriv_strategy_no_via", 
                         "deriv_strategy_via", "deriv_standalone_strategy", 
                         "opt_injective_info", "injectivity_cond", "inj_varids", 
                         "where_type_family", "ty_fam_inst_eqn_list", "ty_fam_inst_eqns", 
                         "ty_fam_inst_eqn", "at_decl_cls", "at_decl_inst", 
                         "opt_kind_sig", "opt_datafam_kind_sig", "opt_tyfam_kind_sig", 
                         "opt_at_kind_inj_sig", "tycl_hdr", "tycl_hdr_inst", 
                         "capi_ctype", "standalone_deriving", "role_annot", 
                         "roles", "role", "pattern_synonym_decl", "pattern_synonym_lhs", 
                         "vars_", "cvars", "where_decls", "pattern_synonym_sig", 
                         "decl_cls", "decls_cls", "decllist_cls", "where_cls", 
                         "decl_inst", "decls_inst", "decllist_inst", "where_inst", 
                         "decls", "decllist", "binds", "wherebinds", "rules", 
                         "pragma_rule", "rule_activation_marker", "rule_activation", 
                         "rule_foralls", "rule_vars", "rule_var", "warnings", 
                         "pragma_warning", "deprecations", "pragma_deprecation", 
                         "strings", "stringlist", "annotation", "fdecl", 
                         "callconv", "safety", "fspec", "opt_sig", "opt_tyconsig", 
                         "sigtype", "sigtypedoc", "sig_vars", "sigtypes1", 
                         "unpackedness", "forall_vis_flag", "ktype", "ktypedoc", 
                         "ctype", "ctypedoc", "tycl_context", "constr_context", 
                         "type_", "typedoc", "constr_btype", "constr_tyapps", 
                         "constr_tyapp", "btype", "tyapps", "tyapp", "atype", 
                         "inst_type", "deriv_types", "comma_types", "bar_types2", 
                         "tv_bndrs", "tv_bndr", "tv_bndr_no_braces", "fds", 
                         "fds1", "fd", "varids0", "kind", "gadt_constrlist", 
                         "gadt_constrs", "gadt_constr_with_doc", "gadt_constr", 
                         "constrs", "constrs1", "constr", "forall", "constr_stuff", 
                         "fielddecls", "fielddecl", "derivings", "deriving", 
                         "deriv_clause_types", "decl_no_th", "decl", "rhs", 
                         "gdrhs", "gdrh", "sigdecl", "activation", "th_quasiquote", 
                         "th_qquasiquote", "quasiquote", "exp", "infixexp", 
                         "exp10p", "exp10", "fexp", "aexp", "aexp1", "aexp2", 
                         "splice_exp", "splice_untyped", "splice_typed", 
                         "cmdargs", "acmd", "cvtopbody", "cvtopdecls0", 
                         "texp", "tup_exprs", "commas_tup_tail", "tup_tail", 
                         "list_", "lexps", "flattenedpquals", "pquals", 
                         "squals", "transformqual", "guards", "guard_", 
                         "alts", "alt", "alt_rhs", "ralt", "gdpats", "ifgdpats", 
                         "gdpat", "pat", "bindpat", "apat", "apats", "fpat", 
                         "stmtlist", "stmts", "stmt", "qual", "fbinds", 
                         "fbind", "dbinds", "dbind", "name_boolformula_opt", 
                         "name_boolformula_and", "name_boolformula_and_list", 
                         "name_boolformula_atom", "namelist", "name_var", 
                         "qcon_nowiredlist", "qcon", "gen_qcon", "con", 
                         "con_list", "sysdcon_nolist", "sysdcon", "conop", 
                         "qconop", "gconsym", "gtycon", "ntgtycon", "oqtycon", 
                         "qtyconop", "qtycon", "tycon", "qtyconsym", "tyconsym", 
                         "op", "varop", "qop", "qopm", "hole_op", "qvarop", 
                         "qvaropm", "tyvar", "tyvarop", "tyvarid", "tycls", 
                         "qtycls", "var_", "qvar", "qvarid", "varid", "qvarsym", 
                         "qvarsym_no_minus", "varsym", "varsym_no_minus", 
                         "special_id", "qconid", "conid", "qconsym", "consym", 
                         "literal", "open_", "close", "semi", "modid", "commas", 
                         "bars", "special", "symbol", "ascSymbol", "integer", 
                         "pfloat", "pchar", "pstring" ];

    constructor(input) {
        super(input);
        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
        this.ruleNames = HaskellParser.ruleNames;
        this.literalNames = HaskellParser.literalNames;
        this.symbolicNames = HaskellParser.symbolicNames;
    }

    get atn() {
        return atn;
    }



	module() {
	    let localctx = new ModuleContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 0, HaskellParser.RULE_module);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 513;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.OCURLY) {
	            this.state = 512;
	            this.match(HaskellParser.OCURLY);
	        }

	        this.state = 518;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,1,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 515;
	                this.semi(); 
	            }
	            this.state = 520;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,1,this._ctx);
	        }

	        this.state = 522;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,2,this._ctx);
	        if(la_===1) {
	            this.state = 521;
	            this.pragmas();

	        }
	        this.state = 527;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,3,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 524;
	                this.semi(); 
	            }
	            this.state = 529;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,3,this._ctx);
	        }

	        this.state = 532;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.MODULE:
	            this.state = 530;
	            this.module_content();
	            break;
	        case HaskellParser.NEWLINE:
	        case HaskellParser.AS:
	        case HaskellParser.CASE:
	        case HaskellParser.CLASS:
	        case HaskellParser.DATA:
	        case HaskellParser.DEFAULT:
	        case HaskellParser.DERIVING:
	        case HaskellParser.DO:
	        case HaskellParser.HIDING:
	        case HaskellParser.IF:
	        case HaskellParser.IMPORT:
	        case HaskellParser.INFIX:
	        case HaskellParser.INFIXL:
	        case HaskellParser.INFIXR:
	        case HaskellParser.INSTANCE:
	        case HaskellParser.LET:
	        case HaskellParser.NEWTYPE:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.TYPE:
	        case HaskellParser.WILDCARD:
	        case HaskellParser.FOREIGN:
	        case HaskellParser.EXPORT:
	        case HaskellParser.MDO:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.PATTERN:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.LCASE:
	        case HaskellParser.Bang:
	        case HaskellParser.Minus:
	        case HaskellParser.Tilde:
	        case HaskellParser.DDollar:
	        case HaskellParser.Dollar:
	        case HaskellParser.Semi:
	        case HaskellParser.Quote:
	        case HaskellParser.DoubleQuote:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.AopenParen:
	        case HaskellParser.TopenTexpQuote:
	        case HaskellParser.TopenExpQuote:
	        case HaskellParser.TopenPatQuote:
	        case HaskellParser.TopenTypQoute:
	        case HaskellParser.TopenDecQoute:
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.OpenSquareBracket:
	        case HaskellParser.CHAR:
	        case HaskellParser.STRING:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	        case HaskellParser.OpenPragmaBracket:
	        case HaskellParser.SEMI:
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	        case HaskellParser.FLOAT:
	            this.state = 531;
	            this.body();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	        this.state = 535;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.CCURLY) {
	            this.state = 534;
	            this.match(HaskellParser.CCURLY);
	        }

	        this.state = 538;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 537;
	            this.semi();
	        }

	        this.state = 540;
	        this.match(HaskellParser.EOF);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	module_content() {
	    let localctx = new Module_contentContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 2, HaskellParser.RULE_module_content);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 542;
	        this.match(HaskellParser.MODULE);
	        this.state = 543;
	        this.modid();
	        this.state = 545;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.OpenRoundBracket) {
	            this.state = 544;
	            this.exports();
	        }

	        this.state = 547;
	        this.where_module();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	where_module() {
	    let localctx = new Where_moduleContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 4, HaskellParser.RULE_where_module);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 549;
	        this.match(HaskellParser.WHERE);
	        this.state = 550;
	        this.module_body();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	module_body() {
	    let localctx = new Module_bodyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 6, HaskellParser.RULE_module_body);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 552;
	        this.open_();
	        this.state = 553;
	        this.body();
	        this.state = 554;
	        this.close();
	        this.state = 558;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,8,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 555;
	                this.semi(); 
	            }
	            this.state = 560;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,8,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pragmas() {
	    let localctx = new PragmasContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 8, HaskellParser.RULE_pragmas);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 562; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 561;
	        		this.pragma();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 564; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,9, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pragma() {
	    let localctx = new PragmaContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 10, HaskellParser.RULE_pragma);
	    try {
	        this.state = 569;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 566;
	            this.language_pragma();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 567;
	            this.options_ghc();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 568;
	            this.simple_options();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	language_pragma() {
	    let localctx = new Language_pragmaContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 12, HaskellParser.RULE_language_pragma);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 571;
	        this.match(HaskellParser.OpenPragmaBracket);
	        this.state = 572;
	        this.match(HaskellParser.LANGUAGE);
	        this.state = 573;
	        this.extension_();
	        this.state = 578;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 574;
	            this.match(HaskellParser.Comma);
	            this.state = 575;
	            this.extension_();
	            this.state = 580;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	        this.state = 581;
	        this.match(HaskellParser.ClosePragmaBracket);
	        this.state = 583;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,12,this._ctx);
	        if(la_===1) {
	            this.state = 582;
	            this.semi();

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	options_ghc() {
	    let localctx = new Options_ghcContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 14, HaskellParser.RULE_options_ghc);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 585;
	        this.match(HaskellParser.OpenPragmaBracket);
	        this.state = 586;
	        this.match(HaskellParser.OPTIONS_GHC);
	        this.state = 594;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Minus) {
	            this.state = 587;
	            this.match(HaskellParser.Minus);
	            this.state = 590;
	            this._errHandler.sync(this);
	            switch(this._input.LA(1)) {
	            case HaskellParser.AS:
	            case HaskellParser.HIDING:
	            case HaskellParser.QUALIFIED:
	            case HaskellParser.EXPORT:
	            case HaskellParser.STDCALL:
	            case HaskellParser.CCALL:
	            case HaskellParser.CAPI:
	            case HaskellParser.JSCALL:
	            case HaskellParser.STOCK:
	            case HaskellParser.ANYCLASS:
	            case HaskellParser.VIA:
	            case HaskellParser.VARID:
	                this.state = 588;
	                this.varid();
	                break;
	            case HaskellParser.CONID:
	                this.state = 589;
	                this.conid();
	                break;
	            default:
	                throw new antlr4.error.NoViableAltException(this);
	            }
	            this.state = 596;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	        this.state = 597;
	        this.match(HaskellParser.ClosePragmaBracket);
	        this.state = 599;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,15,this._ctx);
	        if(la_===1) {
	            this.state = 598;
	            this.semi();

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	simple_options() {
	    let localctx = new Simple_optionsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 16, HaskellParser.RULE_simple_options);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 601;
	        this.match(HaskellParser.OpenPragmaBracket);
	        this.state = 602;
	        this.match(HaskellParser.OPTIONS);
	        this.state = 610;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Minus) {
	            this.state = 603;
	            this.match(HaskellParser.Minus);
	            this.state = 606;
	            this._errHandler.sync(this);
	            switch(this._input.LA(1)) {
	            case HaskellParser.AS:
	            case HaskellParser.HIDING:
	            case HaskellParser.QUALIFIED:
	            case HaskellParser.EXPORT:
	            case HaskellParser.STDCALL:
	            case HaskellParser.CCALL:
	            case HaskellParser.CAPI:
	            case HaskellParser.JSCALL:
	            case HaskellParser.STOCK:
	            case HaskellParser.ANYCLASS:
	            case HaskellParser.VIA:
	            case HaskellParser.VARID:
	                this.state = 604;
	                this.varid();
	                break;
	            case HaskellParser.CONID:
	                this.state = 605;
	                this.conid();
	                break;
	            default:
	                throw new antlr4.error.NoViableAltException(this);
	            }
	            this.state = 612;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	        this.state = 613;
	        this.match(HaskellParser.ClosePragmaBracket);
	        this.state = 615;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,18,this._ctx);
	        if(la_===1) {
	            this.state = 614;
	            this.semi();

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	extension_() {
	    let localctx = new Extension_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 18, HaskellParser.RULE_extension_);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 617;
	        this.match(HaskellParser.CONID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	body() {
	    let localctx = new BodyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 20, HaskellParser.RULE_body);
	    try {
	        this.state = 624;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,19,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 619;
	            this.impdecls();
	            this.state = 620;
	            this.topdecls();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 622;
	            this.impdecls();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 623;
	            this.topdecls();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	impdecls() {
	    let localctx = new ImpdeclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 22, HaskellParser.RULE_impdecls);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 629; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 629;
	        		this._errHandler.sync(this);
	        		switch(this._input.LA(1)) {
	        		case HaskellParser.IMPORT:
	        		    this.state = 626;
	        		    this.impdecl();
	        		    break;
	        		case HaskellParser.NEWLINE:
	        		    this.state = 627;
	        		    this.match(HaskellParser.NEWLINE);
	        		    break;
	        		case HaskellParser.Semi:
	        		case HaskellParser.SEMI:
	        		    this.state = 628;
	        		    this.semi();
	        		    break;
	        		default:
	        		    throw new antlr4.error.NoViableAltException(this);
	        		}
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 631; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,21, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	exports() {
	    let localctx = new ExportsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 24, HaskellParser.RULE_exports);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 633;
	        this.match(HaskellParser.OpenRoundBracket);
	        this.state = 642;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.MODULE) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.CONID - 120)))) !== 0)) {
	            this.state = 634;
	            this.exprt();
	            this.state = 639;
	            this._errHandler.sync(this);
	            var _alt = this._interp.adaptivePredict(this._input,22,this._ctx)
	            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	                if(_alt===1) {
	                    this.state = 635;
	                    this.match(HaskellParser.Comma);
	                    this.state = 636;
	                    this.exprt(); 
	                }
	                this.state = 641;
	                this._errHandler.sync(this);
	                _alt = this._interp.adaptivePredict(this._input,22,this._ctx);
	            }

	        }

	        this.state = 645;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Comma) {
	            this.state = 644;
	            this.match(HaskellParser.Comma);
	        }

	        this.state = 647;
	        this.match(HaskellParser.CloseRoundBracket);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	exprt() {
	    let localctx = new ExprtContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 26, HaskellParser.RULE_exprt);
	    var _la = 0; // Token type
	    try {
	        this.state = 688;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,31,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 649;
	            this.qvar();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 650;
	            this.qtycon();
	            this.state = 666;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,27,this._ctx);
	            if(la_===1) {
	                this.state = 651;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 652;
	                this.match(HaskellParser.DoubleDot);
	                this.state = 653;
	                this.match(HaskellParser.CloseRoundBracket);

	            } else if(la_===2) {
	                this.state = 654;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 663;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	                    this.state = 655;
	                    this.cname();
	                    this.state = 660;
	                    this._errHandler.sync(this);
	                    _la = this._input.LA(1);
	                    while(_la===HaskellParser.Comma) {
	                        this.state = 656;
	                        this.match(HaskellParser.Comma);
	                        this.state = 657;
	                        this.cname();
	                        this.state = 662;
	                        this._errHandler.sync(this);
	                        _la = this._input.LA(1);
	                    }
	                }

	                this.state = 665;
	                this.match(HaskellParser.CloseRoundBracket);

	            }
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 668;
	            this.qtycls();
	            this.state = 684;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,30,this._ctx);
	            if(la_===1) {
	                this.state = 669;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 670;
	                this.match(HaskellParser.DoubleDot);
	                this.state = 671;
	                this.match(HaskellParser.CloseRoundBracket);

	            } else if(la_===2) {
	                this.state = 672;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 681;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.CONID - 120)))) !== 0)) {
	                    this.state = 673;
	                    this.qvar();
	                    this.state = 678;
	                    this._errHandler.sync(this);
	                    _la = this._input.LA(1);
	                    while(_la===HaskellParser.Comma) {
	                        this.state = 674;
	                        this.match(HaskellParser.Comma);
	                        this.state = 675;
	                        this.qvar();
	                        this.state = 680;
	                        this._errHandler.sync(this);
	                        _la = this._input.LA(1);
	                    }
	                }

	                this.state = 683;
	                this.match(HaskellParser.CloseRoundBracket);

	            }
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 686;
	            this.match(HaskellParser.MODULE);
	            this.state = 687;
	            this.modid();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	impdecl() {
	    let localctx = new ImpdeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 28, HaskellParser.RULE_impdecl);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 690;
	        this.match(HaskellParser.IMPORT);
	        this.state = 692;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.QUALIFIED) {
	            this.state = 691;
	            this.match(HaskellParser.QUALIFIED);
	        }

	        this.state = 694;
	        this.modid();
	        this.state = 697;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.AS) {
	            this.state = 695;
	            this.match(HaskellParser.AS);
	            this.state = 696;
	            this.modid();
	        }

	        this.state = 700;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.HIDING || _la===HaskellParser.OpenRoundBracket) {
	            this.state = 699;
	            this.impspec();
	        }

	        this.state = 703; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 702;
	        		this.semi();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 705; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,35, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	impspec() {
	    let localctx = new ImpspecContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 30, HaskellParser.RULE_impspec);
	    var _la = 0; // Token type
	    try {
	        this.state = 738;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 707;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 719;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.CONID - 120)))) !== 0)) {
	                this.state = 708;
	                this.himport();
	                this.state = 713;
	                this._errHandler.sync(this);
	                var _alt = this._interp.adaptivePredict(this._input,36,this._ctx)
	                while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	                    if(_alt===1) {
	                        this.state = 709;
	                        this.match(HaskellParser.Comma);
	                        this.state = 710;
	                        this.himport(); 
	                    }
	                    this.state = 715;
	                    this._errHandler.sync(this);
	                    _alt = this._interp.adaptivePredict(this._input,36,this._ctx);
	                }

	                this.state = 717;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if(_la===HaskellParser.Comma) {
	                    this.state = 716;
	                    this.match(HaskellParser.Comma);
	                }

	            }

	            this.state = 721;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        case HaskellParser.HIDING:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 722;
	            this.match(HaskellParser.HIDING);
	            this.state = 723;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 735;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.CONID - 120)))) !== 0)) {
	                this.state = 724;
	                this.himport();
	                this.state = 729;
	                this._errHandler.sync(this);
	                var _alt = this._interp.adaptivePredict(this._input,39,this._ctx)
	                while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	                    if(_alt===1) {
	                        this.state = 725;
	                        this.match(HaskellParser.Comma);
	                        this.state = 726;
	                        this.himport(); 
	                    }
	                    this.state = 731;
	                    this._errHandler.sync(this);
	                    _alt = this._interp.adaptivePredict(this._input,39,this._ctx);
	                }

	                this.state = 733;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if(_la===HaskellParser.Comma) {
	                    this.state = 732;
	                    this.match(HaskellParser.Comma);
	                }

	            }

	            this.state = 737;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	himport() {
	    let localctx = new HimportContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 32, HaskellParser.RULE_himport);
	    var _la = 0; // Token type
	    try {
	        this.state = 770;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,48,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 740;
	            this.var_();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 741;
	            this.tycon();
	            this.state = 757;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,45,this._ctx);
	            if(la_===1) {
	                this.state = 742;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 743;
	                this.match(HaskellParser.DoubleDot);
	                this.state = 744;
	                this.match(HaskellParser.CloseRoundBracket);

	            } else if(la_===2) {
	                this.state = 745;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 754;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	                    this.state = 746;
	                    this.cname();
	                    this.state = 751;
	                    this._errHandler.sync(this);
	                    _la = this._input.LA(1);
	                    while(_la===HaskellParser.Comma) {
	                        this.state = 747;
	                        this.match(HaskellParser.Comma);
	                        this.state = 748;
	                        this.cname();
	                        this.state = 753;
	                        this._errHandler.sync(this);
	                        _la = this._input.LA(1);
	                    }
	                }

	                this.state = 756;
	                this.match(HaskellParser.CloseRoundBracket);

	            }
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 759;
	            this.tycls();
	            this.state = 768;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,47,this._ctx);
	            if(la_===1) {
	                this.state = 760;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 761;
	                this.match(HaskellParser.DoubleDot);
	                this.state = 762;
	                this.match(HaskellParser.CloseRoundBracket);

	            } else if(la_===2) {
	                this.state = 763;
	                this.match(HaskellParser.OpenRoundBracket);
	                this.state = 765;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.OpenRoundBracket || _la===HaskellParser.VARID) {
	                    this.state = 764;
	                    this.sig_vars();
	                }

	                this.state = 767;
	                this.match(HaskellParser.CloseRoundBracket);

	            }
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cname() {
	    let localctx = new CnameContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 34, HaskellParser.RULE_cname);
	    try {
	        this.state = 774;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,49,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 772;
	            this.var_();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 773;
	            this.con();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fixity() {
	    let localctx = new FixityContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 36, HaskellParser.RULE_fixity);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 776;
	        _la = this._input.LA(1);
	        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ops() {
	    let localctx = new OpsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 38, HaskellParser.RULE_ops);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 778;
	        this.op();
	        this.state = 783;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 779;
	            this.match(HaskellParser.Comma);
	            this.state = 780;
	            this.op();
	            this.state = 785;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	topdecls() {
	    let localctx = new TopdeclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 40, HaskellParser.RULE_topdecls);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 794; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 794;
	        		this._errHandler.sync(this);
	        		var la_ = this._interp.adaptivePredict(this._input,52,this._ctx);
	        		switch(la_) {
	        		case 1:
	        		    this.state = 786;
	        		    this.topdecl();
	        		    this.state = 788; 
	        		    this._errHandler.sync(this);
	        		    var _alt = 1;
	        		    do {
	        		    	switch (_alt) {
	        		    	case 1:
	        		    		this.state = 787;
	        		    		this.semi();
	        		    		break;
	        		    	default:
	        		    		throw new antlr4.error.NoViableAltException(this);
	        		    	}
	        		    	this.state = 790; 
	        		    	this._errHandler.sync(this);
	        		    	_alt = this._interp.adaptivePredict(this._input,51, this._ctx);
	        		    } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	        		    break;

	        		case 2:
	        		    this.state = 792;
	        		    this.match(HaskellParser.NEWLINE);
	        		    break;

	        		case 3:
	        		    this.state = 793;
	        		    this.semi();
	        		    break;

	        		}
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 796; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,53, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	topdecl() {
	    let localctx = new TopdeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 42, HaskellParser.RULE_topdecl);
	    var _la = 0; // Token type
	    try {
	        this.state = 833;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,58,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 798;
	            this.cl_decl();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 799;
	            this.ty_decl();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 800;
	            this.standalone_kind_sig();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 801;
	            this.inst_decl();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 802;
	            this.standalone_deriving();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 803;
	            this.role_annot();
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 804;
	            this.match(HaskellParser.DEFAULT);
	            this.state = 805;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 807;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.FORALL) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 82)) & ~0x1f) == 0 && ((1 << (_la - 82)) & ((1 << (HaskellParser.Hash - 82)) | (1 << (HaskellParser.Less - 82)) | (1 << (HaskellParser.Greater - 82)) | (1 << (HaskellParser.Ampersand - 82)) | (1 << (HaskellParser.Pipe - 82)) | (1 << (HaskellParser.Bang - 82)) | (1 << (HaskellParser.Caret - 82)) | (1 << (HaskellParser.Plus - 82)) | (1 << (HaskellParser.Minus - 82)) | (1 << (HaskellParser.Asterisk - 82)) | (1 << (HaskellParser.Percent - 82)) | (1 << (HaskellParser.Divide - 82)) | (1 << (HaskellParser.Tilde - 82)) | (1 << (HaskellParser.Atsign - 82)) | (1 << (HaskellParser.Dollar - 82)) | (1 << (HaskellParser.Dot - 82)) | (1 << (HaskellParser.QuestionMark - 82)) | (1 << (HaskellParser.Colon - 82)) | (1 << (HaskellParser.Eq - 82)) | (1 << (HaskellParser.Quote - 82)) | (1 << (HaskellParser.ReverseSlash - 82)) | (1 << (HaskellParser.BackQuote - 82)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.STRING - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)) | (1 << (HaskellParser.OpenPragmaBracket - 118)) | (1 << (HaskellParser.OCURLY - 118)) | (1 << (HaskellParser.DECIMAL - 118)) | (1 << (HaskellParser.OCTAL - 118)) | (1 << (HaskellParser.HEXADECIMAL - 118)))) !== 0)) {
	                this.state = 806;
	                this.comma_types();
	            }

	            this.state = 809;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 810;
	            this.match(HaskellParser.FOREIGN);
	            this.state = 811;
	            this.fdecl();
	            break;

	        case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 812;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 813;
	            this.match(HaskellParser.DEPRECATED);
	            this.state = 815;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	                this.state = 814;
	                this.deprecations();
	            }

	            this.state = 817;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 818;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 819;
	            this.match(HaskellParser.WARNING);
	            this.state = 821;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	                this.state = 820;
	                this.warnings();
	            }

	            this.state = 823;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 824;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 825;
	            this.match(HaskellParser.RULES);
	            this.state = 827;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.STRING) {
	                this.state = 826;
	                this.rules();
	            }

	            this.state = 829;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 830;
	            this.annotation();
	            break;

	        case 13:
	            this.enterOuterAlt(localctx, 13);
	            this.state = 831;
	            this.decl_no_th();
	            break;

	        case 14:
	            this.enterOuterAlt(localctx, 14);
	            this.state = 832;
	            this.infixexp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cl_decl() {
	    let localctx = new Cl_declContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 44, HaskellParser.RULE_cl_decl);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 835;
	        this.match(HaskellParser.CLASS);
	        this.state = 836;
	        this.tycl_hdr();
	        this.state = 838;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Pipe) {
	            this.state = 837;
	            this.fds();
	        }

	        this.state = 841;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.WHERE) {
	            this.state = 840;
	            this.where_cls();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ty_decl() {
	    let localctx = new Ty_declContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 46, HaskellParser.RULE_ty_decl);
	    var _la = 0; // Token type
	    try {
	        this.state = 912;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,77,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 843;
	            this.match(HaskellParser.TYPE);
	            this.state = 844;
	            this.type_();
	            this.state = 845;
	            this.match(HaskellParser.Eq);
	            this.state = 846;
	            this.ktypedoc();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 848;
	            this.match(HaskellParser.TYPE);
	            this.state = 849;
	            this.match(HaskellParser.FAMILY);
	            this.state = 850;
	            this.type_();
	            this.state = 852;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon || _la===HaskellParser.Eq) {
	                this.state = 851;
	                this.opt_tyfam_kind_sig();
	            }

	            this.state = 855;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.Pipe) {
	                this.state = 854;
	                this.opt_injective_info();
	            }

	            this.state = 858;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 857;
	                this.where_type_family();
	            }

	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 860;
	            this.match(HaskellParser.DATA);
	            this.state = 862;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,64,this._ctx);
	            if(la_===1) {
	                this.state = 861;
	                this.capi_ctype();

	            }
	            this.state = 864;
	            this.tycl_hdr();
	            this.state = 865;
	            this.constrs();
	            this.state = 867;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 866;
	                this.derivings();
	            }

	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 869;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 871;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,66,this._ctx);
	            if(la_===1) {
	                this.state = 870;
	                this.capi_ctype();

	            }
	            this.state = 873;
	            this.tycl_hdr();
	            this.state = 874;
	            this.constrs();
	            this.state = 876;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 875;
	                this.derivings();
	            }

	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 878;
	            this.match(HaskellParser.DATA);
	            this.state = 880;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,68,this._ctx);
	            if(la_===1) {
	                this.state = 879;
	                this.capi_ctype();

	            }
	            this.state = 882;
	            this.tycl_hdr();
	            this.state = 884;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 883;
	                this.opt_kind_sig();
	            }

	            this.state = 887;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 886;
	                this.gadt_constrlist();
	            }

	            this.state = 890;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 889;
	                this.derivings();
	            }

	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 892;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 894;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,72,this._ctx);
	            if(la_===1) {
	                this.state = 893;
	                this.capi_ctype();

	            }
	            this.state = 896;
	            this.tycl_hdr();
	            this.state = 898;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 897;
	                this.opt_kind_sig();
	            }

	            this.state = 901;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 900;
	                this.gadt_constrlist();
	            }

	            this.state = 904;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 903;
	                this.derivings();
	            }

	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 906;
	            this.match(HaskellParser.DATA);
	            this.state = 907;
	            this.match(HaskellParser.FAMILY);
	            this.state = 908;
	            this.type_();
	            this.state = 910;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 909;
	                this.opt_datafam_kind_sig();
	            }

	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	standalone_kind_sig() {
	    let localctx = new Standalone_kind_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 48, HaskellParser.RULE_standalone_kind_sig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 914;
	        this.match(HaskellParser.TYPE);
	        this.state = 915;
	        this.sks_vars();
	        this.state = 916;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 917;
	        this.ktypedoc();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sks_vars() {
	    let localctx = new Sks_varsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 50, HaskellParser.RULE_sks_vars);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 919;
	        this.oqtycon();
	        this.state = 924;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 920;
	            this.match(HaskellParser.Comma);
	            this.state = 921;
	            this.oqtycon();
	            this.state = 926;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	inst_decl() {
	    let localctx = new Inst_declContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 52, HaskellParser.RULE_inst_decl);
	    var _la = 0; // Token type
	    try {
	        this.state = 986;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,93,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 927;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 929;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,79,this._ctx);
	            if(la_===1) {
	                this.state = 928;
	                this.overlap_pragma();

	            }
	            this.state = 931;
	            this.inst_type();
	            this.state = 933;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 932;
	                this.where_inst();
	            }

	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 935;
	            this.match(HaskellParser.TYPE);
	            this.state = 936;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 937;
	            this.ty_fam_inst_eqn();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 938;
	            this.match(HaskellParser.DATA);
	            this.state = 939;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 941;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,81,this._ctx);
	            if(la_===1) {
	                this.state = 940;
	                this.capi_ctype();

	            }
	            this.state = 943;
	            this.tycl_hdr_inst();
	            this.state = 945;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 944;
	                this.derivings();
	            }

	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 947;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 948;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 950;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,83,this._ctx);
	            if(la_===1) {
	                this.state = 949;
	                this.capi_ctype();

	            }
	            this.state = 952;
	            this.tycl_hdr_inst();
	            this.state = 954;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 953;
	                this.derivings();
	            }

	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 956;
	            this.match(HaskellParser.DATA);
	            this.state = 957;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 959;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,85,this._ctx);
	            if(la_===1) {
	                this.state = 958;
	                this.capi_ctype();

	            }
	            this.state = 961;
	            this.tycl_hdr_inst();
	            this.state = 963;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 962;
	                this.opt_kind_sig();
	            }

	            this.state = 966;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 965;
	                this.gadt_constrlist();
	            }

	            this.state = 969;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 968;
	                this.derivings();
	            }

	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 971;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 972;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 974;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,89,this._ctx);
	            if(la_===1) {
	                this.state = 973;
	                this.capi_ctype();

	            }
	            this.state = 976;
	            this.tycl_hdr_inst();
	            this.state = 978;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 977;
	                this.opt_kind_sig();
	            }

	            this.state = 981;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 980;
	                this.gadt_constrlist();
	            }

	            this.state = 984;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 983;
	                this.derivings();
	            }

	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	overlap_pragma() {
	    let localctx = new Overlap_pragmaContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 54, HaskellParser.RULE_overlap_pragma);
	    try {
	        this.state = 1000;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,94,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 988;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 989;
	            this.match(HaskellParser.OVERLAPPABLE);
	            this.state = 990;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 991;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 992;
	            this.match(HaskellParser.OVERLAPPING);
	            this.state = 993;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 994;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 995;
	            this.match(HaskellParser.OVERLAPS);
	            this.state = 996;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 997;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 998;
	            this.match(HaskellParser.INCOHERENT);
	            this.state = 999;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriv_strategy_no_via() {
	    let localctx = new Deriv_strategy_no_viaContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 56, HaskellParser.RULE_deriv_strategy_no_via);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1002;
	        _la = this._input.LA(1);
	        if(!(((((_la - 22)) & ~0x1f) == 0 && ((1 << (_la - 22)) & ((1 << (HaskellParser.NEWTYPE - 22)) | (1 << (HaskellParser.STOCK - 22)) | (1 << (HaskellParser.ANYCLASS - 22)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriv_strategy_via() {
	    let localctx = new Deriv_strategy_viaContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 58, HaskellParser.RULE_deriv_strategy_via);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1004;
	        this.match(HaskellParser.VIA);
	        this.state = 1005;
	        this.ktype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriv_standalone_strategy() {
	    let localctx = new Deriv_standalone_strategyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 60, HaskellParser.RULE_deriv_standalone_strategy);
	    try {
	        this.state = 1011;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.STOCK:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1007;
	            this.match(HaskellParser.STOCK);
	            break;
	        case HaskellParser.ANYCLASS:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1008;
	            this.match(HaskellParser.ANYCLASS);
	            break;
	        case HaskellParser.NEWTYPE:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1009;
	            this.match(HaskellParser.NEWTYPE);
	            break;
	        case HaskellParser.VIA:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1010;
	            this.deriv_strategy_via();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_injective_info() {
	    let localctx = new Opt_injective_infoContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 62, HaskellParser.RULE_opt_injective_info);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1013;
	        this.match(HaskellParser.Pipe);
	        this.state = 1014;
	        this.injectivity_cond();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	injectivity_cond() {
	    let localctx = new Injectivity_condContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 64, HaskellParser.RULE_injectivity_cond);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1016;
	        this.tyvarid();
	        this.state = 1017;
	        this.match(HaskellParser.Arrow);
	        this.state = 1018;
	        this.inj_varids();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	inj_varids() {
	    let localctx = new Inj_varidsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 66, HaskellParser.RULE_inj_varids);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1021; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1020;
	            this.tyvarid();
	            this.state = 1023; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (HaskellParser.SAFE - 32)) | (1 << (HaskellParser.INTERRUPTIBLE - 32)) | (1 << (HaskellParser.UNSAFE - 32)) | (1 << (HaskellParser.STDCALL - 32)) | (1 << (HaskellParser.CCALL - 32)) | (1 << (HaskellParser.CAPI - 32)) | (1 << (HaskellParser.JSCALL - 32)) | (1 << (HaskellParser.STOCK - 32)) | (1 << (HaskellParser.ANYCLASS - 32)) | (1 << (HaskellParser.VIA - 32)))) !== 0) || _la===HaskellParser.VARID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	where_type_family() {
	    let localctx = new Where_type_familyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 68, HaskellParser.RULE_where_type_family);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1025;
	        this.match(HaskellParser.WHERE);
	        this.state = 1026;
	        this.ty_fam_inst_eqn_list();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ty_fam_inst_eqn_list() {
	    let localctx = new Ty_fam_inst_eqn_listContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 70, HaskellParser.RULE_ty_fam_inst_eqn_list);
	    var _la = 0; // Token type
	    try {
	        this.state = 1041;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,98,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1028;
	            this.open_();
	            this.state = 1030;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.FORALL) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 82)) & ~0x1f) == 0 && ((1 << (_la - 82)) & ((1 << (HaskellParser.Hash - 82)) | (1 << (HaskellParser.Less - 82)) | (1 << (HaskellParser.Greater - 82)) | (1 << (HaskellParser.Ampersand - 82)) | (1 << (HaskellParser.Pipe - 82)) | (1 << (HaskellParser.Bang - 82)) | (1 << (HaskellParser.Caret - 82)) | (1 << (HaskellParser.Plus - 82)) | (1 << (HaskellParser.Minus - 82)) | (1 << (HaskellParser.Asterisk - 82)) | (1 << (HaskellParser.Percent - 82)) | (1 << (HaskellParser.Divide - 82)) | (1 << (HaskellParser.Tilde - 82)) | (1 << (HaskellParser.Atsign - 82)) | (1 << (HaskellParser.Dollar - 82)) | (1 << (HaskellParser.Dot - 82)) | (1 << (HaskellParser.QuestionMark - 82)) | (1 << (HaskellParser.Colon - 82)) | (1 << (HaskellParser.Eq - 82)) | (1 << (HaskellParser.Quote - 82)) | (1 << (HaskellParser.ReverseSlash - 82)) | (1 << (HaskellParser.BackQuote - 82)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.STRING - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)) | (1 << (HaskellParser.OpenPragmaBracket - 118)) | (1 << (HaskellParser.OCURLY - 118)) | (1 << (HaskellParser.DECIMAL - 118)) | (1 << (HaskellParser.OCTAL - 118)) | (1 << (HaskellParser.HEXADECIMAL - 118)))) !== 0)) {
	                this.state = 1029;
	                this.ty_fam_inst_eqns();
	            }

	            this.state = 1032;
	            this.close();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1034;
	            this.match(HaskellParser.OCURLY);
	            this.state = 1035;
	            this.match(HaskellParser.DoubleDot);
	            this.state = 1036;
	            this.match(HaskellParser.CCURLY);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1037;
	            this.open_();
	            this.state = 1038;
	            this.match(HaskellParser.DoubleDot);
	            this.state = 1039;
	            this.close();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ty_fam_inst_eqns() {
	    let localctx = new Ty_fam_inst_eqnsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 72, HaskellParser.RULE_ty_fam_inst_eqns);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1043;
	        this.ty_fam_inst_eqn();
	        this.state = 1053;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,100,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1045; 
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                do {
	                    this.state = 1044;
	                    this.semi();
	                    this.state = 1047; 
	                    this._errHandler.sync(this);
	                    _la = this._input.LA(1);
	                } while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI);
	                this.state = 1049;
	                this.ty_fam_inst_eqn(); 
	            }
	            this.state = 1055;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,100,this._ctx);
	        }

	        this.state = 1059;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1056;
	            this.semi();
	            this.state = 1061;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ty_fam_inst_eqn() {
	    let localctx = new Ty_fam_inst_eqnContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 74, HaskellParser.RULE_ty_fam_inst_eqn);
	    var _la = 0; // Token type
	    try {
	        this.state = 1075;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.FORALL:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1062;
	            this.match(HaskellParser.FORALL);
	            this.state = 1064;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	                this.state = 1063;
	                this.tv_bndrs();
	            }

	            this.state = 1066;
	            this.match(HaskellParser.Dot);
	            this.state = 1067;
	            this.type_();
	            this.state = 1068;
	            this.match(HaskellParser.Eq);
	            this.state = 1069;
	            this.ktype();
	            break;
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.WILDCARD:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Minus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.Quote:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.BackQuote:
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.OpenSquareBracket:
	        case HaskellParser.STRING:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	        case HaskellParser.OpenPragmaBracket:
	        case HaskellParser.OCURLY:
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1071;
	            this.type_();
	            this.state = 1072;
	            this.match(HaskellParser.Eq);
	            this.state = 1073;
	            this.ktype();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	at_decl_cls() {
	    let localctx = new At_decl_clsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 76, HaskellParser.RULE_at_decl_cls);
	    var _la = 0; // Token type
	    try {
	        this.state = 1098;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,109,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1077;
	            this.match(HaskellParser.DATA);
	            this.state = 1079;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.FAMILY) {
	                this.state = 1078;
	                this.match(HaskellParser.FAMILY);
	            }

	            this.state = 1081;
	            this.type_();
	            this.state = 1083;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 1082;
	                this.opt_datafam_kind_sig();
	            }

	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1085;
	            this.match(HaskellParser.TYPE);
	            this.state = 1087;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.FAMILY) {
	                this.state = 1086;
	                this.match(HaskellParser.FAMILY);
	            }

	            this.state = 1089;
	            this.type_();
	            this.state = 1091;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon || _la===HaskellParser.Eq) {
	                this.state = 1090;
	                this.opt_at_kind_inj_sig();
	            }

	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1093;
	            this.match(HaskellParser.TYPE);
	            this.state = 1095;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1094;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1097;
	            this.ty_fam_inst_eqn();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	at_decl_inst() {
	    let localctx = new At_decl_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 78, HaskellParser.RULE_at_decl_inst);
	    var _la = 0; // Token type
	    try {
	        this.state = 1163;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,127,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1100;
	            this.match(HaskellParser.TYPE);
	            this.state = 1102;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1101;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1104;
	            this.ty_fam_inst_eqn();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1105;
	            this.match(HaskellParser.DATA);
	            this.state = 1107;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1106;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1110;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,112,this._ctx);
	            if(la_===1) {
	                this.state = 1109;
	                this.capi_ctype();

	            }
	            this.state = 1112;
	            this.tycl_hdr_inst();
	            this.state = 1113;
	            this.constrs();
	            this.state = 1115;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 1114;
	                this.derivings();
	            }

	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1117;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 1119;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1118;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1122;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,115,this._ctx);
	            if(la_===1) {
	                this.state = 1121;
	                this.capi_ctype();

	            }
	            this.state = 1124;
	            this.tycl_hdr_inst();
	            this.state = 1125;
	            this.constrs();
	            this.state = 1127;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 1126;
	                this.derivings();
	            }

	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1129;
	            this.match(HaskellParser.DATA);
	            this.state = 1131;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1130;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1134;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,118,this._ctx);
	            if(la_===1) {
	                this.state = 1133;
	                this.capi_ctype();

	            }
	            this.state = 1136;
	            this.tycl_hdr_inst();
	            this.state = 1138;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 1137;
	                this.opt_kind_sig();
	            }

	            this.state = 1141;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 1140;
	                this.gadt_constrlist();
	            }

	            this.state = 1144;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 1143;
	                this.derivings();
	            }

	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 1146;
	            this.match(HaskellParser.NEWTYPE);
	            this.state = 1148;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.INSTANCE) {
	                this.state = 1147;
	                this.match(HaskellParser.INSTANCE);
	            }

	            this.state = 1151;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,123,this._ctx);
	            if(la_===1) {
	                this.state = 1150;
	                this.capi_ctype();

	            }
	            this.state = 1153;
	            this.tycl_hdr_inst();
	            this.state = 1155;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 1154;
	                this.opt_kind_sig();
	            }

	            this.state = 1158;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 1157;
	                this.gadt_constrlist();
	            }

	            this.state = 1161;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DERIVING) {
	                this.state = 1160;
	                this.derivings();
	            }

	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_kind_sig() {
	    let localctx = new Opt_kind_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 80, HaskellParser.RULE_opt_kind_sig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1165;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1166;
	        this.kind();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_datafam_kind_sig() {
	    let localctx = new Opt_datafam_kind_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 82, HaskellParser.RULE_opt_datafam_kind_sig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1168;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1169;
	        this.kind();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_tyfam_kind_sig() {
	    let localctx = new Opt_tyfam_kind_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 84, HaskellParser.RULE_opt_tyfam_kind_sig);
	    try {
	        this.state = 1175;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DoubleColon:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1171;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1172;
	            this.kind();
	            break;
	        case HaskellParser.Eq:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1173;
	            this.match(HaskellParser.Eq);
	            this.state = 1174;
	            this.tv_bndr();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_at_kind_inj_sig() {
	    let localctx = new Opt_at_kind_inj_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 86, HaskellParser.RULE_opt_at_kind_inj_sig);
	    try {
	        this.state = 1184;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DoubleColon:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1177;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1178;
	            this.kind();
	            break;
	        case HaskellParser.Eq:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1179;
	            this.match(HaskellParser.Eq);
	            this.state = 1180;
	            this.tv_bndr_no_braces();
	            this.state = 1181;
	            this.match(HaskellParser.Pipe);
	            this.state = 1182;
	            this.injectivity_cond();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tycl_hdr() {
	    let localctx = new Tycl_hdrContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 88, HaskellParser.RULE_tycl_hdr);
	    try {
	        this.state = 1191;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,130,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1186;
	            this.tycl_context();
	            this.state = 1187;
	            this.match(HaskellParser.DoubleArrow);
	            this.state = 1188;
	            this.type_();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1190;
	            this.type_();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tycl_hdr_inst() {
	    let localctx = new Tycl_hdr_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 90, HaskellParser.RULE_tycl_hdr_inst);
	    var _la = 0; // Token type
	    try {
	        this.state = 1213;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,133,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1193;
	            this.match(HaskellParser.FORALL);
	            this.state = 1195;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	                this.state = 1194;
	                this.tv_bndrs();
	            }

	            this.state = 1197;
	            this.match(HaskellParser.Dot);
	            this.state = 1198;
	            this.tycl_context();
	            this.state = 1199;
	            this.match(HaskellParser.DoubleArrow);
	            this.state = 1200;
	            this.type_();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1202;
	            this.match(HaskellParser.FORALL);
	            this.state = 1204;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	                this.state = 1203;
	                this.tv_bndrs();
	            }

	            this.state = 1206;
	            this.match(HaskellParser.Dot);
	            this.state = 1207;
	            this.type_();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1208;
	            this.tycl_context();
	            this.state = 1209;
	            this.match(HaskellParser.DoubleArrow);
	            this.state = 1210;
	            this.type_();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1212;
	            this.type_();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	capi_ctype() {
	    let localctx = new Capi_ctypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 92, HaskellParser.RULE_capi_ctype);
	    try {
	        this.state = 1224;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,134,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1215;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1216;
	            this.match(HaskellParser.CTYPE);
	            this.state = 1217;
	            this.match(HaskellParser.STRING);
	            this.state = 1218;
	            this.match(HaskellParser.STRING);
	            this.state = 1219;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1220;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1221;
	            this.match(HaskellParser.CTYPE);
	            this.state = 1222;
	            this.match(HaskellParser.STRING);
	            this.state = 1223;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	standalone_deriving() {
	    let localctx = new Standalone_derivingContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 94, HaskellParser.RULE_standalone_deriving);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1226;
	        this.match(HaskellParser.DERIVING);
	        this.state = 1228;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(((((_la - 22)) & ~0x1f) == 0 && ((1 << (_la - 22)) & ((1 << (HaskellParser.NEWTYPE - 22)) | (1 << (HaskellParser.STOCK - 22)) | (1 << (HaskellParser.ANYCLASS - 22)) | (1 << (HaskellParser.VIA - 22)))) !== 0)) {
	            this.state = 1227;
	            this.deriv_standalone_strategy();
	        }

	        this.state = 1230;
	        this.match(HaskellParser.INSTANCE);
	        this.state = 1232;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,136,this._ctx);
	        if(la_===1) {
	            this.state = 1231;
	            this.overlap_pragma();

	        }
	        this.state = 1234;
	        this.inst_type();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	role_annot() {
	    let localctx = new Role_annotContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 96, HaskellParser.RULE_role_annot);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1236;
	        this.match(HaskellParser.TYPE);
	        this.state = 1237;
	        this.match(HaskellParser.ROLE);
	        this.state = 1238;
	        this.oqtycon();
	        this.state = 1240;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID) {
	            this.state = 1239;
	            this.roles();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	roles() {
	    let localctx = new RolesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 98, HaskellParser.RULE_roles);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1243; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1242;
	            this.role();
	            this.state = 1245; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	role() {
	    let localctx = new RoleContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 100, HaskellParser.RULE_role);
	    try {
	        this.state = 1249;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.VARID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1247;
	            this.varid();
	            break;
	        case HaskellParser.WILDCARD:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1248;
	            this.match(HaskellParser.WILDCARD);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pattern_synonym_decl() {
	    let localctx = new Pattern_synonym_declContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 102, HaskellParser.RULE_pattern_synonym_decl);
	    var _la = 0; // Token type
	    try {
	        this.state = 1263;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,141,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1251;
	            this.match(HaskellParser.PATTERN);
	            this.state = 1252;
	            this.pattern_synonym_lhs();
	            this.state = 1253;
	            this.match(HaskellParser.Eq);
	            this.state = 1254;
	            this.pat();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1256;
	            this.match(HaskellParser.PATTERN);
	            this.state = 1257;
	            this.pattern_synonym_lhs();
	            this.state = 1258;
	            this.match(HaskellParser.Revarrow);
	            this.state = 1259;
	            this.pat();
	            this.state = 1261;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 1260;
	                this.where_decls();
	            }

	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pattern_synonym_lhs() {
	    let localctx = new Pattern_synonym_lhsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 104, HaskellParser.RULE_pattern_synonym_lhs);
	    var _la = 0; // Token type
	    try {
	        this.state = 1278;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,143,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1265;
	            this.con();
	            this.state = 1267;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID) {
	                this.state = 1266;
	                this.vars_();
	            }

	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1269;
	            this.varid();
	            this.state = 1270;
	            this.conop();
	            this.state = 1271;
	            this.varid();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1273;
	            this.con();
	            this.state = 1274;
	            this.match(HaskellParser.OCURLY);
	            this.state = 1275;
	            this.cvars();
	            this.state = 1276;
	            this.match(HaskellParser.CCURLY);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	vars_() {
	    let localctx = new Vars_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 106, HaskellParser.RULE_vars_);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1281; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1280;
	            this.varid();
	            this.state = 1283; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cvars() {
	    let localctx = new CvarsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 108, HaskellParser.RULE_cvars);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1285;
	        this.var_();
	        this.state = 1290;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1286;
	            this.match(HaskellParser.Comma);
	            this.state = 1287;
	            this.var_();
	            this.state = 1292;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	where_decls() {
	    let localctx = new Where_declsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 110, HaskellParser.RULE_where_decls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1293;
	        this.match(HaskellParser.WHERE);
	        this.state = 1294;
	        this.open_();
	        this.state = 1296;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.PATTERN - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.OpenPragmaBracket - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 1295;
	            this.decls();
	        }

	        this.state = 1298;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pattern_synonym_sig() {
	    let localctx = new Pattern_synonym_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 112, HaskellParser.RULE_pattern_synonym_sig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1300;
	        this.match(HaskellParser.PATTERN);
	        this.state = 1301;
	        this.con_list();
	        this.state = 1302;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1303;
	        this.sigtypedoc();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decl_cls() {
	    let localctx = new Decl_clsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 114, HaskellParser.RULE_decl_cls);
	    try {
	        this.state = 1312;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DATA:
	        case HaskellParser.TYPE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1305;
	            this.at_decl_cls();
	            break;
	        case HaskellParser.AS:
	        case HaskellParser.CASE:
	        case HaskellParser.DO:
	        case HaskellParser.HIDING:
	        case HaskellParser.IF:
	        case HaskellParser.INFIX:
	        case HaskellParser.INFIXL:
	        case HaskellParser.INFIXR:
	        case HaskellParser.LET:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.WILDCARD:
	        case HaskellParser.EXPORT:
	        case HaskellParser.MDO:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.PATTERN:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.LCASE:
	        case HaskellParser.Bang:
	        case HaskellParser.Minus:
	        case HaskellParser.Tilde:
	        case HaskellParser.DDollar:
	        case HaskellParser.Dollar:
	        case HaskellParser.Semi:
	        case HaskellParser.Quote:
	        case HaskellParser.DoubleQuote:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.AopenParen:
	        case HaskellParser.TopenTexpQuote:
	        case HaskellParser.TopenExpQuote:
	        case HaskellParser.TopenPatQuote:
	        case HaskellParser.TopenTypQoute:
	        case HaskellParser.TopenDecQoute:
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.OpenSquareBracket:
	        case HaskellParser.CHAR:
	        case HaskellParser.STRING:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	        case HaskellParser.OpenPragmaBracket:
	        case HaskellParser.SEMI:
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	        case HaskellParser.FLOAT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1306;
	            this.decl();
	            break;
	        case HaskellParser.DEFAULT:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1307;
	            this.match(HaskellParser.DEFAULT);
	            this.state = 1308;
	            this.infixexp();
	            this.state = 1309;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1310;
	            this.sigtypedoc();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decls_cls() {
	    let localctx = new Decls_clsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 116, HaskellParser.RULE_decls_cls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1314;
	        this.decl_cls();
	        this.state = 1324;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,149,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1316; 
	                this._errHandler.sync(this);
	                var _alt = 1;
	                do {
	                	switch (_alt) {
	                	case 1:
	                		this.state = 1315;
	                		this.semi();
	                		break;
	                	default:
	                		throw new antlr4.error.NoViableAltException(this);
	                	}
	                	this.state = 1318; 
	                	this._errHandler.sync(this);
	                	_alt = this._interp.adaptivePredict(this._input,148, this._ctx);
	                } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	                this.state = 1320;
	                this.decl_cls(); 
	            }
	            this.state = 1326;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,149,this._ctx);
	        }

	        this.state = 1330;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1327;
	            this.semi();
	            this.state = 1332;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decllist_cls() {
	    let localctx = new Decllist_clsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 118, HaskellParser.RULE_decllist_cls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1333;
	        this.open_();
	        this.state = 1335;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DATA) | (1 << HaskellParser.DEFAULT) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.TYPE) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.PATTERN - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.OpenPragmaBracket - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 1334;
	            this.decls_cls();
	        }

	        this.state = 1337;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	where_cls() {
	    let localctx = new Where_clsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 120, HaskellParser.RULE_where_cls);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1339;
	        this.match(HaskellParser.WHERE);
	        this.state = 1340;
	        this.decllist_cls();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decl_inst() {
	    let localctx = new Decl_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 122, HaskellParser.RULE_decl_inst);
	    try {
	        this.state = 1344;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DATA:
	        case HaskellParser.NEWTYPE:
	        case HaskellParser.TYPE:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1342;
	            this.at_decl_inst();
	            break;
	        case HaskellParser.AS:
	        case HaskellParser.CASE:
	        case HaskellParser.DO:
	        case HaskellParser.HIDING:
	        case HaskellParser.IF:
	        case HaskellParser.INFIX:
	        case HaskellParser.INFIXL:
	        case HaskellParser.INFIXR:
	        case HaskellParser.LET:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.WILDCARD:
	        case HaskellParser.EXPORT:
	        case HaskellParser.MDO:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.PATTERN:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.LCASE:
	        case HaskellParser.Bang:
	        case HaskellParser.Minus:
	        case HaskellParser.Tilde:
	        case HaskellParser.DDollar:
	        case HaskellParser.Dollar:
	        case HaskellParser.Semi:
	        case HaskellParser.Quote:
	        case HaskellParser.DoubleQuote:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.AopenParen:
	        case HaskellParser.TopenTexpQuote:
	        case HaskellParser.TopenExpQuote:
	        case HaskellParser.TopenPatQuote:
	        case HaskellParser.TopenTypQoute:
	        case HaskellParser.TopenDecQoute:
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.OpenSquareBracket:
	        case HaskellParser.CHAR:
	        case HaskellParser.STRING:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	        case HaskellParser.OpenPragmaBracket:
	        case HaskellParser.SEMI:
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	        case HaskellParser.FLOAT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1343;
	            this.decl();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decls_inst() {
	    let localctx = new Decls_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 124, HaskellParser.RULE_decls_inst);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1346;
	        this.decl_inst();
	        this.state = 1356;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,154,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1348; 
	                this._errHandler.sync(this);
	                var _alt = 1;
	                do {
	                	switch (_alt) {
	                	case 1:
	                		this.state = 1347;
	                		this.semi();
	                		break;
	                	default:
	                		throw new antlr4.error.NoViableAltException(this);
	                	}
	                	this.state = 1350; 
	                	this._errHandler.sync(this);
	                	_alt = this._interp.adaptivePredict(this._input,153, this._ctx);
	                } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	                this.state = 1352;
	                this.decl_inst(); 
	            }
	            this.state = 1358;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,154,this._ctx);
	        }

	        this.state = 1362;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1359;
	            this.semi();
	            this.state = 1364;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decllist_inst() {
	    let localctx = new Decllist_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 126, HaskellParser.RULE_decllist_inst);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1365;
	        this.open_();
	        this.state = 1367;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DATA) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR) | (1 << HaskellParser.LET) | (1 << HaskellParser.NEWTYPE) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.TYPE) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.PATTERN - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.OpenPragmaBracket - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 1366;
	            this.decls_inst();
	        }

	        this.state = 1369;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	where_inst() {
	    let localctx = new Where_instContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 128, HaskellParser.RULE_where_inst);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1371;
	        this.match(HaskellParser.WHERE);
	        this.state = 1372;
	        this.decllist_inst();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decls() {
	    let localctx = new DeclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 130, HaskellParser.RULE_decls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1374;
	        this.decl();
	        this.state = 1384;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,158,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1376; 
	                this._errHandler.sync(this);
	                var _alt = 1;
	                do {
	                	switch (_alt) {
	                	case 1:
	                		this.state = 1375;
	                		this.semi();
	                		break;
	                	default:
	                		throw new antlr4.error.NoViableAltException(this);
	                	}
	                	this.state = 1378; 
	                	this._errHandler.sync(this);
	                	_alt = this._interp.adaptivePredict(this._input,157, this._ctx);
	                } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	                this.state = 1380;
	                this.decl(); 
	            }
	            this.state = 1386;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,158,this._ctx);
	        }

	        this.state = 1390;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1387;
	            this.semi();
	            this.state = 1392;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decllist() {
	    let localctx = new DecllistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 132, HaskellParser.RULE_decllist);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1393;
	        this.open_();
	        this.state = 1395;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.PATTERN - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.OpenPragmaBracket - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 1394;
	            this.decls();
	        }

	        this.state = 1397;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	binds() {
	    let localctx = new BindsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 134, HaskellParser.RULE_binds);
	    var _la = 0; // Token type
	    try {
	        this.state = 1406;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,162,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1399;
	            this.decllist();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1400;
	            this.open_();
	            this.state = 1402;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID) {
	                this.state = 1401;
	                this.dbinds();
	            }

	            this.state = 1404;
	            this.close();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	wherebinds() {
	    let localctx = new WherebindsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 136, HaskellParser.RULE_wherebinds);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1408;
	        this.match(HaskellParser.WHERE);
	        this.state = 1409;
	        this.binds();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rules() {
	    let localctx = new RulesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 138, HaskellParser.RULE_rules);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1411;
	        this.pragma_rule();
	        this.state = 1417;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,163,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1412;
	                this.semi();
	                this.state = 1413;
	                this.pragma_rule(); 
	            }
	            this.state = 1419;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,163,this._ctx);
	        }

	        this.state = 1421;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1420;
	            this.semi();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pragma_rule() {
	    let localctx = new Pragma_ruleContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 140, HaskellParser.RULE_pragma_rule);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1423;
	        this.pstring();
	        this.state = 1425;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,165,this._ctx);
	        if(la_===1) {
	            this.state = 1424;
	            this.rule_activation();

	        }
	        this.state = 1428;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.FORALL) {
	            this.state = 1427;
	            this.rule_foralls();
	        }

	        this.state = 1430;
	        this.infixexp();
	        this.state = 1431;
	        this.match(HaskellParser.Eq);
	        this.state = 1432;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rule_activation_marker() {
	    let localctx = new Rule_activation_markerContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 142, HaskellParser.RULE_rule_activation_marker);
	    try {
	        this.state = 1436;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,167,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1434;
	            this.match(HaskellParser.Tilde);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1435;
	            this.varsym();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rule_activation() {
	    let localctx = new Rule_activationContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 144, HaskellParser.RULE_rule_activation);
	    try {
	        this.state = 1451;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,168,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1438;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1439;
	            this.integer();
	            this.state = 1440;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1442;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1443;
	            this.rule_activation_marker();
	            this.state = 1444;
	            this.integer();
	            this.state = 1445;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1447;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1448;
	            this.rule_activation_marker();
	            this.state = 1449;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rule_foralls() {
	    let localctx = new Rule_forallsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 146, HaskellParser.RULE_rule_foralls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1453;
	        this.match(HaskellParser.FORALL);
	        this.state = 1455;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.OpenRoundBracket || _la===HaskellParser.VARID) {
	            this.state = 1454;
	            this.rule_vars();
	        }

	        this.state = 1457;
	        this.match(HaskellParser.Dot);
	        this.state = 1463;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.FORALL) {
	            this.state = 1458;
	            this.match(HaskellParser.FORALL);
	            this.state = 1460;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.OpenRoundBracket || _la===HaskellParser.VARID) {
	                this.state = 1459;
	                this.rule_vars();
	            }

	            this.state = 1462;
	            this.match(HaskellParser.Dot);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rule_vars() {
	    let localctx = new Rule_varsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 148, HaskellParser.RULE_rule_vars);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1466; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1465;
	            this.rule_var();
	            this.state = 1468; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.OpenRoundBracket || _la===HaskellParser.VARID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rule_var() {
	    let localctx = new Rule_varContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 150, HaskellParser.RULE_rule_var);
	    try {
	        this.state = 1477;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.VARID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1470;
	            this.varid();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1471;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1472;
	            this.varid();
	            this.state = 1473;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1474;
	            this.ctype();
	            this.state = 1475;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	warnings() {
	    let localctx = new WarningsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 152, HaskellParser.RULE_warnings);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1479;
	        this.pragma_warning();
	        this.state = 1485;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,174,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1480;
	                this.semi();
	                this.state = 1481;
	                this.pragma_warning(); 
	            }
	            this.state = 1487;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,174,this._ctx);
	        }

	        this.state = 1489;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1488;
	            this.semi();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pragma_warning() {
	    let localctx = new Pragma_warningContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 154, HaskellParser.RULE_pragma_warning);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1491;
	        this.namelist();
	        this.state = 1492;
	        this.strings();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deprecations() {
	    let localctx = new DeprecationsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 156, HaskellParser.RULE_deprecations);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1494;
	        this.pragma_deprecation();
	        this.state = 1500;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,176,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1495;
	                this.semi();
	                this.state = 1496;
	                this.pragma_deprecation(); 
	            }
	            this.state = 1502;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,176,this._ctx);
	        }

	        this.state = 1504;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1503;
	            this.semi();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pragma_deprecation() {
	    let localctx = new Pragma_deprecationContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 158, HaskellParser.RULE_pragma_deprecation);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1506;
	        this.namelist();
	        this.state = 1507;
	        this.strings();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	strings() {
	    let localctx = new StringsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 160, HaskellParser.RULE_strings);
	    var _la = 0; // Token type
	    try {
	        this.state = 1515;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.STRING:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1509;
	            this.pstring();
	            break;
	        case HaskellParser.OpenSquareBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1510;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1512;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.STRING) {
	                this.state = 1511;
	                this.stringlist();
	            }

	            this.state = 1514;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	stringlist() {
	    let localctx = new StringlistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 162, HaskellParser.RULE_stringlist);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1517;
	        this.pstring();
	        this.state = 1522;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1518;
	            this.match(HaskellParser.Comma);
	            this.state = 1519;
	            this.pstring();
	            this.state = 1524;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	annotation() {
	    let localctx = new AnnotationContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 164, HaskellParser.RULE_annotation);
	    try {
	        this.state = 1543;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,181,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1525;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1526;
	            this.match(HaskellParser.ANN);
	            this.state = 1527;
	            this.name_var();
	            this.state = 1528;
	            this.aexp();
	            this.state = 1529;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1531;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1532;
	            this.match(HaskellParser.ANN);
	            this.state = 1533;
	            this.tycon();
	            this.state = 1534;
	            this.aexp();
	            this.state = 1535;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1537;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1538;
	            this.match(HaskellParser.ANN);
	            this.state = 1539;
	            this.match(HaskellParser.MODULE);
	            this.state = 1540;
	            this.aexp();
	            this.state = 1541;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fdecl() {
	    let localctx = new FdeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 166, HaskellParser.RULE_fdecl);
	    var _la = 0; // Token type
	    try {
	        this.state = 1556;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.IMPORT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1545;
	            this.match(HaskellParser.IMPORT);
	            this.state = 1546;
	            this.callconv();
	            this.state = 1548;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (HaskellParser.SAFE - 32)) | (1 << (HaskellParser.INTERRUPTIBLE - 32)) | (1 << (HaskellParser.UNSAFE - 32)))) !== 0)) {
	                this.state = 1547;
	                this.safety();
	            }

	            this.state = 1550;
	            this.fspec();
	            break;
	        case HaskellParser.EXPORT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1552;
	            this.match(HaskellParser.EXPORT);
	            this.state = 1553;
	            this.callconv();
	            this.state = 1554;
	            this.fspec();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	callconv() {
	    let localctx = new CallconvContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 168, HaskellParser.RULE_callconv);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1558;
	        _la = this._input.LA(1);
	        if(!(((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CPPCALL - 38)) | (1 << (HaskellParser.JSCALL - 38)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	safety() {
	    let localctx = new SafetyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 170, HaskellParser.RULE_safety);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1560;
	        _la = this._input.LA(1);
	        if(!(((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (HaskellParser.SAFE - 32)) | (1 << (HaskellParser.INTERRUPTIBLE - 32)) | (1 << (HaskellParser.UNSAFE - 32)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fspec() {
	    let localctx = new FspecContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 172, HaskellParser.RULE_fspec);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1563;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.STRING) {
	            this.state = 1562;
	            this.pstring();
	        }

	        this.state = 1565;
	        this.var_();
	        this.state = 1566;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1567;
	        this.sigtypedoc();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_sig() {
	    let localctx = new Opt_sigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 174, HaskellParser.RULE_opt_sig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1569;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1570;
	        this.sigtype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	opt_tyconsig() {
	    let localctx = new Opt_tyconsigContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 176, HaskellParser.RULE_opt_tyconsig);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1572;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1573;
	        this.gtycon();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sigtype() {
	    let localctx = new SigtypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 178, HaskellParser.RULE_sigtype);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1575;
	        this.ctype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sigtypedoc() {
	    let localctx = new SigtypedocContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 180, HaskellParser.RULE_sigtypedoc);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1577;
	        this.ctypedoc();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sig_vars() {
	    let localctx = new Sig_varsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 182, HaskellParser.RULE_sig_vars);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1579;
	        this.var_();
	        this.state = 1584;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1580;
	            this.match(HaskellParser.Comma);
	            this.state = 1581;
	            this.var_();
	            this.state = 1586;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sigtypes1() {
	    let localctx = new Sigtypes1Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 184, HaskellParser.RULE_sigtypes1);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1587;
	        this.sigtype();
	        this.state = 1592;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1588;
	            this.match(HaskellParser.Comma);
	            this.state = 1589;
	            this.sigtype();
	            this.state = 1594;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	unpackedness() {
	    let localctx = new UnpackednessContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 186, HaskellParser.RULE_unpackedness);
	    try {
	        this.state = 1601;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,187,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1595;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1596;
	            this.match(HaskellParser.UNPACK);
	            this.state = 1597;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1598;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 1599;
	            this.match(HaskellParser.NOUNPACK);
	            this.state = 1600;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	forall_vis_flag() {
	    let localctx = new Forall_vis_flagContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 188, HaskellParser.RULE_forall_vis_flag);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1603;
	        _la = this._input.LA(1);
	        if(!(_la===HaskellParser.Arrow || _la===HaskellParser.Dot)) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ktype() {
	    let localctx = new KtypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 190, HaskellParser.RULE_ktype);
	    try {
	        this.state = 1610;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,188,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1605;
	            this.ctype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1606;
	            this.ctype();
	            this.state = 1607;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1608;
	            this.kind();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ktypedoc() {
	    let localctx = new KtypedocContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 192, HaskellParser.RULE_ktypedoc);
	    try {
	        this.state = 1617;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,189,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1612;
	            this.ctypedoc();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1613;
	            this.ctypedoc();
	            this.state = 1614;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1615;
	            this.kind();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ctype() {
	    let localctx = new CtypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 194, HaskellParser.RULE_ctype);
	    var _la = 0; // Token type
	    try {
	        this.state = 1635;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,191,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1619;
	            this.match(HaskellParser.FORALL);
	            this.state = 1621;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	                this.state = 1620;
	                this.tv_bndrs();
	            }

	            this.state = 1623;
	            this.forall_vis_flag();
	            this.state = 1624;
	            this.ctype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1626;
	            this.btype();
	            this.state = 1627;
	            this.match(HaskellParser.DoubleArrow);
	            this.state = 1628;
	            this.ctype();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1630;
	            this.var_();
	            this.state = 1631;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1632;
	            this.type_();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1634;
	            this.type_();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ctypedoc() {
	    let localctx = new CtypedocContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 196, HaskellParser.RULE_ctypedoc);
	    var _la = 0; // Token type
	    try {
	        this.state = 1653;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,193,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1637;
	            this.match(HaskellParser.FORALL);
	            this.state = 1639;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	                this.state = 1638;
	                this.tv_bndrs();
	            }

	            this.state = 1641;
	            this.forall_vis_flag();
	            this.state = 1642;
	            this.ctypedoc();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1644;
	            this.tycl_context();
	            this.state = 1645;
	            this.match(HaskellParser.DoubleArrow);
	            this.state = 1646;
	            this.ctypedoc();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1648;
	            this.var_();
	            this.state = 1649;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1650;
	            this.type_();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1652;
	            this.typedoc();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tycl_context() {
	    let localctx = new Tycl_contextContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 198, HaskellParser.RULE_tycl_context);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1655;
	        this.btype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr_context() {
	    let localctx = new Constr_contextContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 200, HaskellParser.RULE_constr_context);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1657;
	        this.constr_btype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	type_() {
	    let localctx = new Type_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 202, HaskellParser.RULE_type_);
	    try {
	        this.state = 1664;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,194,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1659;
	            this.btype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1660;
	            this.btype();
	            this.state = 1661;
	            this.match(HaskellParser.Arrow);
	            this.state = 1662;
	            this.ctype();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	typedoc() {
	    let localctx = new TypedocContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 204, HaskellParser.RULE_typedoc);
	    try {
	        this.state = 1671;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,195,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1666;
	            this.btype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1667;
	            this.btype();
	            this.state = 1668;
	            this.match(HaskellParser.Arrow);
	            this.state = 1669;
	            this.ctypedoc();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr_btype() {
	    let localctx = new Constr_btypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 206, HaskellParser.RULE_constr_btype);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1673;
	        this.constr_tyapps();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr_tyapps() {
	    let localctx = new Constr_tyappsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 208, HaskellParser.RULE_constr_tyapps);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1676; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 1675;
	        		this.constr_tyapp();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 1678; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,196, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr_tyapp() {
	    let localctx = new Constr_tyappContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 210, HaskellParser.RULE_constr_tyapp);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1680;
	        this.tyapp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	btype() {
	    let localctx = new BtypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 212, HaskellParser.RULE_btype);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1682;
	        this.tyapps();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyapps() {
	    let localctx = new TyappsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 214, HaskellParser.RULE_tyapps);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1685; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 1684;
	        		this.tyapp();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 1687; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,197, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyapp() {
	    let localctx = new TyappContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 216, HaskellParser.RULE_tyapp);
	    try {
	        this.state = 1699;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,198,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1689;
	            this.atype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1690;
	            this.match(HaskellParser.Atsign);
	            this.state = 1691;
	            this.atype();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1692;
	            this.qtyconop();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1693;
	            this.tyvarop();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 1694;
	            this.match(HaskellParser.Quote);
	            this.state = 1695;
	            this.qconop();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 1696;
	            this.match(HaskellParser.Quote);
	            this.state = 1697;
	            this.varop();
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 1698;
	            this.unpackedness();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	atype() {
	    let localctx = new AtypeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 218, HaskellParser.RULE_atype);
	    var _la = 0; // Token type
	    try {
	        this.state = 1767;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,201,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1701;
	            this.ntgtycon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1702;
	            this.tyvar();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1703;
	            this.match(HaskellParser.Asterisk);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1704;
	            this.match(HaskellParser.Tilde);
	            this.state = 1705;
	            this.atype();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 1706;
	            this.match(HaskellParser.Bang);
	            this.state = 1707;
	            this.atype();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 1708;
	            this.match(HaskellParser.OCURLY);
	            this.state = 1710;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.OpenRoundBracket || _la===HaskellParser.VARID) {
	                this.state = 1709;
	                this.fielddecls();
	            }

	            this.state = 1712;
	            this.match(HaskellParser.CCURLY);
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 1713;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1714;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 1715;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1716;
	            this.ktype();
	            this.state = 1717;
	            this.match(HaskellParser.Comma);
	            this.state = 1718;
	            this.comma_types();
	            this.state = 1719;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 1721;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 1722;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 1723;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 1724;
	            this.comma_types();
	            this.state = 1725;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 1727;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 1728;
	            this.bar_types2();
	            this.state = 1729;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 1731;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1732;
	            this.ktype();
	            this.state = 1733;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 13:
	            this.enterOuterAlt(localctx, 13);
	            this.state = 1735;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1736;
	            this.ktype();
	            this.state = 1737;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 14:
	            this.enterOuterAlt(localctx, 14);
	            this.state = 1739;
	            this.quasiquote();
	            break;

	        case 15:
	            this.enterOuterAlt(localctx, 15);
	            this.state = 1740;
	            this.splice_untyped();
	            break;

	        case 16:
	            this.enterOuterAlt(localctx, 16);
	            this.state = 1741;
	            this.match(HaskellParser.Quote);
	            this.state = 1742;
	            this.qcon_nowiredlist();
	            break;

	        case 17:
	            this.enterOuterAlt(localctx, 17);
	            this.state = 1743;
	            this.match(HaskellParser.Quote);
	            this.state = 1744;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1745;
	            this.ktype();
	            this.state = 1746;
	            this.match(HaskellParser.Comma);
	            this.state = 1747;
	            this.comma_types();
	            this.state = 1748;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 18:
	            this.enterOuterAlt(localctx, 18);
	            this.state = 1750;
	            this.match(HaskellParser.Quote);
	            this.state = 1751;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1753;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.FORALL) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 82)) & ~0x1f) == 0 && ((1 << (_la - 82)) & ((1 << (HaskellParser.Hash - 82)) | (1 << (HaskellParser.Less - 82)) | (1 << (HaskellParser.Greater - 82)) | (1 << (HaskellParser.Ampersand - 82)) | (1 << (HaskellParser.Pipe - 82)) | (1 << (HaskellParser.Bang - 82)) | (1 << (HaskellParser.Caret - 82)) | (1 << (HaskellParser.Plus - 82)) | (1 << (HaskellParser.Minus - 82)) | (1 << (HaskellParser.Asterisk - 82)) | (1 << (HaskellParser.Percent - 82)) | (1 << (HaskellParser.Divide - 82)) | (1 << (HaskellParser.Tilde - 82)) | (1 << (HaskellParser.Atsign - 82)) | (1 << (HaskellParser.Dollar - 82)) | (1 << (HaskellParser.Dot - 82)) | (1 << (HaskellParser.QuestionMark - 82)) | (1 << (HaskellParser.Colon - 82)) | (1 << (HaskellParser.Eq - 82)) | (1 << (HaskellParser.Quote - 82)) | (1 << (HaskellParser.ReverseSlash - 82)) | (1 << (HaskellParser.BackQuote - 82)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.STRING - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)) | (1 << (HaskellParser.OpenPragmaBracket - 118)) | (1 << (HaskellParser.OCURLY - 118)) | (1 << (HaskellParser.DECIMAL - 118)) | (1 << (HaskellParser.OCTAL - 118)) | (1 << (HaskellParser.HEXADECIMAL - 118)))) !== 0)) {
	                this.state = 1752;
	                this.comma_types();
	            }

	            this.state = 1755;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 19:
	            this.enterOuterAlt(localctx, 19);
	            this.state = 1756;
	            this.match(HaskellParser.Quote);
	            this.state = 1757;
	            this.var_();
	            break;

	        case 20:
	            this.enterOuterAlt(localctx, 20);
	            this.state = 1758;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 1759;
	            this.ktype();
	            this.state = 1760;
	            this.match(HaskellParser.Comma);
	            this.state = 1761;
	            this.comma_types();
	            this.state = 1762;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 21:
	            this.enterOuterAlt(localctx, 21);
	            this.state = 1764;
	            this.integer();
	            break;

	        case 22:
	            this.enterOuterAlt(localctx, 22);
	            this.state = 1765;
	            this.pstring();
	            break;

	        case 23:
	            this.enterOuterAlt(localctx, 23);
	            this.state = 1766;
	            this.match(HaskellParser.WILDCARD);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	inst_type() {
	    let localctx = new Inst_typeContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 220, HaskellParser.RULE_inst_type);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1769;
	        this.sigtype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriv_types() {
	    let localctx = new Deriv_typesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 222, HaskellParser.RULE_deriv_types);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1771;
	        this.ktypedoc();
	        this.state = 1776;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1772;
	            this.match(HaskellParser.Comma);
	            this.state = 1773;
	            this.ktypedoc();
	            this.state = 1778;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	comma_types() {
	    let localctx = new Comma_typesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 224, HaskellParser.RULE_comma_types);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1779;
	        this.ktype();
	        this.state = 1784;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1780;
	            this.match(HaskellParser.Comma);
	            this.state = 1781;
	            this.ktype();
	            this.state = 1786;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	bar_types2() {
	    let localctx = new Bar_types2Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 226, HaskellParser.RULE_bar_types2);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1787;
	        this.ktype();
	        this.state = 1788;
	        this.match(HaskellParser.Pipe);
	        this.state = 1789;
	        this.ktype();
	        this.state = 1794;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Pipe) {
	            this.state = 1790;
	            this.match(HaskellParser.Pipe);
	            this.state = 1791;
	            this.ktype();
	            this.state = 1796;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tv_bndrs() {
	    let localctx = new Tv_bndrsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 228, HaskellParser.RULE_tv_bndrs);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1798; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1797;
	            this.tv_bndr();
	            this.state = 1800; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0));
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tv_bndr() {
	    let localctx = new Tv_bndrContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 230, HaskellParser.RULE_tv_bndr);
	    try {
	        this.state = 1813;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,206,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1802;
	            this.tv_bndr_no_braces();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1803;
	            this.match(HaskellParser.OCURLY);
	            this.state = 1804;
	            this.tyvar();
	            this.state = 1805;
	            this.match(HaskellParser.CCURLY);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1807;
	            this.match(HaskellParser.OCURLY);
	            this.state = 1808;
	            this.tyvar();
	            this.state = 1809;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1810;
	            this.kind();
	            this.state = 1811;
	            this.match(HaskellParser.CCURLY);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tv_bndr_no_braces() {
	    let localctx = new Tv_bndr_no_bracesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 232, HaskellParser.RULE_tv_bndr_no_braces);
	    try {
	        this.state = 1822;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.VARID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1815;
	            this.tyvar();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1816;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1817;
	            this.tyvar();
	            this.state = 1818;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1819;
	            this.kind();
	            this.state = 1820;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fds() {
	    let localctx = new FdsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 234, HaskellParser.RULE_fds);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1824;
	        this.match(HaskellParser.Pipe);
	        this.state = 1825;
	        this.fds1();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fds1() {
	    let localctx = new Fds1Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 236, HaskellParser.RULE_fds1);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1827;
	        this.fd();
	        this.state = 1832;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1828;
	            this.match(HaskellParser.Comma);
	            this.state = 1829;
	            this.fd();
	            this.state = 1834;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fd() {
	    let localctx = new FdContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 238, HaskellParser.RULE_fd);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1836;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID) {
	            this.state = 1835;
	            this.varids0();
	        }

	        this.state = 1838;
	        this.match(HaskellParser.Arrow);
	        this.state = 1840;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID) {
	            this.state = 1839;
	            this.varids0();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	varids0() {
	    let localctx = new Varids0Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 240, HaskellParser.RULE_varids0);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1843; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1842;
	            this.tyvar();
	            this.state = 1845; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || _la===HaskellParser.VARID);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	kind() {
	    let localctx = new KindContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 242, HaskellParser.RULE_kind);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1847;
	        this.ctype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gadt_constrlist() {
	    let localctx = new Gadt_constrlistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 244, HaskellParser.RULE_gadt_constrlist);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1849;
	        this.match(HaskellParser.WHERE);
	        this.state = 1850;
	        this.open_();
	        this.state = 1852;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	            this.state = 1851;
	            this.gadt_constrs();
	        }

	        this.state = 1857;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 1854;
	            this.semi();
	            this.state = 1859;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	        this.state = 1860;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gadt_constrs() {
	    let localctx = new Gadt_constrsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 246, HaskellParser.RULE_gadt_constrs);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1862;
	        this.gadt_constr_with_doc();
	        this.state = 1868;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,214,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 1863;
	                this.semi();
	                this.state = 1864;
	                this.gadt_constr_with_doc(); 
	            }
	            this.state = 1870;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,214,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gadt_constr_with_doc() {
	    let localctx = new Gadt_constr_with_docContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 248, HaskellParser.RULE_gadt_constr_with_doc);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1871;
	        this.gadt_constr();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gadt_constr() {
	    let localctx = new Gadt_constrContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 250, HaskellParser.RULE_gadt_constr);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1873;
	        this.con_list();
	        this.state = 1874;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1875;
	        this.sigtypedoc();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constrs() {
	    let localctx = new ConstrsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 252, HaskellParser.RULE_constrs);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1877;
	        this.match(HaskellParser.Eq);
	        this.state = 1878;
	        this.constrs1();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constrs1() {
	    let localctx = new Constrs1Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 254, HaskellParser.RULE_constrs1);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1880;
	        this.constr();
	        this.state = 1885;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Pipe) {
	            this.state = 1881;
	            this.match(HaskellParser.Pipe);
	            this.state = 1882;
	            this.constr();
	            this.state = 1887;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr() {
	    let localctx = new ConstrContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 256, HaskellParser.RULE_constr);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1889;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.FORALL) {
	            this.state = 1888;
	            this.forall();
	        }

	        this.state = 1894;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,217,this._ctx);
	        if(la_===1) {
	            this.state = 1891;
	            this.constr_context();
	            this.state = 1892;
	            this.match(HaskellParser.DoubleArrow);

	        }
	        this.state = 1896;
	        this.constr_stuff();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	forall() {
	    let localctx = new ForallContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 258, HaskellParser.RULE_forall);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1898;
	        this.match(HaskellParser.FORALL);
	        this.state = 1900;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 120)) & ~0x1f) == 0 && ((1 << (_la - 120)) & ((1 << (HaskellParser.OpenRoundBracket - 120)) | (1 << (HaskellParser.VARID - 120)) | (1 << (HaskellParser.OCURLY - 120)))) !== 0)) {
	            this.state = 1899;
	            this.tv_bndrs();
	        }

	        this.state = 1902;
	        this.match(HaskellParser.Dot);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	constr_stuff() {
	    let localctx = new Constr_stuffContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 260, HaskellParser.RULE_constr_stuff);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1904;
	        this.constr_tyapps();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fielddecls() {
	    let localctx = new FielddeclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 262, HaskellParser.RULE_fielddecls);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1906;
	        this.fielddecl();
	        this.state = 1911;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 1907;
	            this.match(HaskellParser.Comma);
	            this.state = 1908;
	            this.fielddecl();
	            this.state = 1913;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fielddecl() {
	    let localctx = new FielddeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 264, HaskellParser.RULE_fielddecl);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1914;
	        this.sig_vars();
	        this.state = 1915;
	        this.match(HaskellParser.DoubleColon);
	        this.state = 1916;
	        this.ctype();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	derivings() {
	    let localctx = new DerivingsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 266, HaskellParser.RULE_derivings);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1919; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1918;
	            this.deriving();
	            this.state = 1921; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while(_la===HaskellParser.DERIVING);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriving() {
	    let localctx = new DerivingContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 268, HaskellParser.RULE_deriving);
	    try {
	        this.state = 1933;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,221,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1923;
	            this.match(HaskellParser.DERIVING);
	            this.state = 1924;
	            this.deriv_clause_types();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1925;
	            this.match(HaskellParser.DERIVING);
	            this.state = 1926;
	            this.deriv_strategy_no_via();
	            this.state = 1927;
	            this.deriv_clause_types();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1929;
	            this.match(HaskellParser.DERIVING);
	            this.state = 1930;
	            this.deriv_clause_types();
	            this.state = 1931;
	            this.deriv_strategy_via();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	deriv_clause_types() {
	    let localctx = new Deriv_clause_typesContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 270, HaskellParser.RULE_deriv_clause_types);
	    try {
	        this.state = 1942;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,222,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1935;
	            this.qtycon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1936;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1937;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1938;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 1939;
	            this.deriv_types();
	            this.state = 1940;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decl_no_th() {
	    let localctx = new Decl_no_thContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 272, HaskellParser.RULE_decl_no_th);
	    var _la = 0; // Token type
	    try {
	        this.state = 1957;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,225,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1944;
	            this.sigdecl();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1945;
	            this.infixexp();
	            this.state = 1947;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 1946;
	                this.opt_sig();
	            }

	            this.state = 1949;
	            this.rhs();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1951;
	            this.pattern_synonym_decl();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 1953; 
	            this._errHandler.sync(this);
	            var _alt = 1;
	            do {
	            	switch (_alt) {
	            	case 1:
	            		this.state = 1952;
	            		this.semi();
	            		break;
	            	default:
	            		throw new antlr4.error.NoViableAltException(this);
	            	}
	            	this.state = 1955; 
	            	this._errHandler.sync(this);
	            	_alt = this._interp.adaptivePredict(this._input,224, this._ctx);
	            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	decl() {
	    let localctx = new DeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 274, HaskellParser.RULE_decl);
	    try {
	        this.state = 1966;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,227,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1959;
	            this.decl_no_th();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1960;
	            this.splice_exp();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1962; 
	            this._errHandler.sync(this);
	            var _alt = 1;
	            do {
	            	switch (_alt) {
	            	case 1:
	            		this.state = 1961;
	            		this.semi();
	            		break;
	            	default:
	            		throw new antlr4.error.NoViableAltException(this);
	            	}
	            	this.state = 1964; 
	            	this._errHandler.sync(this);
	            	_alt = this._interp.adaptivePredict(this._input,226, this._ctx);
	            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	rhs() {
	    let localctx = new RhsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 276, HaskellParser.RULE_rhs);
	    var _la = 0; // Token type
	    try {
	        this.state = 1977;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Eq:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1968;
	            this.match(HaskellParser.Eq);
	            this.state = 1969;
	            this.exp();
	            this.state = 1971;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 1970;
	                this.wherebinds();
	            }

	            break;
	        case HaskellParser.Pipe:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1973;
	            this.gdrhs();
	            this.state = 1975;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.WHERE) {
	                this.state = 1974;
	                this.wherebinds();
	            }

	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gdrhs() {
	    let localctx = new GdrhsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 278, HaskellParser.RULE_gdrhs);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1980; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 1979;
	            this.gdrh();
	            this.state = 1982; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while(_la===HaskellParser.Pipe);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gdrh() {
	    let localctx = new GdrhContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 280, HaskellParser.RULE_gdrh);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 1984;
	        this.match(HaskellParser.Pipe);
	        this.state = 1985;
	        this.guards();
	        this.state = 1986;
	        this.match(HaskellParser.Eq);
	        this.state = 1987;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sigdecl() {
	    let localctx = new SigdeclContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 282, HaskellParser.RULE_sigdecl);
	    var _la = 0; // Token type
	    try {
	        this.state = 2068;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,240,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 1989;
	            this.infixexp();
	            this.state = 1990;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1991;
	            this.sigtypedoc();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 1993;
	            this.var_();
	            this.state = 1994;
	            this.match(HaskellParser.Comma);
	            this.state = 1995;
	            this.sig_vars();
	            this.state = 1996;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 1997;
	            this.sigtypedoc();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 1999;
	            this.fixity();
	            this.state = 2001;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)))) !== 0)) {
	                this.state = 2000;
	                this.integer();
	            }

	            this.state = 2003;
	            this.ops();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2005;
	            this.pattern_synonym_sig();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2006;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2007;
	            this.match(HaskellParser.COMPLETE);
	            this.state = 2008;
	            this.con_list();
	            this.state = 2010;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.DoubleColon) {
	                this.state = 2009;
	                this.opt_tyconsig();
	            }

	            this.state = 2012;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 2014;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2015;
	            this.match(HaskellParser.INLINE);
	            this.state = 2017;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.OpenSquareBracket) {
	                this.state = 2016;
	                this.activation();
	            }

	            this.state = 2019;
	            this.qvar();
	            this.state = 2020;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 2022;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2023;
	            this.match(HaskellParser.SCC);
	            this.state = 2024;
	            this.qvar();
	            this.state = 2026;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.STRING) {
	                this.state = 2025;
	                this.pstring();
	            }

	            this.state = 2028;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 2030;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2031;
	            this.match(HaskellParser.SPECIALISE);
	            this.state = 2033;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.OpenSquareBracket) {
	                this.state = 2032;
	                this.activation();
	            }

	            this.state = 2035;
	            this.qvar();
	            this.state = 2036;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 2037;
	            this.sigtypes1();
	            this.state = 2038;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 2040;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2041;
	            this.match(HaskellParser.SPECINLINE);
	            this.state = 2043;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.OpenSquareBracket) {
	                this.state = 2042;
	                this.activation();
	            }

	            this.state = 2045;
	            this.qvar();
	            this.state = 2046;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 2047;
	            this.sigtypes1();
	            this.state = 2048;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 2050;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2051;
	            this.match(HaskellParser.SPECIALISE);
	            this.state = 2052;
	            this.match(HaskellParser.INSTANCE);
	            this.state = 2053;
	            this.inst_type();
	            this.state = 2054;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 2056;
	            this.match(HaskellParser.OpenPragmaBracket);
	            this.state = 2057;
	            this.match(HaskellParser.MINIMAL);
	            this.state = 2058;
	            this.match(HaskellParser.ClosePragmaBracket);
	            this.state = 2060;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 118)) & ~0x1f) == 0 && ((1 << (_la - 118)) & ((1 << (HaskellParser.OpenBoxParen - 118)) | (1 << (HaskellParser.OpenRoundBracket - 118)) | (1 << (HaskellParser.OpenSquareBracket - 118)) | (1 << (HaskellParser.VARID - 118)) | (1 << (HaskellParser.CONID - 118)))) !== 0)) {
	                this.state = 2059;
	                this.name_boolformula_opt();
	            }

	            this.state = 2062;
	            this.match(HaskellParser.ClosePragmaBracket);
	            break;

	        case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 2064; 
	            this._errHandler.sync(this);
	            var _alt = 1;
	            do {
	            	switch (_alt) {
	            	case 1:
	            		this.state = 2063;
	            		this.semi();
	            		break;
	            	default:
	            		throw new antlr4.error.NoViableAltException(this);
	            	}
	            	this.state = 2066; 
	            	this._errHandler.sync(this);
	            	_alt = this._interp.adaptivePredict(this._input,239, this._ctx);
	            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	activation() {
	    let localctx = new ActivationContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 284, HaskellParser.RULE_activation);
	    try {
	        this.state = 2079;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,241,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2070;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 2071;
	            this.integer();
	            this.state = 2072;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2074;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 2075;
	            this.rule_activation_marker();
	            this.state = 2076;
	            this.integer();
	            this.state = 2077;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	th_quasiquote() {
	    let localctx = new Th_quasiquoteContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 286, HaskellParser.RULE_th_quasiquote);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2081;
	        this.match(HaskellParser.OpenSquareBracket);
	        this.state = 2082;
	        this.varid();
	        this.state = 2083;
	        this.match(HaskellParser.Pipe);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	th_qquasiquote() {
	    let localctx = new Th_qquasiquoteContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 288, HaskellParser.RULE_th_qquasiquote);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2085;
	        this.match(HaskellParser.OpenSquareBracket);
	        this.state = 2086;
	        this.qvarid();
	        this.state = 2087;
	        this.match(HaskellParser.Pipe);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	quasiquote() {
	    let localctx = new QuasiquoteContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 290, HaskellParser.RULE_quasiquote);
	    try {
	        this.state = 2091;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,242,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2089;
	            this.th_quasiquote();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2090;
	            this.th_qquasiquote();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	exp() {
	    let localctx = new ExpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 292, HaskellParser.RULE_exp);
	    try {
	        this.state = 2114;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,243,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2093;
	            this.infixexp();
	            this.state = 2094;
	            this.match(HaskellParser.DoubleColon);
	            this.state = 2095;
	            this.sigtype();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2097;
	            this.infixexp();
	            this.state = 2098;
	            this.match(HaskellParser.LarrowTail);
	            this.state = 2099;
	            this.exp();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2101;
	            this.infixexp();
	            this.state = 2102;
	            this.match(HaskellParser.RarrowTail);
	            this.state = 2103;
	            this.exp();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2105;
	            this.infixexp();
	            this.state = 2106;
	            this.match(HaskellParser.LLarrowTail);
	            this.state = 2107;
	            this.exp();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2109;
	            this.infixexp();
	            this.state = 2110;
	            this.match(HaskellParser.RRarrowTail);
	            this.state = 2111;
	            this.exp();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 2113;
	            this.infixexp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	infixexp() {
	    let localctx = new InfixexpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 294, HaskellParser.RULE_infixexp);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2116;
	        this.exp10();
	        this.state = 2122;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,244,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2117;
	                this.qop();
	                this.state = 2118;
	                this.exp10p(); 
	            }
	            this.state = 2124;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,244,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	exp10p() {
	    let localctx = new Exp10pContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 296, HaskellParser.RULE_exp10p);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2125;
	        this.exp10();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	exp10() {
	    let localctx = new Exp10Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 298, HaskellParser.RULE_exp10);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2128;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.Minus) {
	            this.state = 2127;
	            this.match(HaskellParser.Minus);
	        }

	        this.state = 2130;
	        this.fexp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fexp() {
	    let localctx = new FexpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 300, HaskellParser.RULE_fexp);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2133; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 2132;
	        		this.aexp();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 2135; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,246, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	        this.state = 2139;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,247,this._ctx);
	        if(la_===1) {
	            this.state = 2137;
	            this.match(HaskellParser.Atsign);
	            this.state = 2138;
	            this.atype();

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	aexp() {
	    let localctx = new AexpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 302, HaskellParser.RULE_aexp);
	    var _la = 0; // Token type
	    try {
	        this.state = 2186;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,250,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2141;
	            this.qvar();
	            this.state = 2142;
	            this.match(HaskellParser.Atsign);
	            this.state = 2143;
	            this.aexp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2145;
	            this.match(HaskellParser.Tilde);
	            this.state = 2146;
	            this.aexp();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2147;
	            this.match(HaskellParser.Bang);
	            this.state = 2148;
	            this.aexp();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2149;
	            this.match(HaskellParser.ReverseSlash);
	            this.state = 2150;
	            this.apats();
	            this.state = 2151;
	            this.match(HaskellParser.Arrow);
	            this.state = 2152;
	            this.exp();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2154;
	            this.match(HaskellParser.LET);
	            this.state = 2155;
	            this.decllist();
	            this.state = 2156;
	            this.match(HaskellParser.IN);
	            this.state = 2157;
	            this.exp();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 2159;
	            this.match(HaskellParser.LCASE);
	            this.state = 2160;
	            this.alts();
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 2161;
	            this.match(HaskellParser.IF);
	            this.state = 2162;
	            this.exp();
	            this.state = 2164;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	                this.state = 2163;
	                this.semi();
	            }

	            this.state = 2166;
	            this.match(HaskellParser.THEN);
	            this.state = 2167;
	            this.exp();
	            this.state = 2169;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	                this.state = 2168;
	                this.semi();
	            }

	            this.state = 2171;
	            this.match(HaskellParser.ELSE);
	            this.state = 2172;
	            this.exp();
	            break;

	        case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 2174;
	            this.match(HaskellParser.IF);
	            this.state = 2175;
	            this.ifgdpats();
	            break;

	        case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 2176;
	            this.match(HaskellParser.CASE);
	            this.state = 2177;
	            this.exp();
	            this.state = 2178;
	            this.match(HaskellParser.OF);
	            this.state = 2179;
	            this.alts();
	            break;

	        case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 2181;
	            this.match(HaskellParser.DO);
	            this.state = 2182;
	            this.stmtlist();
	            break;

	        case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 2183;
	            this.match(HaskellParser.MDO);
	            this.state = 2184;
	            this.stmtlist();
	            break;

	        case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 2185;
	            this.aexp1();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	aexp1() {
	    let localctx = new Aexp1Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 304, HaskellParser.RULE_aexp1);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2188;
	        this.aexp2();
	        this.state = 2196;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,252,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2189;
	                this.match(HaskellParser.OCURLY);
	                this.state = 2191;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0) || ((((_la - 98)) & ~0x1f) == 0 && ((1 << (_la - 98)) & ((1 << (HaskellParser.DoubleDot - 98)) | (1 << (HaskellParser.OpenRoundBracket - 98)) | (1 << (HaskellParser.VARID - 98)) | (1 << (HaskellParser.CONID - 98)))) !== 0)) {
	                    this.state = 2190;
	                    this.fbinds();
	                }

	                this.state = 2193;
	                this.match(HaskellParser.CCURLY); 
	            }
	            this.state = 2198;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,252,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	aexp2() {
	    let localctx = new Aexp2Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 306, HaskellParser.RULE_aexp2);
	    try {
	        this.state = 2266;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,254,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2199;
	            this.qvar();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2200;
	            this.qcon();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2201;
	            this.varid();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2202;
	            this.literal();
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2203;
	            this.pstring();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 2204;
	            this.integer();
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 2205;
	            this.pfloat();
	            break;

	        case 8:
	            this.enterOuterAlt(localctx, 8);
	            this.state = 2206;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2207;
	            this.texp();
	            this.state = 2208;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 9:
	            this.enterOuterAlt(localctx, 9);
	            this.state = 2210;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2211;
	            this.tup_exprs();
	            this.state = 2212;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 10:
	            this.enterOuterAlt(localctx, 10);
	            this.state = 2214;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2215;
	            this.texp();
	            this.state = 2216;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 11:
	            this.enterOuterAlt(localctx, 11);
	            this.state = 2218;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2219;
	            this.tup_exprs();
	            this.state = 2220;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 12:
	            this.enterOuterAlt(localctx, 12);
	            this.state = 2222;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 2223;
	            this.list_();
	            this.state = 2224;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        case 13:
	            this.enterOuterAlt(localctx, 13);
	            this.state = 2226;
	            this.match(HaskellParser.WILDCARD);
	            break;

	        case 14:
	            this.enterOuterAlt(localctx, 14);
	            this.state = 2227;
	            this.splice_untyped();
	            break;

	        case 15:
	            this.enterOuterAlt(localctx, 15);
	            this.state = 2228;
	            this.splice_typed();
	            break;

	        case 16:
	            this.enterOuterAlt(localctx, 16);
	            this.state = 2229;
	            this.match(HaskellParser.Quote);
	            this.state = 2230;
	            this.qvar();
	            break;

	        case 17:
	            this.enterOuterAlt(localctx, 17);
	            this.state = 2231;
	            this.match(HaskellParser.Quote);
	            this.state = 2232;
	            this.qcon();
	            break;

	        case 18:
	            this.enterOuterAlt(localctx, 18);
	            this.state = 2233;
	            this.match(HaskellParser.DoubleQuote);
	            this.state = 2234;
	            this.tyvar();
	            break;

	        case 19:
	            this.enterOuterAlt(localctx, 19);
	            this.state = 2235;
	            this.match(HaskellParser.DoubleQuote);
	            this.state = 2236;
	            this.gtycon();
	            break;

	        case 20:
	            this.enterOuterAlt(localctx, 20);
	            this.state = 2237;
	            this.match(HaskellParser.DoubleQuote);
	            break;

	        case 21:
	            this.enterOuterAlt(localctx, 21);
	            this.state = 2238;
	            this.match(HaskellParser.TopenExpQuote);
	            this.state = 2239;
	            this.exp();
	            this.state = 2240;
	            this.match(HaskellParser.TcloseQoute);
	            break;

	        case 22:
	            this.enterOuterAlt(localctx, 22);
	            this.state = 2242;
	            this.match(HaskellParser.TopenTexpQuote);
	            this.state = 2243;
	            this.exp();
	            this.state = 2244;
	            this.match(HaskellParser.TcloseTExpQoute);
	            break;

	        case 23:
	            this.enterOuterAlt(localctx, 23);
	            this.state = 2246;
	            this.match(HaskellParser.TopenTypQoute);
	            this.state = 2247;
	            this.ktype();
	            this.state = 2248;
	            this.match(HaskellParser.TcloseQoute);
	            break;

	        case 24:
	            this.enterOuterAlt(localctx, 24);
	            this.state = 2250;
	            this.match(HaskellParser.TopenPatQuote);
	            this.state = 2251;
	            this.infixexp();
	            this.state = 2252;
	            this.match(HaskellParser.TcloseQoute);
	            break;

	        case 25:
	            this.enterOuterAlt(localctx, 25);
	            this.state = 2254;
	            this.match(HaskellParser.TopenDecQoute);
	            this.state = 2255;
	            this.cvtopbody();
	            this.state = 2256;
	            this.match(HaskellParser.TcloseQoute);
	            break;

	        case 26:
	            this.enterOuterAlt(localctx, 26);
	            this.state = 2258;
	            this.quasiquote();
	            break;

	        case 27:
	            this.enterOuterAlt(localctx, 27);
	            this.state = 2259;
	            this.match(HaskellParser.AopenParen);
	            this.state = 2260;
	            this.aexp();
	            this.state = 2262;
	            this._errHandler.sync(this);
	            var la_ = this._interp.adaptivePredict(this._input,253,this._ctx);
	            if(la_===1) {
	                this.state = 2261;
	                this.cmdargs();

	            }
	            this.state = 2264;
	            this.match(HaskellParser.AopenParen);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	splice_exp() {
	    let localctx = new Splice_expContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 308, HaskellParser.RULE_splice_exp);
	    try {
	        this.state = 2270;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DDollar:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2268;
	            this.splice_typed();
	            break;
	        case HaskellParser.Dollar:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2269;
	            this.splice_untyped();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	splice_untyped() {
	    let localctx = new Splice_untypedContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 310, HaskellParser.RULE_splice_untyped);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2272;
	        this.match(HaskellParser.Dollar);
	        this.state = 2273;
	        this.aexp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	splice_typed() {
	    let localctx = new Splice_typedContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 312, HaskellParser.RULE_splice_typed);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2275;
	        this.match(HaskellParser.DDollar);
	        this.state = 2276;
	        this.aexp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cmdargs() {
	    let localctx = new CmdargsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 314, HaskellParser.RULE_cmdargs);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2279; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 2278;
	        		this.acmd();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 2281; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,256, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	acmd() {
	    let localctx = new AcmdContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 316, HaskellParser.RULE_acmd);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2283;
	        this.aexp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cvtopbody() {
	    let localctx = new CvtopbodyContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 318, HaskellParser.RULE_cvtopbody);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2285;
	        this.open_();
	        this.state = 2287;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.NEWLINE) | (1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.CLASS) | (1 << HaskellParser.DATA) | (1 << HaskellParser.DEFAULT) | (1 << HaskellParser.DERIVING) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.INFIX) | (1 << HaskellParser.INFIXL) | (1 << HaskellParser.INFIXR) | (1 << HaskellParser.INSTANCE) | (1 << HaskellParser.LET) | (1 << HaskellParser.NEWTYPE) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.TYPE) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.FOREIGN) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.PATTERN - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.OpenPragmaBracket - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 2286;
	            this.cvtopdecls0();
	        }

	        this.state = 2289;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	cvtopdecls0() {
	    let localctx = new Cvtopdecls0Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 320, HaskellParser.RULE_cvtopdecls0);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2291;
	        this.topdecls();
	        this.state = 2295;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 2292;
	            this.semi();
	            this.state = 2297;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	texp() {
	    let localctx = new TexpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 322, HaskellParser.RULE_texp);
	    try {
	        this.state = 2309;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,259,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2298;
	            this.exp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2299;
	            this.infixexp();
	            this.state = 2300;
	            this.qop();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2302;
	            this.qopm();
	            this.state = 2303;
	            this.infixexp();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2305;
	            this.exp();
	            this.state = 2306;
	            this.match(HaskellParser.Arrow);
	            this.state = 2307;
	            this.texp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tup_exprs() {
	    let localctx = new Tup_exprsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 324, HaskellParser.RULE_tup_exprs);
	    var _la = 0; // Token type
	    try {
	        this.state = 2326;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,262,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2311;
	            this.texp();
	            this.state = 2312;
	            this.commas_tup_tail();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2314;
	            this.texp();
	            this.state = 2315;
	            this.bars();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2317;
	            this.commas();
	            this.state = 2319;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Hash - 73)) | (1 << (HaskellParser.Less - 73)) | (1 << (HaskellParser.Greater - 73)) | (1 << (HaskellParser.Ampersand - 73)) | (1 << (HaskellParser.Pipe - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Caret - 73)) | (1 << (HaskellParser.Plus - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Asterisk - 73)) | (1 << (HaskellParser.Percent - 73)) | (1 << (HaskellParser.Divide - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.Atsign - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Dot - 73)) | (1 << (HaskellParser.QuestionMark - 73)) | (1 << (HaskellParser.Colon - 73)) | (1 << (HaskellParser.Eq - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.BackQuote - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	                this.state = 2318;
	                this.tup_tail();
	            }

	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2321;
	            this.bars();
	            this.state = 2322;
	            this.texp();
	            this.state = 2324;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            if(_la===HaskellParser.Pipe) {
	                this.state = 2323;
	                this.bars();
	            }

	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	commas_tup_tail() {
	    let localctx = new Commas_tup_tailContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 326, HaskellParser.RULE_commas_tup_tail);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2328;
	        this.commas();
	        this.state = 2330;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Hash - 73)) | (1 << (HaskellParser.Less - 73)) | (1 << (HaskellParser.Greater - 73)) | (1 << (HaskellParser.Ampersand - 73)) | (1 << (HaskellParser.Pipe - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Caret - 73)) | (1 << (HaskellParser.Plus - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Asterisk - 73)) | (1 << (HaskellParser.Percent - 73)) | (1 << (HaskellParser.Divide - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.Atsign - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Dot - 73)) | (1 << (HaskellParser.QuestionMark - 73)) | (1 << (HaskellParser.Colon - 73)) | (1 << (HaskellParser.Eq - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.BackQuote - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 2329;
	            this.tup_tail();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tup_tail() {
	    let localctx = new Tup_tailContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 328, HaskellParser.RULE_tup_tail);
	    try {
	        this.state = 2336;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,264,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2332;
	            this.texp();
	            this.state = 2333;
	            this.commas_tup_tail();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2335;
	            this.texp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	list_() {
	    let localctx = new List_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 330, HaskellParser.RULE_list_);
	    try {
	        this.state = 2362;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,265,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2338;
	            this.texp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2339;
	            this.lexps();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2340;
	            this.texp();
	            this.state = 2341;
	            this.match(HaskellParser.DoubleDot);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2343;
	            this.texp();
	            this.state = 2344;
	            this.match(HaskellParser.Comma);
	            this.state = 2345;
	            this.exp();
	            this.state = 2346;
	            this.match(HaskellParser.DoubleDot);
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2348;
	            this.texp();
	            this.state = 2349;
	            this.match(HaskellParser.DoubleDot);
	            this.state = 2350;
	            this.exp();
	            break;

	        case 6:
	            this.enterOuterAlt(localctx, 6);
	            this.state = 2352;
	            this.texp();
	            this.state = 2353;
	            this.match(HaskellParser.Comma);
	            this.state = 2354;
	            this.exp();
	            this.state = 2355;
	            this.match(HaskellParser.DoubleDot);
	            this.state = 2356;
	            this.exp();
	            break;

	        case 7:
	            this.enterOuterAlt(localctx, 7);
	            this.state = 2358;
	            this.texp();
	            this.state = 2359;
	            this.match(HaskellParser.Pipe);
	            this.state = 2360;
	            this.flattenedpquals();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	lexps() {
	    let localctx = new LexpsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 332, HaskellParser.RULE_lexps);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2364;
	        this.texp();
	        this.state = 2365;
	        this.match(HaskellParser.Comma);
	        this.state = 2366;
	        this.texp();
	        this.state = 2371;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 2367;
	            this.match(HaskellParser.Comma);
	            this.state = 2368;
	            this.texp();
	            this.state = 2373;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	flattenedpquals() {
	    let localctx = new FlattenedpqualsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 334, HaskellParser.RULE_flattenedpquals);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2374;
	        this.pquals();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pquals() {
	    let localctx = new PqualsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 336, HaskellParser.RULE_pquals);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2376;
	        this.squals();
	        this.state = 2381;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Pipe) {
	            this.state = 2377;
	            this.match(HaskellParser.Pipe);
	            this.state = 2378;
	            this.squals();
	            this.state = 2383;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	squals() {
	    let localctx = new SqualsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 338, HaskellParser.RULE_squals);
	    var _la = 0; // Token type
	    try {
	        this.state = 2416;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,272,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2384;
	            this.transformqual();
	            this.state = 2389;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            while(_la===HaskellParser.Comma) {
	                this.state = 2385;
	                this.match(HaskellParser.Comma);
	                this.state = 2386;
	                this.transformqual();
	                this.state = 2391;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            }
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2392;
	            this.transformqual();
	            this.state = 2397;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            while(_la===HaskellParser.Comma) {
	                this.state = 2393;
	                this.match(HaskellParser.Comma);
	                this.state = 2394;
	                this.qual();
	                this.state = 2399;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            }
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2400;
	            this.qual();
	            this.state = 2405;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            while(_la===HaskellParser.Comma) {
	                this.state = 2401;
	                this.match(HaskellParser.Comma);
	                this.state = 2402;
	                this.transformqual();
	                this.state = 2407;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            }
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2408;
	            this.qual();
	            this.state = 2413;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            while(_la===HaskellParser.Comma) {
	                this.state = 2409;
	                this.match(HaskellParser.Comma);
	                this.state = 2410;
	                this.qual();
	                this.state = 2415;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            }
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	transformqual() {
	    let localctx = new TransformqualContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 340, HaskellParser.RULE_transformqual);
	    try {
	        this.state = 2436;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,273,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2418;
	            this.match(HaskellParser.THEN);
	            this.state = 2419;
	            this.exp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2420;
	            this.match(HaskellParser.THEN);
	            this.state = 2421;
	            this.exp();
	            this.state = 2422;
	            this.match(HaskellParser.BY);
	            this.state = 2423;
	            this.exp();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2425;
	            this.match(HaskellParser.THEN);
	            this.state = 2426;
	            this.match(HaskellParser.GROUP);
	            this.state = 2427;
	            this.match(HaskellParser.USING);
	            this.state = 2428;
	            this.exp();
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2429;
	            this.match(HaskellParser.THEN);
	            this.state = 2430;
	            this.match(HaskellParser.GROUP);
	            this.state = 2431;
	            this.match(HaskellParser.BY);
	            this.state = 2432;
	            this.exp();
	            this.state = 2433;
	            this.match(HaskellParser.USING);
	            this.state = 2434;
	            this.exp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	guards() {
	    let localctx = new GuardsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 342, HaskellParser.RULE_guards);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2438;
	        this.guard_();
	        this.state = 2443;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 2439;
	            this.match(HaskellParser.Comma);
	            this.state = 2440;
	            this.guard_();
	            this.state = 2445;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	guard_() {
	    let localctx = new Guard_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 344, HaskellParser.RULE_guard_);
	    try {
	        this.state = 2453;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,275,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2446;
	            this.pat();
	            this.state = 2447;
	            this.match(HaskellParser.Revarrow);
	            this.state = 2448;
	            this.infixexp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2450;
	            this.match(HaskellParser.LET);
	            this.state = 2451;
	            this.decllist();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2452;
	            this.infixexp();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	alts() {
	    let localctx = new AltsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 346, HaskellParser.RULE_alts);
	    var _la = 0; // Token type
	    try {
	        this.state = 2472;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,278,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2455;
	            this.open_();
	            this.state = 2463; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            do {
	                this.state = 2456;
	                this.alt();
	                this.state = 2460;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	                while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	                    this.state = 2457;
	                    this.semi();
	                    this.state = 2462;
	                    this._errHandler.sync(this);
	                    _la = this._input.LA(1);
	                }
	                this.state = 2465; 
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0));
	            this.state = 2467;
	            this.close();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2469;
	            this.open_();
	            this.state = 2470;
	            this.close();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	alt() {
	    let localctx = new AltContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 348, HaskellParser.RULE_alt);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2474;
	        this.pat();
	        this.state = 2475;
	        this.alt_rhs();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	alt_rhs() {
	    let localctx = new Alt_rhsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 350, HaskellParser.RULE_alt_rhs);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2477;
	        this.ralt();
	        this.state = 2479;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.WHERE) {
	            this.state = 2478;
	            this.wherebinds();
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ralt() {
	    let localctx = new RaltContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 352, HaskellParser.RULE_ralt);
	    try {
	        this.state = 2484;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Arrow:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2481;
	            this.match(HaskellParser.Arrow);
	            this.state = 2482;
	            this.exp();
	            break;
	        case HaskellParser.Pipe:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2483;
	            this.gdpats();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gdpats() {
	    let localctx = new GdpatsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 354, HaskellParser.RULE_gdpats);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2487; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 2486;
	        		this.gdpat();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 2489; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,281, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ifgdpats() {
	    let localctx = new IfgdpatsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 356, HaskellParser.RULE_ifgdpats);
	    try {
	        this.state = 2496;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.OCURLY:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2491;
	            this.match(HaskellParser.OCURLY);
	            this.state = 2492;
	            this.gdpats();
	            this.state = 2493;
	            this.match(HaskellParser.CCURLY);
	            break;
	        case HaskellParser.Pipe:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2495;
	            this.gdpats();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gdpat() {
	    let localctx = new GdpatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 358, HaskellParser.RULE_gdpat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2498;
	        this.match(HaskellParser.Pipe);
	        this.state = 2499;
	        this.guards();
	        this.state = 2500;
	        this.match(HaskellParser.Arrow);
	        this.state = 2501;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pat() {
	    let localctx = new PatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 360, HaskellParser.RULE_pat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2503;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	bindpat() {
	    let localctx = new BindpatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 362, HaskellParser.RULE_bindpat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2505;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	apat() {
	    let localctx = new ApatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 364, HaskellParser.RULE_apat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2507;
	        this.aexp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	apats() {
	    let localctx = new ApatsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 366, HaskellParser.RULE_apats);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2510; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 2509;
	            this.apat();
	            this.state = 2512; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0));
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fpat() {
	    let localctx = new FpatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 368, HaskellParser.RULE_fpat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2514;
	        this.qvar();
	        this.state = 2515;
	        this.match(HaskellParser.Eq);
	        this.state = 2516;
	        this.pat();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	stmtlist() {
	    let localctx = new StmtlistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 370, HaskellParser.RULE_stmtlist);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2518;
	        this.open_();
	        this.state = 2520;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.CASE) | (1 << HaskellParser.DO) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.IF) | (1 << HaskellParser.LET) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.WILDCARD) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (HaskellParser.MDO - 35)) | (1 << (HaskellParser.STDCALL - 35)) | (1 << (HaskellParser.CCALL - 35)) | (1 << (HaskellParser.CAPI - 35)) | (1 << (HaskellParser.JSCALL - 35)) | (1 << (HaskellParser.REC - 35)) | (1 << (HaskellParser.STOCK - 35)) | (1 << (HaskellParser.ANYCLASS - 35)) | (1 << (HaskellParser.VIA - 35)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (HaskellParser.LCASE - 73)) | (1 << (HaskellParser.Bang - 73)) | (1 << (HaskellParser.Minus - 73)) | (1 << (HaskellParser.Tilde - 73)) | (1 << (HaskellParser.DDollar - 73)) | (1 << (HaskellParser.Dollar - 73)) | (1 << (HaskellParser.Semi - 73)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (HaskellParser.Quote - 105)) | (1 << (HaskellParser.DoubleQuote - 105)) | (1 << (HaskellParser.ReverseSlash - 105)) | (1 << (HaskellParser.AopenParen - 105)) | (1 << (HaskellParser.TopenTexpQuote - 105)) | (1 << (HaskellParser.TopenExpQuote - 105)) | (1 << (HaskellParser.TopenPatQuote - 105)) | (1 << (HaskellParser.TopenTypQoute - 105)) | (1 << (HaskellParser.TopenDecQoute - 105)) | (1 << (HaskellParser.OpenBoxParen - 105)) | (1 << (HaskellParser.OpenRoundBracket - 105)) | (1 << (HaskellParser.OpenSquareBracket - 105)) | (1 << (HaskellParser.CHAR - 105)) | (1 << (HaskellParser.STRING - 105)) | (1 << (HaskellParser.VARID - 105)) | (1 << (HaskellParser.CONID - 105)) | (1 << (HaskellParser.SEMI - 105)))) !== 0) || ((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)) | (1 << (HaskellParser.FLOAT - 137)))) !== 0)) {
	            this.state = 2519;
	            this.stmts();
	        }

	        this.state = 2522;
	        this.close();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	stmts() {
	    let localctx = new StmtsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 372, HaskellParser.RULE_stmts);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2524;
	        this.stmt();
	        this.state = 2534;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,286,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2526; 
	                this._errHandler.sync(this);
	                var _alt = 1;
	                do {
	                	switch (_alt) {
	                	case 1:
	                		this.state = 2525;
	                		this.semi();
	                		break;
	                	default:
	                		throw new antlr4.error.NoViableAltException(this);
	                	}
	                	this.state = 2528; 
	                	this._errHandler.sync(this);
	                	_alt = this._interp.adaptivePredict(this._input,285, this._ctx);
	                } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	                this.state = 2530;
	                this.stmt(); 
	            }
	            this.state = 2536;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,286,this._ctx);
	        }

	        this.state = 2540;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 2537;
	            this.semi();
	            this.state = 2542;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	stmt() {
	    let localctx = new StmtContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 374, HaskellParser.RULE_stmt);
	    try {
	        this.state = 2551;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.CASE:
	        case HaskellParser.DO:
	        case HaskellParser.HIDING:
	        case HaskellParser.IF:
	        case HaskellParser.LET:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.WILDCARD:
	        case HaskellParser.EXPORT:
	        case HaskellParser.MDO:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.LCASE:
	        case HaskellParser.Bang:
	        case HaskellParser.Minus:
	        case HaskellParser.Tilde:
	        case HaskellParser.DDollar:
	        case HaskellParser.Dollar:
	        case HaskellParser.Quote:
	        case HaskellParser.DoubleQuote:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.AopenParen:
	        case HaskellParser.TopenTexpQuote:
	        case HaskellParser.TopenExpQuote:
	        case HaskellParser.TopenPatQuote:
	        case HaskellParser.TopenTypQoute:
	        case HaskellParser.TopenDecQoute:
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.OpenSquareBracket:
	        case HaskellParser.CHAR:
	        case HaskellParser.STRING:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	        case HaskellParser.FLOAT:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2543;
	            this.qual();
	            break;
	        case HaskellParser.REC:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2544;
	            this.match(HaskellParser.REC);
	            this.state = 2545;
	            this.stmtlist();
	            break;
	        case HaskellParser.Semi:
	        case HaskellParser.SEMI:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2547; 
	            this._errHandler.sync(this);
	            var _alt = 1;
	            do {
	            	switch (_alt) {
	            	case 1:
	            		this.state = 2546;
	            		this.semi();
	            		break;
	            	default:
	            		throw new antlr4.error.NoViableAltException(this);
	            	}
	            	this.state = 2549; 
	            	this._errHandler.sync(this);
	            	_alt = this._interp.adaptivePredict(this._input,288, this._ctx);
	            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qual() {
	    let localctx = new QualContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 376, HaskellParser.RULE_qual);
	    try {
	        this.state = 2560;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,290,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2553;
	            this.bindpat();
	            this.state = 2554;
	            this.match(HaskellParser.Revarrow);
	            this.state = 2555;
	            this.exp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2557;
	            this.exp();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2558;
	            this.match(HaskellParser.LET);
	            this.state = 2559;
	            this.binds();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fbinds() {
	    let localctx = new FbindsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 378, HaskellParser.RULE_fbinds);
	    var _la = 0; // Token type
	    try {
	        this.state = 2571;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.OpenRoundBracket:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2562;
	            this.fbind();
	            this.state = 2567;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	            while(_la===HaskellParser.Comma) {
	                this.state = 2563;
	                this.match(HaskellParser.Comma);
	                this.state = 2564;
	                this.fbind();
	                this.state = 2569;
	                this._errHandler.sync(this);
	                _la = this._input.LA(1);
	            }
	            break;
	        case HaskellParser.DoubleDot:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2570;
	            this.match(HaskellParser.DoubleDot);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	fbind() {
	    let localctx = new FbindContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 380, HaskellParser.RULE_fbind);
	    try {
	        this.state = 2578;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,293,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2573;
	            this.qvar();
	            this.state = 2574;
	            this.match(HaskellParser.Eq);
	            this.state = 2575;
	            this.exp();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2577;
	            this.qvar();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	dbinds() {
	    let localctx = new DbindsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 382, HaskellParser.RULE_dbinds);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2580;
	        this.dbind();

	        this.state = 2582; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 2581;
	            this.semi();
	            this.state = 2584; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI);
	        this.state = 2586;
	        this.dbind();
	        this.state = 2591;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Semi || _la===HaskellParser.SEMI) {
	            this.state = 2588;
	            this.semi();
	            this.state = 2593;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	dbind() {
	    let localctx = new DbindContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 384, HaskellParser.RULE_dbind);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2594;
	        this.varid();
	        this.state = 2595;
	        this.match(HaskellParser.Eq);
	        this.state = 2596;
	        this.exp();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	name_boolformula_opt() {
	    let localctx = new Name_boolformula_optContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 386, HaskellParser.RULE_name_boolformula_opt);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2598;
	        this.name_boolformula_and();
	        this.state = 2603;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Pipe) {
	            this.state = 2599;
	            this.match(HaskellParser.Pipe);
	            this.state = 2600;
	            this.name_boolformula_and();
	            this.state = 2605;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	name_boolformula_and() {
	    let localctx = new Name_boolformula_andContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 388, HaskellParser.RULE_name_boolformula_and);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2606;
	        this.name_boolformula_and_list();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	name_boolformula_and_list() {
	    let localctx = new Name_boolformula_and_listContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 390, HaskellParser.RULE_name_boolformula_and_list);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2608;
	        this.name_boolformula_atom();
	        this.state = 2613;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 2609;
	            this.match(HaskellParser.Comma);
	            this.state = 2610;
	            this.name_boolformula_atom();
	            this.state = 2615;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	name_boolformula_atom() {
	    let localctx = new Name_boolformula_atomContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 392, HaskellParser.RULE_name_boolformula_atom);
	    try {
	        this.state = 2621;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,298,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2616;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2617;
	            this.name_boolformula_opt();
	            this.state = 2618;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2620;
	            this.name_var();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	namelist() {
	    let localctx = new NamelistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 394, HaskellParser.RULE_namelist);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2623;
	        this.name_var();
	        this.state = 2628;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 2624;
	            this.match(HaskellParser.Comma);
	            this.state = 2625;
	            this.name_var();
	            this.state = 2630;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	name_var() {
	    let localctx = new Name_varContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 396, HaskellParser.RULE_name_var);
	    try {
	        this.state = 2633;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,300,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2631;
	            this.var_();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2632;
	            this.con();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qcon_nowiredlist() {
	    let localctx = new Qcon_nowiredlistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 398, HaskellParser.RULE_qcon_nowiredlist);
	    try {
	        this.state = 2637;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,301,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2635;
	            this.gen_qcon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2636;
	            this.sysdcon_nolist();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qcon() {
	    let localctx = new QconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 400, HaskellParser.RULE_qcon);
	    try {
	        this.state = 2641;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,302,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2639;
	            this.gen_qcon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2640;
	            this.sysdcon();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gen_qcon() {
	    let localctx = new Gen_qconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 402, HaskellParser.RULE_gen_qcon);
	    try {
	        this.state = 2648;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2643;
	            this.qconid();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2644;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2645;
	            this.qconsym();
	            this.state = 2646;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	con() {
	    let localctx = new ConContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 404, HaskellParser.RULE_con);
	    try {
	        this.state = 2656;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,304,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2650;
	            this.conid();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2651;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2652;
	            this.consym();
	            this.state = 2653;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2655;
	            this.sysdcon();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	con_list() {
	    let localctx = new Con_listContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 406, HaskellParser.RULE_con_list);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2658;
	        this.con();
	        this.state = 2663;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        while(_la===HaskellParser.Comma) {
	            this.state = 2659;
	            this.match(HaskellParser.Comma);
	            this.state = 2660;
	            this.con();
	            this.state = 2665;
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sysdcon_nolist() {
	    let localctx = new Sysdcon_nolistContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 408, HaskellParser.RULE_sysdcon_nolist);
	    try {
	        this.state = 2678;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,306,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2666;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2667;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2668;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2669;
	            this.commas();
	            this.state = 2670;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2672;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2673;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2674;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2675;
	            this.commas();
	            this.state = 2676;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	sysdcon() {
	    let localctx = new SysdconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 410, HaskellParser.RULE_sysdcon);
	    try {
	        this.state = 2683;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.OpenBoxParen:
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2680;
	            this.sysdcon_nolist();
	            break;
	        case HaskellParser.OpenSquareBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2681;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 2682;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	conop() {
	    let localctx = new ConopContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 412, HaskellParser.RULE_conop);
	    try {
	        this.state = 2690;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Colon:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2685;
	            this.consym();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2686;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2687;
	            this.conid();
	            this.state = 2688;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qconop() {
	    let localctx = new QconopContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 414, HaskellParser.RULE_qconop);
	    try {
	        this.state = 2697;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Colon:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2692;
	            this.gconsym();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2693;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2694;
	            this.qconid();
	            this.state = 2695;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gconsym() {
	    let localctx = new GconsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 416, HaskellParser.RULE_gconsym);
	    try {
	        this.state = 2701;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,310,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2699;
	            this.match(HaskellParser.Colon);
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2700;
	            this.qconsym();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	gtycon() {
	    let localctx = new GtyconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 418, HaskellParser.RULE_gtycon);
	    try {
	        this.state = 2708;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,311,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2703;
	            this.ntgtycon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2704;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2705;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2706;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2707;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ntgtycon() {
	    let localctx = new NtgtyconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 420, HaskellParser.RULE_ntgtycon);
	    try {
	        this.state = 2724;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,312,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2710;
	            this.oqtycon();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2711;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2712;
	            this.commas();
	            this.state = 2713;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2715;
	            this.match(HaskellParser.OpenBoxParen);
	            this.state = 2716;
	            this.commas();
	            this.state = 2717;
	            this.match(HaskellParser.CloseBoxParen);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2719;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2720;
	            this.match(HaskellParser.Arrow);
	            this.state = 2721;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2722;
	            this.match(HaskellParser.OpenSquareBracket);
	            this.state = 2723;
	            this.match(HaskellParser.CloseSquareBracket);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	oqtycon() {
	    let localctx = new OqtyconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 422, HaskellParser.RULE_oqtycon);
	    try {
	        this.state = 2731;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2726;
	            this.qtycon();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2727;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2728;
	            this.qtyconsym();
	            this.state = 2729;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qtyconop() {
	    let localctx = new QtyconopContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 424, HaskellParser.RULE_qtyconop);
	    try {
	        this.state = 2738;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Minus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2733;
	            this.qtyconsym();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2734;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2735;
	            this.qtycon();
	            this.state = 2736;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qtycon() {
	    let localctx = new QtyconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 426, HaskellParser.RULE_qtycon);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2743;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,315,this._ctx);
	        if(la_===1) {
	            this.state = 2740;
	            this.modid();
	            this.state = 2741;
	            this.match(HaskellParser.Dot);

	        }
	        this.state = 2745;
	        this.tycon();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tycon() {
	    let localctx = new TyconContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 428, HaskellParser.RULE_tycon);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2747;
	        this.conid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qtyconsym() {
	    let localctx = new QtyconsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 430, HaskellParser.RULE_qtyconsym);
	    try {
	        this.state = 2752;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,316,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2749;
	            this.qconsym();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2750;
	            this.qvarsym();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2751;
	            this.tyconsym();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyconsym() {
	    let localctx = new TyconsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 432, HaskellParser.RULE_tyconsym);
	    try {
	        this.state = 2759;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,317,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2754;
	            this.consym();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2755;
	            this.varsym();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2756;
	            this.match(HaskellParser.Colon);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2757;
	            this.match(HaskellParser.Minus);
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2758;
	            this.match(HaskellParser.Dot);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	op() {
	    let localctx = new OpContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 434, HaskellParser.RULE_op);
	    try {
	        this.state = 2763;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,318,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2761;
	            this.varop();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2762;
	            this.conop();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	varop() {
	    let localctx = new VaropContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 436, HaskellParser.RULE_varop);
	    try {
	        this.state = 2770;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Minus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.ReverseSlash:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2765;
	            this.varsym();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2766;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2767;
	            this.varid();
	            this.state = 2768;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qop() {
	    let localctx = new QopContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 438, HaskellParser.RULE_qop);
	    try {
	        this.state = 2774;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,320,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2772;
	            this.qvarop();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2773;
	            this.qconop();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qopm() {
	    let localctx = new QopmContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 440, HaskellParser.RULE_qopm);
	    try {
	        this.state = 2779;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,321,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2776;
	            this.qvaropm();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2777;
	            this.qconop();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2778;
	            this.hole_op();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	hole_op() {
	    let localctx = new Hole_opContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 442, HaskellParser.RULE_hole_op);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2781;
	        this.match(HaskellParser.BackQuote);
	        this.state = 2782;
	        this.match(HaskellParser.WILDCARD);
	        this.state = 2783;
	        this.match(HaskellParser.BackQuote);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvarop() {
	    let localctx = new QvaropContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 444, HaskellParser.RULE_qvarop);
	    try {
	        this.state = 2790;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Minus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2785;
	            this.qvarsym();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2786;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2787;
	            this.qvarid();
	            this.state = 2788;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvaropm() {
	    let localctx = new QvaropmContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 446, HaskellParser.RULE_qvaropm);
	    try {
	        this.state = 2797;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Minus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.ReverseSlash:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2792;
	            this.qvarsym_no_minus();
	            break;
	        case HaskellParser.BackQuote:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2793;
	            this.match(HaskellParser.BackQuote);
	            this.state = 2794;
	            this.qvarid();
	            this.state = 2795;
	            this.match(HaskellParser.BackQuote);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyvar() {
	    let localctx = new TyvarContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 448, HaskellParser.RULE_tyvar);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2799;
	        this.varid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyvarop() {
	    let localctx = new TyvaropContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 450, HaskellParser.RULE_tyvarop);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2801;
	        this.match(HaskellParser.BackQuote);
	        this.state = 2802;
	        this.tyvarid();
	        this.state = 2803;
	        this.match(HaskellParser.BackQuote);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tyvarid() {
	    let localctx = new TyvaridContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 452, HaskellParser.RULE_tyvarid);
	    try {
	        this.state = 2810;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,324,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2805;
	            this.varid();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2806;
	            this.special_id();
	            break;

	        case 3:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2807;
	            this.match(HaskellParser.UNSAFE);
	            break;

	        case 4:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2808;
	            this.match(HaskellParser.SAFE);
	            break;

	        case 5:
	            this.enterOuterAlt(localctx, 5);
	            this.state = 2809;
	            this.match(HaskellParser.INTERRUPTIBLE);
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	tycls() {
	    let localctx = new TyclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 454, HaskellParser.RULE_tycls);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2812;
	        this.conid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qtycls() {
	    let localctx = new QtyclsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 456, HaskellParser.RULE_qtycls);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2817;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,325,this._ctx);
	        if(la_===1) {
	            this.state = 2814;
	            this.modid();
	            this.state = 2815;
	            this.match(HaskellParser.Dot);

	        }
	        this.state = 2819;
	        this.tycls();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	var_() {
	    let localctx = new Var_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 458, HaskellParser.RULE_var_);
	    try {
	        this.state = 2826;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.VARID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2821;
	            this.varid();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2822;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2823;
	            this.varsym();
	            this.state = 2824;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvar() {
	    let localctx = new QvarContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 460, HaskellParser.RULE_qvar);
	    try {
	        this.state = 2833;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	        case HaskellParser.VARID:
	        case HaskellParser.CONID:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2828;
	            this.qvarid();
	            break;
	        case HaskellParser.OpenRoundBracket:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2829;
	            this.match(HaskellParser.OpenRoundBracket);
	            this.state = 2830;
	            this.qvarsym();
	            this.state = 2831;
	            this.match(HaskellParser.CloseRoundBracket);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvarid() {
	    let localctx = new QvaridContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 462, HaskellParser.RULE_qvarid);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2838;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.CONID) {
	            this.state = 2835;
	            this.modid();
	            this.state = 2836;
	            this.match(HaskellParser.Dot);
	        }

	        this.state = 2840;
	        this.varid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	varid() {
	    let localctx = new VaridContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 464, HaskellParser.RULE_varid);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2844;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.VARID:
	            this.state = 2842;
	            this.match(HaskellParser.VARID);
	            break;
	        case HaskellParser.AS:
	        case HaskellParser.HIDING:
	        case HaskellParser.QUALIFIED:
	        case HaskellParser.EXPORT:
	        case HaskellParser.STDCALL:
	        case HaskellParser.CCALL:
	        case HaskellParser.CAPI:
	        case HaskellParser.JSCALL:
	        case HaskellParser.STOCK:
	        case HaskellParser.ANYCLASS:
	        case HaskellParser.VIA:
	            this.state = 2843;
	            this.special_id();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	        this.state = 2849;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,330,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2846;
	                this.match(HaskellParser.Hash); 
	            }
	            this.state = 2851;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,330,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvarsym() {
	    let localctx = new QvarsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 466, HaskellParser.RULE_qvarsym);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2855;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.CONID) {
	            this.state = 2852;
	            this.modid();
	            this.state = 2853;
	            this.match(HaskellParser.Dot);
	        }

	        this.state = 2857;
	        this.varsym();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qvarsym_no_minus() {
	    let localctx = new Qvarsym_no_minusContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 468, HaskellParser.RULE_qvarsym_no_minus);
	    try {
	        this.state = 2861;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,332,this._ctx);
	        switch(la_) {
	        case 1:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2859;
	            this.varsym_no_minus();
	            break;

	        case 2:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2860;
	            this.qvarsym();
	            break;

	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	varsym() {
	    let localctx = new VarsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 470, HaskellParser.RULE_varsym);
	    try {
	        this.state = 2865;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.Hash:
	        case HaskellParser.Less:
	        case HaskellParser.Greater:
	        case HaskellParser.Ampersand:
	        case HaskellParser.Pipe:
	        case HaskellParser.Bang:
	        case HaskellParser.Caret:
	        case HaskellParser.Plus:
	        case HaskellParser.Asterisk:
	        case HaskellParser.Percent:
	        case HaskellParser.Divide:
	        case HaskellParser.Tilde:
	        case HaskellParser.Atsign:
	        case HaskellParser.Dollar:
	        case HaskellParser.Dot:
	        case HaskellParser.QuestionMark:
	        case HaskellParser.Colon:
	        case HaskellParser.Eq:
	        case HaskellParser.ReverseSlash:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2863;
	            this.varsym_no_minus();
	            break;
	        case HaskellParser.Minus:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2864;
	            this.match(HaskellParser.Minus);
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	varsym_no_minus() {
	    let localctx = new Varsym_no_minusContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 472, HaskellParser.RULE_varsym_no_minus);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2868; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 2867;
	        		this.ascSymbol();
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 2870; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,334, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	special_id() {
	    let localctx = new Special_idContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 474, HaskellParser.RULE_special_id);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2872;
	        _la = this._input.LA(1);
	        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << HaskellParser.AS) | (1 << HaskellParser.HIDING) | (1 << HaskellParser.QUALIFIED) | (1 << HaskellParser.EXPORT))) !== 0) || ((((_la - 38)) & ~0x1f) == 0 && ((1 << (_la - 38)) & ((1 << (HaskellParser.STDCALL - 38)) | (1 << (HaskellParser.CCALL - 38)) | (1 << (HaskellParser.CAPI - 38)) | (1 << (HaskellParser.JSCALL - 38)) | (1 << (HaskellParser.STOCK - 38)) | (1 << (HaskellParser.ANYCLASS - 38)) | (1 << (HaskellParser.VIA - 38)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qconid() {
	    let localctx = new QconidContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 476, HaskellParser.RULE_qconid);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2877;
	        this._errHandler.sync(this);
	        var la_ = this._interp.adaptivePredict(this._input,335,this._ctx);
	        if(la_===1) {
	            this.state = 2874;
	            this.modid();
	            this.state = 2875;
	            this.match(HaskellParser.Dot);

	        }
	        this.state = 2879;
	        this.conid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	conid() {
	    let localctx = new ConidContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 478, HaskellParser.RULE_conid);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2881;
	        this.match(HaskellParser.CONID);
	        this.state = 2885;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,336,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2882;
	                this.match(HaskellParser.Hash); 
	            }
	            this.state = 2887;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,336,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	qconsym() {
	    let localctx = new QconsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 480, HaskellParser.RULE_qconsym);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2891;
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        if(_la===HaskellParser.CONID) {
	            this.state = 2888;
	            this.modid();
	            this.state = 2889;
	            this.match(HaskellParser.Dot);
	        }

	        this.state = 2893;
	        this.consym();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	consym() {
	    let localctx = new ConsymContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 482, HaskellParser.RULE_consym);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2895;
	        this.match(HaskellParser.Colon);
	        this.state = 2899;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,338,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2896;
	                this.ascSymbol(); 
	            }
	            this.state = 2901;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,338,this._ctx);
	        }

	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	literal() {
	    let localctx = new LiteralContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 484, HaskellParser.RULE_literal);
	    try {
	        this.state = 2906;
	        this._errHandler.sync(this);
	        switch(this._input.LA(1)) {
	        case HaskellParser.DECIMAL:
	        case HaskellParser.OCTAL:
	        case HaskellParser.HEXADECIMAL:
	            this.enterOuterAlt(localctx, 1);
	            this.state = 2902;
	            this.integer();
	            break;
	        case HaskellParser.FLOAT:
	            this.enterOuterAlt(localctx, 2);
	            this.state = 2903;
	            this.pfloat();
	            break;
	        case HaskellParser.CHAR:
	            this.enterOuterAlt(localctx, 3);
	            this.state = 2904;
	            this.pchar();
	            break;
	        case HaskellParser.STRING:
	            this.enterOuterAlt(localctx, 4);
	            this.state = 2905;
	            this.pstring();
	            break;
	        default:
	            throw new antlr4.error.NoViableAltException(this);
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	open_() {
	    let localctx = new Open_Context(this, this._ctx, this.state);
	    this.enterRule(localctx, 486, HaskellParser.RULE_open_);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2908;
	        _la = this._input.LA(1);
	        if(!(_la===HaskellParser.OCURLY || _la===HaskellParser.VOCURLY)) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	close() {
	    let localctx = new CloseContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 488, HaskellParser.RULE_close);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2910;
	        _la = this._input.LA(1);
	        if(!(_la===HaskellParser.CCURLY || _la===HaskellParser.VCCURLY)) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	semi() {
	    let localctx = new SemiContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 490, HaskellParser.RULE_semi);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2912;
	        _la = this._input.LA(1);
	        if(!(_la===HaskellParser.Semi || _la===HaskellParser.SEMI)) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	modid() {
	    let localctx = new ModidContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 492, HaskellParser.RULE_modid);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2919;
	        this._errHandler.sync(this);
	        var _alt = this._interp.adaptivePredict(this._input,340,this._ctx)
	        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
	            if(_alt===1) {
	                this.state = 2914;
	                this.conid();
	                this.state = 2915;
	                this.match(HaskellParser.Dot); 
	            }
	            this.state = 2921;
	            this._errHandler.sync(this);
	            _alt = this._interp.adaptivePredict(this._input,340,this._ctx);
	        }

	        this.state = 2922;
	        this.conid();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	commas() {
	    let localctx = new CommasContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 494, HaskellParser.RULE_commas);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2925; 
	        this._errHandler.sync(this);
	        _la = this._input.LA(1);
	        do {
	            this.state = 2924;
	            this.match(HaskellParser.Comma);
	            this.state = 2927; 
	            this._errHandler.sync(this);
	            _la = this._input.LA(1);
	        } while(_la===HaskellParser.Comma);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	bars() {
	    let localctx = new BarsContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 496, HaskellParser.RULE_bars);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2930; 
	        this._errHandler.sync(this);
	        var _alt = 1;
	        do {
	        	switch (_alt) {
	        	case 1:
	        		this.state = 2929;
	        		this.match(HaskellParser.Pipe);
	        		break;
	        	default:
	        		throw new antlr4.error.NoViableAltException(this);
	        	}
	        	this.state = 2932; 
	        	this._errHandler.sync(this);
	        	_alt = this._interp.adaptivePredict(this._input,342, this._ctx);
	        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	special() {
	    let localctx = new SpecialContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 498, HaskellParser.RULE_special);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2934;
	        _la = this._input.LA(1);
	        if(!(((((_la - 100)) & ~0x1f) == 0 && ((1 << (_la - 100)) & ((1 << (HaskellParser.Semi - 100)) | (1 << (HaskellParser.Comma - 100)) | (1 << (HaskellParser.BackQuote - 100)) | (1 << (HaskellParser.OpenRoundBracket - 100)) | (1 << (HaskellParser.CloseRoundBracket - 100)) | (1 << (HaskellParser.OpenSquareBracket - 100)) | (1 << (HaskellParser.CloseSquareBracket - 100)))) !== 0) || _la===HaskellParser.OCURLY || _la===HaskellParser.CCURLY)) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	symbol() {
	    let localctx = new SymbolContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 500, HaskellParser.RULE_symbol);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2936;
	        this.ascSymbol();
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	ascSymbol() {
	    let localctx = new AscSymbolContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 502, HaskellParser.RULE_ascSymbol);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2938;
	        _la = this._input.LA(1);
	        if(!(((((_la - 82)) & ~0x1f) == 0 && ((1 << (_la - 82)) & ((1 << (HaskellParser.Hash - 82)) | (1 << (HaskellParser.Less - 82)) | (1 << (HaskellParser.Greater - 82)) | (1 << (HaskellParser.Ampersand - 82)) | (1 << (HaskellParser.Pipe - 82)) | (1 << (HaskellParser.Bang - 82)) | (1 << (HaskellParser.Caret - 82)) | (1 << (HaskellParser.Plus - 82)) | (1 << (HaskellParser.Asterisk - 82)) | (1 << (HaskellParser.Percent - 82)) | (1 << (HaskellParser.Divide - 82)) | (1 << (HaskellParser.Tilde - 82)) | (1 << (HaskellParser.Atsign - 82)) | (1 << (HaskellParser.Dollar - 82)) | (1 << (HaskellParser.Dot - 82)) | (1 << (HaskellParser.QuestionMark - 82)) | (1 << (HaskellParser.Colon - 82)) | (1 << (HaskellParser.Eq - 82)) | (1 << (HaskellParser.ReverseSlash - 82)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	integer() {
	    let localctx = new IntegerContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 504, HaskellParser.RULE_integer);
	    var _la = 0; // Token type
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2940;
	        _la = this._input.LA(1);
	        if(!(((((_la - 137)) & ~0x1f) == 0 && ((1 << (_la - 137)) & ((1 << (HaskellParser.DECIMAL - 137)) | (1 << (HaskellParser.OCTAL - 137)) | (1 << (HaskellParser.HEXADECIMAL - 137)))) !== 0))) {
	        this._errHandler.recoverInline(this);
	        }
	        else {
	        	this._errHandler.reportMatch(this);
	            this.consume();
	        }
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pfloat() {
	    let localctx = new PfloatContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 506, HaskellParser.RULE_pfloat);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2942;
	        this.match(HaskellParser.FLOAT);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pchar() {
	    let localctx = new PcharContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 508, HaskellParser.RULE_pchar);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2944;
	        this.match(HaskellParser.CHAR);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}



	pstring() {
	    let localctx = new PstringContext(this, this._ctx, this.state);
	    this.enterRule(localctx, 510, HaskellParser.RULE_pstring);
	    try {
	        this.enterOuterAlt(localctx, 1);
	        this.state = 2946;
	        this.match(HaskellParser.STRING);
	    } catch (re) {
	    	if(re instanceof antlr4.error.RecognitionException) {
		        localctx.exception = re;
		        this._errHandler.reportError(this, re);
		        this._errHandler.recover(this, re);
		    } else {
		    	throw re;
		    }
	    } finally {
	        this.exitRule();
	    }
	    return localctx;
	}


}

HaskellParser.EOF = antlr4.Token.EOF;
HaskellParser.NEWLINE = 1;
HaskellParser.TAB = 2;
HaskellParser.WS = 3;
HaskellParser.AS = 4;
HaskellParser.CASE = 5;
HaskellParser.CLASS = 6;
HaskellParser.DATA = 7;
HaskellParser.DEFAULT = 8;
HaskellParser.DERIVING = 9;
HaskellParser.DO = 10;
HaskellParser.ELSE = 11;
HaskellParser.HIDING = 12;
HaskellParser.IF = 13;
HaskellParser.IMPORT = 14;
HaskellParser.IN = 15;
HaskellParser.INFIX = 16;
HaskellParser.INFIXL = 17;
HaskellParser.INFIXR = 18;
HaskellParser.INSTANCE = 19;
HaskellParser.LET = 20;
HaskellParser.MODULE = 21;
HaskellParser.NEWTYPE = 22;
HaskellParser.OF = 23;
HaskellParser.QUALIFIED = 24;
HaskellParser.THEN = 25;
HaskellParser.TYPE = 26;
HaskellParser.WHERE = 27;
HaskellParser.WILDCARD = 28;
HaskellParser.FORALL = 29;
HaskellParser.FOREIGN = 30;
HaskellParser.EXPORT = 31;
HaskellParser.SAFE = 32;
HaskellParser.INTERRUPTIBLE = 33;
HaskellParser.UNSAFE = 34;
HaskellParser.MDO = 35;
HaskellParser.FAMILY = 36;
HaskellParser.ROLE = 37;
HaskellParser.STDCALL = 38;
HaskellParser.CCALL = 39;
HaskellParser.CAPI = 40;
HaskellParser.CPPCALL = 41;
HaskellParser.JSCALL = 42;
HaskellParser.REC = 43;
HaskellParser.GROUP = 44;
HaskellParser.BY = 45;
HaskellParser.USING = 46;
HaskellParser.PATTERN = 47;
HaskellParser.STOCK = 48;
HaskellParser.ANYCLASS = 49;
HaskellParser.VIA = 50;
HaskellParser.LANGUAGE = 51;
HaskellParser.OPTIONS_GHC = 52;
HaskellParser.OPTIONS = 53;
HaskellParser.INLINE = 54;
HaskellParser.NOINLINE = 55;
HaskellParser.SPECIALISE = 56;
HaskellParser.SPECINLINE = 57;
HaskellParser.SOURCE = 58;
HaskellParser.RULES = 59;
HaskellParser.SCC = 60;
HaskellParser.DEPRECATED = 61;
HaskellParser.WARNING = 62;
HaskellParser.UNPACK = 63;
HaskellParser.NOUNPACK = 64;
HaskellParser.ANN = 65;
HaskellParser.MINIMAL = 66;
HaskellParser.CTYPE = 67;
HaskellParser.OVERLAPPING = 68;
HaskellParser.OVERLAPPABLE = 69;
HaskellParser.OVERLAPS = 70;
HaskellParser.INCOHERENT = 71;
HaskellParser.COMPLETE = 72;
HaskellParser.LCASE = 73;
HaskellParser.DoubleArrow = 74;
HaskellParser.DoubleColon = 75;
HaskellParser.Arrow = 76;
HaskellParser.Revarrow = 77;
HaskellParser.LarrowTail = 78;
HaskellParser.RarrowTail = 79;
HaskellParser.LLarrowTail = 80;
HaskellParser.RRarrowTail = 81;
HaskellParser.Hash = 82;
HaskellParser.Less = 83;
HaskellParser.Greater = 84;
HaskellParser.Ampersand = 85;
HaskellParser.Pipe = 86;
HaskellParser.Bang = 87;
HaskellParser.Caret = 88;
HaskellParser.Plus = 89;
HaskellParser.Minus = 90;
HaskellParser.Asterisk = 91;
HaskellParser.Percent = 92;
HaskellParser.Divide = 93;
HaskellParser.Tilde = 94;
HaskellParser.Atsign = 95;
HaskellParser.DDollar = 96;
HaskellParser.Dollar = 97;
HaskellParser.DoubleDot = 98;
HaskellParser.Dot = 99;
HaskellParser.Semi = 100;
HaskellParser.QuestionMark = 101;
HaskellParser.Comma = 102;
HaskellParser.Colon = 103;
HaskellParser.Eq = 104;
HaskellParser.Quote = 105;
HaskellParser.DoubleQuote = 106;
HaskellParser.ReverseSlash = 107;
HaskellParser.BackQuote = 108;
HaskellParser.AopenParen = 109;
HaskellParser.AcloseParen = 110;
HaskellParser.TopenTexpQuote = 111;
HaskellParser.TcloseTExpQoute = 112;
HaskellParser.TopenExpQuote = 113;
HaskellParser.TopenPatQuote = 114;
HaskellParser.TopenTypQoute = 115;
HaskellParser.TopenDecQoute = 116;
HaskellParser.TcloseQoute = 117;
HaskellParser.OpenBoxParen = 118;
HaskellParser.CloseBoxParen = 119;
HaskellParser.OpenRoundBracket = 120;
HaskellParser.CloseRoundBracket = 121;
HaskellParser.OpenSquareBracket = 122;
HaskellParser.CloseSquareBracket = 123;
HaskellParser.CHAR = 124;
HaskellParser.STRING = 125;
HaskellParser.VARID = 126;
HaskellParser.CONID = 127;
HaskellParser.OpenPragmaBracket = 128;
HaskellParser.ClosePragmaBracket = 129;
HaskellParser.COMMENT = 130;
HaskellParser.NCOMMENT = 131;
HaskellParser.OCURLY = 132;
HaskellParser.CCURLY = 133;
HaskellParser.VOCURLY = 134;
HaskellParser.VCCURLY = 135;
HaskellParser.SEMI = 136;
HaskellParser.DECIMAL = 137;
HaskellParser.OCTAL = 138;
HaskellParser.HEXADECIMAL = 139;
HaskellParser.FLOAT = 140;
HaskellParser.EXPONENT = 141;

HaskellParser.RULE_module = 0;
HaskellParser.RULE_module_content = 1;
HaskellParser.RULE_where_module = 2;
HaskellParser.RULE_module_body = 3;
HaskellParser.RULE_pragmas = 4;
HaskellParser.RULE_pragma = 5;
HaskellParser.RULE_language_pragma = 6;
HaskellParser.RULE_options_ghc = 7;
HaskellParser.RULE_simple_options = 8;
HaskellParser.RULE_extension_ = 9;
HaskellParser.RULE_body = 10;
HaskellParser.RULE_impdecls = 11;
HaskellParser.RULE_exports = 12;
HaskellParser.RULE_exprt = 13;
HaskellParser.RULE_impdecl = 14;
HaskellParser.RULE_impspec = 15;
HaskellParser.RULE_himport = 16;
HaskellParser.RULE_cname = 17;
HaskellParser.RULE_fixity = 18;
HaskellParser.RULE_ops = 19;
HaskellParser.RULE_topdecls = 20;
HaskellParser.RULE_topdecl = 21;
HaskellParser.RULE_cl_decl = 22;
HaskellParser.RULE_ty_decl = 23;
HaskellParser.RULE_standalone_kind_sig = 24;
HaskellParser.RULE_sks_vars = 25;
HaskellParser.RULE_inst_decl = 26;
HaskellParser.RULE_overlap_pragma = 27;
HaskellParser.RULE_deriv_strategy_no_via = 28;
HaskellParser.RULE_deriv_strategy_via = 29;
HaskellParser.RULE_deriv_standalone_strategy = 30;
HaskellParser.RULE_opt_injective_info = 31;
HaskellParser.RULE_injectivity_cond = 32;
HaskellParser.RULE_inj_varids = 33;
HaskellParser.RULE_where_type_family = 34;
HaskellParser.RULE_ty_fam_inst_eqn_list = 35;
HaskellParser.RULE_ty_fam_inst_eqns = 36;
HaskellParser.RULE_ty_fam_inst_eqn = 37;
HaskellParser.RULE_at_decl_cls = 38;
HaskellParser.RULE_at_decl_inst = 39;
HaskellParser.RULE_opt_kind_sig = 40;
HaskellParser.RULE_opt_datafam_kind_sig = 41;
HaskellParser.RULE_opt_tyfam_kind_sig = 42;
HaskellParser.RULE_opt_at_kind_inj_sig = 43;
HaskellParser.RULE_tycl_hdr = 44;
HaskellParser.RULE_tycl_hdr_inst = 45;
HaskellParser.RULE_capi_ctype = 46;
HaskellParser.RULE_standalone_deriving = 47;
HaskellParser.RULE_role_annot = 48;
HaskellParser.RULE_roles = 49;
HaskellParser.RULE_role = 50;
HaskellParser.RULE_pattern_synonym_decl = 51;
HaskellParser.RULE_pattern_synonym_lhs = 52;
HaskellParser.RULE_vars_ = 53;
HaskellParser.RULE_cvars = 54;
HaskellParser.RULE_where_decls = 55;
HaskellParser.RULE_pattern_synonym_sig = 56;
HaskellParser.RULE_decl_cls = 57;
HaskellParser.RULE_decls_cls = 58;
HaskellParser.RULE_decllist_cls = 59;
HaskellParser.RULE_where_cls = 60;
HaskellParser.RULE_decl_inst = 61;
HaskellParser.RULE_decls_inst = 62;
HaskellParser.RULE_decllist_inst = 63;
HaskellParser.RULE_where_inst = 64;
HaskellParser.RULE_decls = 65;
HaskellParser.RULE_decllist = 66;
HaskellParser.RULE_binds = 67;
HaskellParser.RULE_wherebinds = 68;
HaskellParser.RULE_rules = 69;
HaskellParser.RULE_pragma_rule = 70;
HaskellParser.RULE_rule_activation_marker = 71;
HaskellParser.RULE_rule_activation = 72;
HaskellParser.RULE_rule_foralls = 73;
HaskellParser.RULE_rule_vars = 74;
HaskellParser.RULE_rule_var = 75;
HaskellParser.RULE_warnings = 76;
HaskellParser.RULE_pragma_warning = 77;
HaskellParser.RULE_deprecations = 78;
HaskellParser.RULE_pragma_deprecation = 79;
HaskellParser.RULE_strings = 80;
HaskellParser.RULE_stringlist = 81;
HaskellParser.RULE_annotation = 82;
HaskellParser.RULE_fdecl = 83;
HaskellParser.RULE_callconv = 84;
HaskellParser.RULE_safety = 85;
HaskellParser.RULE_fspec = 86;
HaskellParser.RULE_opt_sig = 87;
HaskellParser.RULE_opt_tyconsig = 88;
HaskellParser.RULE_sigtype = 89;
HaskellParser.RULE_sigtypedoc = 90;
HaskellParser.RULE_sig_vars = 91;
HaskellParser.RULE_sigtypes1 = 92;
HaskellParser.RULE_unpackedness = 93;
HaskellParser.RULE_forall_vis_flag = 94;
HaskellParser.RULE_ktype = 95;
HaskellParser.RULE_ktypedoc = 96;
HaskellParser.RULE_ctype = 97;
HaskellParser.RULE_ctypedoc = 98;
HaskellParser.RULE_tycl_context = 99;
HaskellParser.RULE_constr_context = 100;
HaskellParser.RULE_type_ = 101;
HaskellParser.RULE_typedoc = 102;
HaskellParser.RULE_constr_btype = 103;
HaskellParser.RULE_constr_tyapps = 104;
HaskellParser.RULE_constr_tyapp = 105;
HaskellParser.RULE_btype = 106;
HaskellParser.RULE_tyapps = 107;
HaskellParser.RULE_tyapp = 108;
HaskellParser.RULE_atype = 109;
HaskellParser.RULE_inst_type = 110;
HaskellParser.RULE_deriv_types = 111;
HaskellParser.RULE_comma_types = 112;
HaskellParser.RULE_bar_types2 = 113;
HaskellParser.RULE_tv_bndrs = 114;
HaskellParser.RULE_tv_bndr = 115;
HaskellParser.RULE_tv_bndr_no_braces = 116;
HaskellParser.RULE_fds = 117;
HaskellParser.RULE_fds1 = 118;
HaskellParser.RULE_fd = 119;
HaskellParser.RULE_varids0 = 120;
HaskellParser.RULE_kind = 121;
HaskellParser.RULE_gadt_constrlist = 122;
HaskellParser.RULE_gadt_constrs = 123;
HaskellParser.RULE_gadt_constr_with_doc = 124;
HaskellParser.RULE_gadt_constr = 125;
HaskellParser.RULE_constrs = 126;
HaskellParser.RULE_constrs1 = 127;
HaskellParser.RULE_constr = 128;
HaskellParser.RULE_forall = 129;
HaskellParser.RULE_constr_stuff = 130;
HaskellParser.RULE_fielddecls = 131;
HaskellParser.RULE_fielddecl = 132;
HaskellParser.RULE_derivings = 133;
HaskellParser.RULE_deriving = 134;
HaskellParser.RULE_deriv_clause_types = 135;
HaskellParser.RULE_decl_no_th = 136;
HaskellParser.RULE_decl = 137;
HaskellParser.RULE_rhs = 138;
HaskellParser.RULE_gdrhs = 139;
HaskellParser.RULE_gdrh = 140;
HaskellParser.RULE_sigdecl = 141;
HaskellParser.RULE_activation = 142;
HaskellParser.RULE_th_quasiquote = 143;
HaskellParser.RULE_th_qquasiquote = 144;
HaskellParser.RULE_quasiquote = 145;
HaskellParser.RULE_exp = 146;
HaskellParser.RULE_infixexp = 147;
HaskellParser.RULE_exp10p = 148;
HaskellParser.RULE_exp10 = 149;
HaskellParser.RULE_fexp = 150;
HaskellParser.RULE_aexp = 151;
HaskellParser.RULE_aexp1 = 152;
HaskellParser.RULE_aexp2 = 153;
HaskellParser.RULE_splice_exp = 154;
HaskellParser.RULE_splice_untyped = 155;
HaskellParser.RULE_splice_typed = 156;
HaskellParser.RULE_cmdargs = 157;
HaskellParser.RULE_acmd = 158;
HaskellParser.RULE_cvtopbody = 159;
HaskellParser.RULE_cvtopdecls0 = 160;
HaskellParser.RULE_texp = 161;
HaskellParser.RULE_tup_exprs = 162;
HaskellParser.RULE_commas_tup_tail = 163;
HaskellParser.RULE_tup_tail = 164;
HaskellParser.RULE_list_ = 165;
HaskellParser.RULE_lexps = 166;
HaskellParser.RULE_flattenedpquals = 167;
HaskellParser.RULE_pquals = 168;
HaskellParser.RULE_squals = 169;
HaskellParser.RULE_transformqual = 170;
HaskellParser.RULE_guards = 171;
HaskellParser.RULE_guard_ = 172;
HaskellParser.RULE_alts = 173;
HaskellParser.RULE_alt = 174;
HaskellParser.RULE_alt_rhs = 175;
HaskellParser.RULE_ralt = 176;
HaskellParser.RULE_gdpats = 177;
HaskellParser.RULE_ifgdpats = 178;
HaskellParser.RULE_gdpat = 179;
HaskellParser.RULE_pat = 180;
HaskellParser.RULE_bindpat = 181;
HaskellParser.RULE_apat = 182;
HaskellParser.RULE_apats = 183;
HaskellParser.RULE_fpat = 184;
HaskellParser.RULE_stmtlist = 185;
HaskellParser.RULE_stmts = 186;
HaskellParser.RULE_stmt = 187;
HaskellParser.RULE_qual = 188;
HaskellParser.RULE_fbinds = 189;
HaskellParser.RULE_fbind = 190;
HaskellParser.RULE_dbinds = 191;
HaskellParser.RULE_dbind = 192;
HaskellParser.RULE_name_boolformula_opt = 193;
HaskellParser.RULE_name_boolformula_and = 194;
HaskellParser.RULE_name_boolformula_and_list = 195;
HaskellParser.RULE_name_boolformula_atom = 196;
HaskellParser.RULE_namelist = 197;
HaskellParser.RULE_name_var = 198;
HaskellParser.RULE_qcon_nowiredlist = 199;
HaskellParser.RULE_qcon = 200;
HaskellParser.RULE_gen_qcon = 201;
HaskellParser.RULE_con = 202;
HaskellParser.RULE_con_list = 203;
HaskellParser.RULE_sysdcon_nolist = 204;
HaskellParser.RULE_sysdcon = 205;
HaskellParser.RULE_conop = 206;
HaskellParser.RULE_qconop = 207;
HaskellParser.RULE_gconsym = 208;
HaskellParser.RULE_gtycon = 209;
HaskellParser.RULE_ntgtycon = 210;
HaskellParser.RULE_oqtycon = 211;
HaskellParser.RULE_qtyconop = 212;
HaskellParser.RULE_qtycon = 213;
HaskellParser.RULE_tycon = 214;
HaskellParser.RULE_qtyconsym = 215;
HaskellParser.RULE_tyconsym = 216;
HaskellParser.RULE_op = 217;
HaskellParser.RULE_varop = 218;
HaskellParser.RULE_qop = 219;
HaskellParser.RULE_qopm = 220;
HaskellParser.RULE_hole_op = 221;
HaskellParser.RULE_qvarop = 222;
HaskellParser.RULE_qvaropm = 223;
HaskellParser.RULE_tyvar = 224;
HaskellParser.RULE_tyvarop = 225;
HaskellParser.RULE_tyvarid = 226;
HaskellParser.RULE_tycls = 227;
HaskellParser.RULE_qtycls = 228;
HaskellParser.RULE_var_ = 229;
HaskellParser.RULE_qvar = 230;
HaskellParser.RULE_qvarid = 231;
HaskellParser.RULE_varid = 232;
HaskellParser.RULE_qvarsym = 233;
HaskellParser.RULE_qvarsym_no_minus = 234;
HaskellParser.RULE_varsym = 235;
HaskellParser.RULE_varsym_no_minus = 236;
HaskellParser.RULE_special_id = 237;
HaskellParser.RULE_qconid = 238;
HaskellParser.RULE_conid = 239;
HaskellParser.RULE_qconsym = 240;
HaskellParser.RULE_consym = 241;
HaskellParser.RULE_literal = 242;
HaskellParser.RULE_open_ = 243;
HaskellParser.RULE_close = 244;
HaskellParser.RULE_semi = 245;
HaskellParser.RULE_modid = 246;
HaskellParser.RULE_commas = 247;
HaskellParser.RULE_bars = 248;
HaskellParser.RULE_special = 249;
HaskellParser.RULE_symbol = 250;
HaskellParser.RULE_ascSymbol = 251;
HaskellParser.RULE_integer = 252;
HaskellParser.RULE_pfloat = 253;
HaskellParser.RULE_pchar = 254;
HaskellParser.RULE_pstring = 255;

class ModuleContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_module;
    }

	EOF() {
	    return this.getToken(HaskellParser.EOF, 0);
	};

	module_content() {
	    return this.getTypedRuleContext(Module_contentContext,0);
	};

	body() {
	    return this.getTypedRuleContext(BodyContext,0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	pragmas() {
	    return this.getTypedRuleContext(PragmasContext,0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterModule(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitModule(this);
		}
	}


}



class Module_contentContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_module_content;
    }

	MODULE() {
	    return this.getToken(HaskellParser.MODULE, 0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	where_module() {
	    return this.getTypedRuleContext(Where_moduleContext,0);
	};

	exports() {
	    return this.getTypedRuleContext(ExportsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterModule_content(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitModule_content(this);
		}
	}


}



class Where_moduleContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_where_module;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	module_body() {
	    return this.getTypedRuleContext(Module_bodyContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWhere_module(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWhere_module(this);
		}
	}


}



class Module_bodyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_module_body;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	body() {
	    return this.getTypedRuleContext(BodyContext,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterModule_body(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitModule_body(this);
		}
	}


}



class PragmasContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pragmas;
    }

	pragma = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(PragmaContext);
	    } else {
	        return this.getTypedRuleContext(PragmaContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPragmas(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPragmas(this);
		}
	}


}



class PragmaContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pragma;
    }

	language_pragma() {
	    return this.getTypedRuleContext(Language_pragmaContext,0);
	};

	options_ghc() {
	    return this.getTypedRuleContext(Options_ghcContext,0);
	};

	simple_options() {
	    return this.getTypedRuleContext(Simple_optionsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPragma(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPragma(this);
		}
	}


}



class Language_pragmaContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_language_pragma;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	LANGUAGE() {
	    return this.getToken(HaskellParser.LANGUAGE, 0);
	};

	extension_ = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Extension_Context);
	    } else {
	        return this.getTypedRuleContext(Extension_Context,i);
	    }
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	semi() {
	    return this.getTypedRuleContext(SemiContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterLanguage_pragma(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitLanguage_pragma(this);
		}
	}


}



class Options_ghcContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_options_ghc;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	OPTIONS_GHC() {
	    return this.getToken(HaskellParser.OPTIONS_GHC, 0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	Minus = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Minus);
	    } else {
	        return this.getToken(HaskellParser.Minus, i);
	    }
	};


	semi() {
	    return this.getTypedRuleContext(SemiContext,0);
	};

	varid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(VaridContext);
	    } else {
	        return this.getTypedRuleContext(VaridContext,i);
	    }
	};

	conid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ConidContext);
	    } else {
	        return this.getTypedRuleContext(ConidContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOptions_ghc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOptions_ghc(this);
		}
	}


}



class Simple_optionsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_simple_options;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	OPTIONS() {
	    return this.getToken(HaskellParser.OPTIONS, 0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	Minus = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Minus);
	    } else {
	        return this.getToken(HaskellParser.Minus, i);
	    }
	};


	semi() {
	    return this.getTypedRuleContext(SemiContext,0);
	};

	varid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(VaridContext);
	    } else {
	        return this.getTypedRuleContext(VaridContext,i);
	    }
	};

	conid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ConidContext);
	    } else {
	        return this.getTypedRuleContext(ConidContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSimple_options(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSimple_options(this);
		}
	}


}



class Extension_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_extension_;
    }

	CONID() {
	    return this.getToken(HaskellParser.CONID, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExtension_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExtension_(this);
		}
	}


}



class BodyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_body;
    }

	impdecls() {
	    return this.getTypedRuleContext(ImpdeclsContext,0);
	};

	topdecls() {
	    return this.getTypedRuleContext(TopdeclsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBody(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBody(this);
		}
	}


}



class ImpdeclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_impdecls;
    }

	impdecl = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ImpdeclContext);
	    } else {
	        return this.getTypedRuleContext(ImpdeclContext,i);
	    }
	};

	NEWLINE = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.NEWLINE);
	    } else {
	        return this.getToken(HaskellParser.NEWLINE, i);
	    }
	};


	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterImpdecls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitImpdecls(this);
		}
	}


}



class ExportsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_exports;
    }

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	exprt = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ExprtContext);
	    } else {
	        return this.getTypedRuleContext(ExprtContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExports(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExports(this);
		}
	}


}



class ExprtContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_exprt;
    }

	qvar = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(QvarContext);
	    } else {
	        return this.getTypedRuleContext(QvarContext,i);
	    }
	};

	qtycon() {
	    return this.getTypedRuleContext(QtyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	DoubleDot() {
	    return this.getToken(HaskellParser.DoubleDot, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	cname = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(CnameContext);
	    } else {
	        return this.getTypedRuleContext(CnameContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	qtycls() {
	    return this.getTypedRuleContext(QtyclsContext,0);
	};

	MODULE() {
	    return this.getToken(HaskellParser.MODULE, 0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExprt(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExprt(this);
		}
	}


}



class ImpdeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_impdecl;
    }

	IMPORT() {
	    return this.getToken(HaskellParser.IMPORT, 0);
	};

	modid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ModidContext);
	    } else {
	        return this.getTypedRuleContext(ModidContext,i);
	    }
	};

	QUALIFIED() {
	    return this.getToken(HaskellParser.QUALIFIED, 0);
	};

	AS() {
	    return this.getToken(HaskellParser.AS, 0);
	};

	impspec() {
	    return this.getTypedRuleContext(ImpspecContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterImpdecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitImpdecl(this);
		}
	}


}



class ImpspecContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_impspec;
    }

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	himport = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(HimportContext);
	    } else {
	        return this.getTypedRuleContext(HimportContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	HIDING() {
	    return this.getToken(HaskellParser.HIDING, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterImpspec(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitImpspec(this);
		}
	}


}



class HimportContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_himport;
    }

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	tycon() {
	    return this.getTypedRuleContext(TyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	DoubleDot() {
	    return this.getToken(HaskellParser.DoubleDot, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	cname = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(CnameContext);
	    } else {
	        return this.getTypedRuleContext(CnameContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	tycls() {
	    return this.getTypedRuleContext(TyclsContext,0);
	};

	sig_vars() {
	    return this.getTypedRuleContext(Sig_varsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterHimport(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitHimport(this);
		}
	}


}



class CnameContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cname;
    }

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	con() {
	    return this.getTypedRuleContext(ConContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCname(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCname(this);
		}
	}


}



class FixityContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fixity;
    }

	INFIX() {
	    return this.getToken(HaskellParser.INFIX, 0);
	};

	INFIXL() {
	    return this.getToken(HaskellParser.INFIXL, 0);
	};

	INFIXR() {
	    return this.getToken(HaskellParser.INFIXR, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFixity(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFixity(this);
		}
	}


}



class OpsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ops;
    }

	op = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(OpContext);
	    } else {
	        return this.getTypedRuleContext(OpContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOps(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOps(this);
		}
	}


}



class TopdeclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_topdecls;
    }

	topdecl = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TopdeclContext);
	    } else {
	        return this.getTypedRuleContext(TopdeclContext,i);
	    }
	};

	NEWLINE = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.NEWLINE);
	    } else {
	        return this.getToken(HaskellParser.NEWLINE, i);
	    }
	};


	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTopdecls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTopdecls(this);
		}
	}


}



class TopdeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_topdecl;
    }

	cl_decl() {
	    return this.getTypedRuleContext(Cl_declContext,0);
	};

	ty_decl() {
	    return this.getTypedRuleContext(Ty_declContext,0);
	};

	standalone_kind_sig() {
	    return this.getTypedRuleContext(Standalone_kind_sigContext,0);
	};

	inst_decl() {
	    return this.getTypedRuleContext(Inst_declContext,0);
	};

	standalone_deriving() {
	    return this.getTypedRuleContext(Standalone_derivingContext,0);
	};

	role_annot() {
	    return this.getTypedRuleContext(Role_annotContext,0);
	};

	DEFAULT() {
	    return this.getToken(HaskellParser.DEFAULT, 0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	comma_types() {
	    return this.getTypedRuleContext(Comma_typesContext,0);
	};

	FOREIGN() {
	    return this.getToken(HaskellParser.FOREIGN, 0);
	};

	fdecl() {
	    return this.getTypedRuleContext(FdeclContext,0);
	};

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	DEPRECATED() {
	    return this.getToken(HaskellParser.DEPRECATED, 0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	deprecations() {
	    return this.getTypedRuleContext(DeprecationsContext,0);
	};

	WARNING() {
	    return this.getToken(HaskellParser.WARNING, 0);
	};

	warnings() {
	    return this.getTypedRuleContext(WarningsContext,0);
	};

	RULES() {
	    return this.getToken(HaskellParser.RULES, 0);
	};

	rules() {
	    return this.getTypedRuleContext(RulesContext,0);
	};

	annotation() {
	    return this.getTypedRuleContext(AnnotationContext,0);
	};

	decl_no_th() {
	    return this.getTypedRuleContext(Decl_no_thContext,0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTopdecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTopdecl(this);
		}
	}


}



class Cl_declContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cl_decl;
    }

	CLASS() {
	    return this.getToken(HaskellParser.CLASS, 0);
	};

	tycl_hdr() {
	    return this.getTypedRuleContext(Tycl_hdrContext,0);
	};

	fds() {
	    return this.getTypedRuleContext(FdsContext,0);
	};

	where_cls() {
	    return this.getTypedRuleContext(Where_clsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCl_decl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCl_decl(this);
		}
	}


}



class Ty_declContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ty_decl;
    }

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	ktypedoc() {
	    return this.getTypedRuleContext(KtypedocContext,0);
	};

	FAMILY() {
	    return this.getToken(HaskellParser.FAMILY, 0);
	};

	opt_tyfam_kind_sig() {
	    return this.getTypedRuleContext(Opt_tyfam_kind_sigContext,0);
	};

	opt_injective_info() {
	    return this.getTypedRuleContext(Opt_injective_infoContext,0);
	};

	where_type_family() {
	    return this.getTypedRuleContext(Where_type_familyContext,0);
	};

	DATA() {
	    return this.getToken(HaskellParser.DATA, 0);
	};

	tycl_hdr() {
	    return this.getTypedRuleContext(Tycl_hdrContext,0);
	};

	constrs() {
	    return this.getTypedRuleContext(ConstrsContext,0);
	};

	capi_ctype() {
	    return this.getTypedRuleContext(Capi_ctypeContext,0);
	};

	derivings() {
	    return this.getTypedRuleContext(DerivingsContext,0);
	};

	NEWTYPE() {
	    return this.getToken(HaskellParser.NEWTYPE, 0);
	};

	opt_kind_sig() {
	    return this.getTypedRuleContext(Opt_kind_sigContext,0);
	};

	gadt_constrlist() {
	    return this.getTypedRuleContext(Gadt_constrlistContext,0);
	};

	opt_datafam_kind_sig() {
	    return this.getTypedRuleContext(Opt_datafam_kind_sigContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTy_decl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTy_decl(this);
		}
	}


}



class Standalone_kind_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_standalone_kind_sig;
    }

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	sks_vars() {
	    return this.getTypedRuleContext(Sks_varsContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	ktypedoc() {
	    return this.getTypedRuleContext(KtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStandalone_kind_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStandalone_kind_sig(this);
		}
	}


}



class Sks_varsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sks_vars;
    }

	oqtycon = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(OqtyconContext);
	    } else {
	        return this.getTypedRuleContext(OqtyconContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSks_vars(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSks_vars(this);
		}
	}


}



class Inst_declContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_inst_decl;
    }

	INSTANCE() {
	    return this.getToken(HaskellParser.INSTANCE, 0);
	};

	inst_type() {
	    return this.getTypedRuleContext(Inst_typeContext,0);
	};

	overlap_pragma() {
	    return this.getTypedRuleContext(Overlap_pragmaContext,0);
	};

	where_inst() {
	    return this.getTypedRuleContext(Where_instContext,0);
	};

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	ty_fam_inst_eqn() {
	    return this.getTypedRuleContext(Ty_fam_inst_eqnContext,0);
	};

	DATA() {
	    return this.getToken(HaskellParser.DATA, 0);
	};

	tycl_hdr_inst() {
	    return this.getTypedRuleContext(Tycl_hdr_instContext,0);
	};

	capi_ctype() {
	    return this.getTypedRuleContext(Capi_ctypeContext,0);
	};

	derivings() {
	    return this.getTypedRuleContext(DerivingsContext,0);
	};

	NEWTYPE() {
	    return this.getToken(HaskellParser.NEWTYPE, 0);
	};

	opt_kind_sig() {
	    return this.getTypedRuleContext(Opt_kind_sigContext,0);
	};

	gadt_constrlist() {
	    return this.getTypedRuleContext(Gadt_constrlistContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInst_decl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInst_decl(this);
		}
	}


}



class Overlap_pragmaContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_overlap_pragma;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	OVERLAPPABLE() {
	    return this.getToken(HaskellParser.OVERLAPPABLE, 0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	OVERLAPPING() {
	    return this.getToken(HaskellParser.OVERLAPPING, 0);
	};

	OVERLAPS() {
	    return this.getToken(HaskellParser.OVERLAPS, 0);
	};

	INCOHERENT() {
	    return this.getToken(HaskellParser.INCOHERENT, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOverlap_pragma(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOverlap_pragma(this);
		}
	}


}



class Deriv_strategy_no_viaContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriv_strategy_no_via;
    }

	STOCK() {
	    return this.getToken(HaskellParser.STOCK, 0);
	};

	ANYCLASS() {
	    return this.getToken(HaskellParser.ANYCLASS, 0);
	};

	NEWTYPE() {
	    return this.getToken(HaskellParser.NEWTYPE, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriv_strategy_no_via(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriv_strategy_no_via(this);
		}
	}


}



class Deriv_strategy_viaContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriv_strategy_via;
    }

	VIA() {
	    return this.getToken(HaskellParser.VIA, 0);
	};

	ktype() {
	    return this.getTypedRuleContext(KtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriv_strategy_via(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriv_strategy_via(this);
		}
	}


}



class Deriv_standalone_strategyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriv_standalone_strategy;
    }

	STOCK() {
	    return this.getToken(HaskellParser.STOCK, 0);
	};

	ANYCLASS() {
	    return this.getToken(HaskellParser.ANYCLASS, 0);
	};

	NEWTYPE() {
	    return this.getToken(HaskellParser.NEWTYPE, 0);
	};

	deriv_strategy_via() {
	    return this.getTypedRuleContext(Deriv_strategy_viaContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriv_standalone_strategy(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriv_standalone_strategy(this);
		}
	}


}



class Opt_injective_infoContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_injective_info;
    }

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	injectivity_cond() {
	    return this.getTypedRuleContext(Injectivity_condContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_injective_info(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_injective_info(this);
		}
	}


}



class Injectivity_condContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_injectivity_cond;
    }

	tyvarid() {
	    return this.getTypedRuleContext(TyvaridContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	inj_varids() {
	    return this.getTypedRuleContext(Inj_varidsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInjectivity_cond(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInjectivity_cond(this);
		}
	}


}



class Inj_varidsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_inj_varids;
    }

	tyvarid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TyvaridContext);
	    } else {
	        return this.getTypedRuleContext(TyvaridContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInj_varids(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInj_varids(this);
		}
	}


}



class Where_type_familyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_where_type_family;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	ty_fam_inst_eqn_list() {
	    return this.getTypedRuleContext(Ty_fam_inst_eqn_listContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWhere_type_family(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWhere_type_family(this);
		}
	}


}



class Ty_fam_inst_eqn_listContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ty_fam_inst_eqn_list;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	ty_fam_inst_eqns() {
	    return this.getTypedRuleContext(Ty_fam_inst_eqnsContext,0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	DoubleDot() {
	    return this.getToken(HaskellParser.DoubleDot, 0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTy_fam_inst_eqn_list(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTy_fam_inst_eqn_list(this);
		}
	}


}



class Ty_fam_inst_eqnsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ty_fam_inst_eqns;
    }

	ty_fam_inst_eqn = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Ty_fam_inst_eqnContext);
	    } else {
	        return this.getTypedRuleContext(Ty_fam_inst_eqnContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTy_fam_inst_eqns(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTy_fam_inst_eqns(this);
		}
	}


}



class Ty_fam_inst_eqnContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ty_fam_inst_eqn;
    }

	FORALL() {
	    return this.getToken(HaskellParser.FORALL, 0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	ktype() {
	    return this.getTypedRuleContext(KtypeContext,0);
	};

	tv_bndrs() {
	    return this.getTypedRuleContext(Tv_bndrsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTy_fam_inst_eqn(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTy_fam_inst_eqn(this);
		}
	}


}



class At_decl_clsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_at_decl_cls;
    }

	DATA() {
	    return this.getToken(HaskellParser.DATA, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	FAMILY() {
	    return this.getToken(HaskellParser.FAMILY, 0);
	};

	opt_datafam_kind_sig() {
	    return this.getTypedRuleContext(Opt_datafam_kind_sigContext,0);
	};

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	opt_at_kind_inj_sig() {
	    return this.getTypedRuleContext(Opt_at_kind_inj_sigContext,0);
	};

	ty_fam_inst_eqn() {
	    return this.getTypedRuleContext(Ty_fam_inst_eqnContext,0);
	};

	INSTANCE() {
	    return this.getToken(HaskellParser.INSTANCE, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAt_decl_cls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAt_decl_cls(this);
		}
	}


}



class At_decl_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_at_decl_inst;
    }

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	ty_fam_inst_eqn() {
	    return this.getTypedRuleContext(Ty_fam_inst_eqnContext,0);
	};

	INSTANCE() {
	    return this.getToken(HaskellParser.INSTANCE, 0);
	};

	DATA() {
	    return this.getToken(HaskellParser.DATA, 0);
	};

	tycl_hdr_inst() {
	    return this.getTypedRuleContext(Tycl_hdr_instContext,0);
	};

	constrs() {
	    return this.getTypedRuleContext(ConstrsContext,0);
	};

	capi_ctype() {
	    return this.getTypedRuleContext(Capi_ctypeContext,0);
	};

	derivings() {
	    return this.getTypedRuleContext(DerivingsContext,0);
	};

	NEWTYPE() {
	    return this.getToken(HaskellParser.NEWTYPE, 0);
	};

	opt_kind_sig() {
	    return this.getTypedRuleContext(Opt_kind_sigContext,0);
	};

	gadt_constrlist() {
	    return this.getTypedRuleContext(Gadt_constrlistContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAt_decl_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAt_decl_inst(this);
		}
	}


}



class Opt_kind_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_kind_sig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_kind_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_kind_sig(this);
		}
	}


}



class Opt_datafam_kind_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_datafam_kind_sig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_datafam_kind_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_datafam_kind_sig(this);
		}
	}


}



class Opt_tyfam_kind_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_tyfam_kind_sig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	tv_bndr() {
	    return this.getTypedRuleContext(Tv_bndrContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_tyfam_kind_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_tyfam_kind_sig(this);
		}
	}


}



class Opt_at_kind_inj_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_at_kind_inj_sig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	tv_bndr_no_braces() {
	    return this.getTypedRuleContext(Tv_bndr_no_bracesContext,0);
	};

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	injectivity_cond() {
	    return this.getTypedRuleContext(Injectivity_condContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_at_kind_inj_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_at_kind_inj_sig(this);
		}
	}


}



class Tycl_hdrContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tycl_hdr;
    }

	tycl_context() {
	    return this.getTypedRuleContext(Tycl_contextContext,0);
	};

	DoubleArrow() {
	    return this.getToken(HaskellParser.DoubleArrow, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTycl_hdr(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTycl_hdr(this);
		}
	}


}



class Tycl_hdr_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tycl_hdr_inst;
    }

	FORALL() {
	    return this.getToken(HaskellParser.FORALL, 0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	tycl_context() {
	    return this.getTypedRuleContext(Tycl_contextContext,0);
	};

	DoubleArrow() {
	    return this.getToken(HaskellParser.DoubleArrow, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	tv_bndrs() {
	    return this.getTypedRuleContext(Tv_bndrsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTycl_hdr_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTycl_hdr_inst(this);
		}
	}


}



class Capi_ctypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_capi_ctype;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	CTYPE() {
	    return this.getToken(HaskellParser.CTYPE, 0);
	};

	STRING = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.STRING);
	    } else {
	        return this.getToken(HaskellParser.STRING, i);
	    }
	};


	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCapi_ctype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCapi_ctype(this);
		}
	}


}



class Standalone_derivingContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_standalone_deriving;
    }

	DERIVING() {
	    return this.getToken(HaskellParser.DERIVING, 0);
	};

	INSTANCE() {
	    return this.getToken(HaskellParser.INSTANCE, 0);
	};

	inst_type() {
	    return this.getTypedRuleContext(Inst_typeContext,0);
	};

	deriv_standalone_strategy() {
	    return this.getTypedRuleContext(Deriv_standalone_strategyContext,0);
	};

	overlap_pragma() {
	    return this.getTypedRuleContext(Overlap_pragmaContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStandalone_deriving(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStandalone_deriving(this);
		}
	}


}



class Role_annotContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_role_annot;
    }

	TYPE() {
	    return this.getToken(HaskellParser.TYPE, 0);
	};

	ROLE() {
	    return this.getToken(HaskellParser.ROLE, 0);
	};

	oqtycon() {
	    return this.getTypedRuleContext(OqtyconContext,0);
	};

	roles() {
	    return this.getTypedRuleContext(RolesContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRole_annot(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRole_annot(this);
		}
	}


}



class RolesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_roles;
    }

	role = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(RoleContext);
	    } else {
	        return this.getTypedRuleContext(RoleContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRoles(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRoles(this);
		}
	}


}



class RoleContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_role;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	WILDCARD() {
	    return this.getToken(HaskellParser.WILDCARD, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRole(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRole(this);
		}
	}


}



class Pattern_synonym_declContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pattern_synonym_decl;
    }

	PATTERN() {
	    return this.getToken(HaskellParser.PATTERN, 0);
	};

	pattern_synonym_lhs() {
	    return this.getTypedRuleContext(Pattern_synonym_lhsContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	pat() {
	    return this.getTypedRuleContext(PatContext,0);
	};

	Revarrow() {
	    return this.getToken(HaskellParser.Revarrow, 0);
	};

	where_decls() {
	    return this.getTypedRuleContext(Where_declsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPattern_synonym_decl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPattern_synonym_decl(this);
		}
	}


}



class Pattern_synonym_lhsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pattern_synonym_lhs;
    }

	con() {
	    return this.getTypedRuleContext(ConContext,0);
	};

	vars_() {
	    return this.getTypedRuleContext(Vars_Context,0);
	};

	varid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(VaridContext);
	    } else {
	        return this.getTypedRuleContext(VaridContext,i);
	    }
	};

	conop() {
	    return this.getTypedRuleContext(ConopContext,0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	cvars() {
	    return this.getTypedRuleContext(CvarsContext,0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPattern_synonym_lhs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPattern_synonym_lhs(this);
		}
	}


}



class Vars_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_vars_;
    }

	varid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(VaridContext);
	    } else {
	        return this.getTypedRuleContext(VaridContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVars_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVars_(this);
		}
	}


}



class CvarsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cvars;
    }

	var_ = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Var_Context);
	    } else {
	        return this.getTypedRuleContext(Var_Context,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCvars(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCvars(this);
		}
	}


}



class Where_declsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_where_decls;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	decls() {
	    return this.getTypedRuleContext(DeclsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWhere_decls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWhere_decls(this);
		}
	}


}



class Pattern_synonym_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pattern_synonym_sig;
    }

	PATTERN() {
	    return this.getToken(HaskellParser.PATTERN, 0);
	};

	con_list() {
	    return this.getTypedRuleContext(Con_listContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtypedoc() {
	    return this.getTypedRuleContext(SigtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPattern_synonym_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPattern_synonym_sig(this);
		}
	}


}



class Decl_clsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decl_cls;
    }

	at_decl_cls() {
	    return this.getTypedRuleContext(At_decl_clsContext,0);
	};

	decl() {
	    return this.getTypedRuleContext(DeclContext,0);
	};

	DEFAULT() {
	    return this.getToken(HaskellParser.DEFAULT, 0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtypedoc() {
	    return this.getTypedRuleContext(SigtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecl_cls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecl_cls(this);
		}
	}


}



class Decls_clsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decls_cls;
    }

	decl_cls = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Decl_clsContext);
	    } else {
	        return this.getTypedRuleContext(Decl_clsContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecls_cls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecls_cls(this);
		}
	}


}



class Decllist_clsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decllist_cls;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	decls_cls() {
	    return this.getTypedRuleContext(Decls_clsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecllist_cls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecllist_cls(this);
		}
	}


}



class Where_clsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_where_cls;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	decllist_cls() {
	    return this.getTypedRuleContext(Decllist_clsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWhere_cls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWhere_cls(this);
		}
	}


}



class Decl_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decl_inst;
    }

	at_decl_inst() {
	    return this.getTypedRuleContext(At_decl_instContext,0);
	};

	decl() {
	    return this.getTypedRuleContext(DeclContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecl_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecl_inst(this);
		}
	}


}



class Decls_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decls_inst;
    }

	decl_inst = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Decl_instContext);
	    } else {
	        return this.getTypedRuleContext(Decl_instContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecls_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecls_inst(this);
		}
	}


}



class Decllist_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decllist_inst;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	decls_inst() {
	    return this.getTypedRuleContext(Decls_instContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecllist_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecllist_inst(this);
		}
	}


}



class Where_instContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_where_inst;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	decllist_inst() {
	    return this.getTypedRuleContext(Decllist_instContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWhere_inst(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWhere_inst(this);
		}
	}


}



class DeclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decls;
    }

	decl = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(DeclContext);
	    } else {
	        return this.getTypedRuleContext(DeclContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecls(this);
		}
	}


}



class DecllistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decllist;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	decls() {
	    return this.getTypedRuleContext(DeclsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecllist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecllist(this);
		}
	}


}



class BindsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_binds;
    }

	decllist() {
	    return this.getTypedRuleContext(DecllistContext,0);
	};

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	dbinds() {
	    return this.getTypedRuleContext(DbindsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBinds(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBinds(this);
		}
	}


}



class WherebindsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_wherebinds;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	binds() {
	    return this.getTypedRuleContext(BindsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWherebinds(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWherebinds(this);
		}
	}


}



class RulesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rules;
    }

	pragma_rule = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Pragma_ruleContext);
	    } else {
	        return this.getTypedRuleContext(Pragma_ruleContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRules(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRules(this);
		}
	}


}



class Pragma_ruleContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pragma_rule;
    }

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	rule_activation() {
	    return this.getTypedRuleContext(Rule_activationContext,0);
	};

	rule_foralls() {
	    return this.getTypedRuleContext(Rule_forallsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPragma_rule(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPragma_rule(this);
		}
	}


}



class Rule_activation_markerContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rule_activation_marker;
    }

	Tilde() {
	    return this.getToken(HaskellParser.Tilde, 0);
	};

	varsym() {
	    return this.getTypedRuleContext(VarsymContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRule_activation_marker(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRule_activation_marker(this);
		}
	}


}



class Rule_activationContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rule_activation;
    }

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	rule_activation_marker() {
	    return this.getTypedRuleContext(Rule_activation_markerContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRule_activation(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRule_activation(this);
		}
	}


}



class Rule_forallsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rule_foralls;
    }

	FORALL = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.FORALL);
	    } else {
	        return this.getToken(HaskellParser.FORALL, i);
	    }
	};


	Dot = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Dot);
	    } else {
	        return this.getToken(HaskellParser.Dot, i);
	    }
	};


	rule_vars = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Rule_varsContext);
	    } else {
	        return this.getTypedRuleContext(Rule_varsContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRule_foralls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRule_foralls(this);
		}
	}


}



class Rule_varsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rule_vars;
    }

	rule_var = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Rule_varContext);
	    } else {
	        return this.getTypedRuleContext(Rule_varContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRule_vars(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRule_vars(this);
		}
	}


}



class Rule_varContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rule_var;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRule_var(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRule_var(this);
		}
	}


}



class WarningsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_warnings;
    }

	pragma_warning = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Pragma_warningContext);
	    } else {
	        return this.getTypedRuleContext(Pragma_warningContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterWarnings(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitWarnings(this);
		}
	}


}



class Pragma_warningContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pragma_warning;
    }

	namelist() {
	    return this.getTypedRuleContext(NamelistContext,0);
	};

	strings() {
	    return this.getTypedRuleContext(StringsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPragma_warning(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPragma_warning(this);
		}
	}


}



class DeprecationsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deprecations;
    }

	pragma_deprecation = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Pragma_deprecationContext);
	    } else {
	        return this.getTypedRuleContext(Pragma_deprecationContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeprecations(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeprecations(this);
		}
	}


}



class Pragma_deprecationContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pragma_deprecation;
    }

	namelist() {
	    return this.getTypedRuleContext(NamelistContext,0);
	};

	strings() {
	    return this.getTypedRuleContext(StringsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPragma_deprecation(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPragma_deprecation(this);
		}
	}


}



class StringsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_strings;
    }

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	stringlist() {
	    return this.getTypedRuleContext(StringlistContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStrings(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStrings(this);
		}
	}


}



class StringlistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_stringlist;
    }

	pstring = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(PstringContext);
	    } else {
	        return this.getTypedRuleContext(PstringContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStringlist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStringlist(this);
		}
	}


}



class AnnotationContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_annotation;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	ANN() {
	    return this.getToken(HaskellParser.ANN, 0);
	};

	name_var() {
	    return this.getTypedRuleContext(Name_varContext,0);
	};

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	tycon() {
	    return this.getTypedRuleContext(TyconContext,0);
	};

	MODULE() {
	    return this.getToken(HaskellParser.MODULE, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAnnotation(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAnnotation(this);
		}
	}


}



class FdeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fdecl;
    }

	IMPORT() {
	    return this.getToken(HaskellParser.IMPORT, 0);
	};

	callconv() {
	    return this.getTypedRuleContext(CallconvContext,0);
	};

	fspec() {
	    return this.getTypedRuleContext(FspecContext,0);
	};

	safety() {
	    return this.getTypedRuleContext(SafetyContext,0);
	};

	EXPORT() {
	    return this.getToken(HaskellParser.EXPORT, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFdecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFdecl(this);
		}
	}


}



class CallconvContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_callconv;
    }

	CCALL() {
	    return this.getToken(HaskellParser.CCALL, 0);
	};

	STDCALL() {
	    return this.getToken(HaskellParser.STDCALL, 0);
	};

	CPPCALL() {
	    return this.getToken(HaskellParser.CPPCALL, 0);
	};

	JSCALL() {
	    return this.getToken(HaskellParser.JSCALL, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCallconv(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCallconv(this);
		}
	}


}



class SafetyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_safety;
    }

	UNSAFE() {
	    return this.getToken(HaskellParser.UNSAFE, 0);
	};

	SAFE() {
	    return this.getToken(HaskellParser.SAFE, 0);
	};

	INTERRUPTIBLE() {
	    return this.getToken(HaskellParser.INTERRUPTIBLE, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSafety(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSafety(this);
		}
	}


}



class FspecContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fspec;
    }

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtypedoc() {
	    return this.getTypedRuleContext(SigtypedocContext,0);
	};

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFspec(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFspec(this);
		}
	}


}



class Opt_sigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_sig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtype() {
	    return this.getTypedRuleContext(SigtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_sig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_sig(this);
		}
	}


}



class Opt_tyconsigContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_opt_tyconsig;
    }

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	gtycon() {
	    return this.getTypedRuleContext(GtyconContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpt_tyconsig(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpt_tyconsig(this);
		}
	}


}



class SigtypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sigtype;
    }

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSigtype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSigtype(this);
		}
	}


}



class SigtypedocContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sigtypedoc;
    }

	ctypedoc() {
	    return this.getTypedRuleContext(CtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSigtypedoc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSigtypedoc(this);
		}
	}


}



class Sig_varsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sig_vars;
    }

	var_ = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Var_Context);
	    } else {
	        return this.getTypedRuleContext(Var_Context,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSig_vars(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSig_vars(this);
		}
	}


}



class Sigtypes1Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sigtypes1;
    }

	sigtype = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SigtypeContext);
	    } else {
	        return this.getTypedRuleContext(SigtypeContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSigtypes1(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSigtypes1(this);
		}
	}


}



class UnpackednessContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_unpackedness;
    }

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	UNPACK() {
	    return this.getToken(HaskellParser.UNPACK, 0);
	};

	ClosePragmaBracket() {
	    return this.getToken(HaskellParser.ClosePragmaBracket, 0);
	};

	NOUNPACK() {
	    return this.getToken(HaskellParser.NOUNPACK, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterUnpackedness(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitUnpackedness(this);
		}
	}


}



class Forall_vis_flagContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_forall_vis_flag;
    }

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterForall_vis_flag(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitForall_vis_flag(this);
		}
	}


}



class KtypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ktype;
    }

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterKtype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitKtype(this);
		}
	}


}



class KtypedocContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ktypedoc;
    }

	ctypedoc() {
	    return this.getTypedRuleContext(CtypedocContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterKtypedoc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitKtypedoc(this);
		}
	}


}



class CtypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ctype;
    }

	FORALL() {
	    return this.getToken(HaskellParser.FORALL, 0);
	};

	forall_vis_flag() {
	    return this.getTypedRuleContext(Forall_vis_flagContext,0);
	};

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	tv_bndrs() {
	    return this.getTypedRuleContext(Tv_bndrsContext,0);
	};

	btype() {
	    return this.getTypedRuleContext(BtypeContext,0);
	};

	DoubleArrow() {
	    return this.getToken(HaskellParser.DoubleArrow, 0);
	};

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCtype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCtype(this);
		}
	}


}



class CtypedocContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ctypedoc;
    }

	FORALL() {
	    return this.getToken(HaskellParser.FORALL, 0);
	};

	forall_vis_flag() {
	    return this.getTypedRuleContext(Forall_vis_flagContext,0);
	};

	ctypedoc() {
	    return this.getTypedRuleContext(CtypedocContext,0);
	};

	tv_bndrs() {
	    return this.getTypedRuleContext(Tv_bndrsContext,0);
	};

	tycl_context() {
	    return this.getTypedRuleContext(Tycl_contextContext,0);
	};

	DoubleArrow() {
	    return this.getToken(HaskellParser.DoubleArrow, 0);
	};

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	type_() {
	    return this.getTypedRuleContext(Type_Context,0);
	};

	typedoc() {
	    return this.getTypedRuleContext(TypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCtypedoc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCtypedoc(this);
		}
	}


}



class Tycl_contextContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tycl_context;
    }

	btype() {
	    return this.getTypedRuleContext(BtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTycl_context(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTycl_context(this);
		}
	}


}



class Constr_contextContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr_context;
    }

	constr_btype() {
	    return this.getTypedRuleContext(Constr_btypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr_context(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr_context(this);
		}
	}


}



class Type_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_type_;
    }

	btype() {
	    return this.getTypedRuleContext(BtypeContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterType_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitType_(this);
		}
	}


}



class TypedocContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_typedoc;
    }

	btype() {
	    return this.getTypedRuleContext(BtypeContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	ctypedoc() {
	    return this.getTypedRuleContext(CtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTypedoc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTypedoc(this);
		}
	}


}



class Constr_btypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr_btype;
    }

	constr_tyapps() {
	    return this.getTypedRuleContext(Constr_tyappsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr_btype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr_btype(this);
		}
	}


}



class Constr_tyappsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr_tyapps;
    }

	constr_tyapp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Constr_tyappContext);
	    } else {
	        return this.getTypedRuleContext(Constr_tyappContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr_tyapps(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr_tyapps(this);
		}
	}


}



class Constr_tyappContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr_tyapp;
    }

	tyapp() {
	    return this.getTypedRuleContext(TyappContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr_tyapp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr_tyapp(this);
		}
	}


}



class BtypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_btype;
    }

	tyapps() {
	    return this.getTypedRuleContext(TyappsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBtype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBtype(this);
		}
	}


}



class TyappsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyapps;
    }

	tyapp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TyappContext);
	    } else {
	        return this.getTypedRuleContext(TyappContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyapps(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyapps(this);
		}
	}


}



class TyappContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyapp;
    }

	atype() {
	    return this.getTypedRuleContext(AtypeContext,0);
	};

	Atsign() {
	    return this.getToken(HaskellParser.Atsign, 0);
	};

	qtyconop() {
	    return this.getTypedRuleContext(QtyconopContext,0);
	};

	tyvarop() {
	    return this.getTypedRuleContext(TyvaropContext,0);
	};

	Quote() {
	    return this.getToken(HaskellParser.Quote, 0);
	};

	qconop() {
	    return this.getTypedRuleContext(QconopContext,0);
	};

	varop() {
	    return this.getTypedRuleContext(VaropContext,0);
	};

	unpackedness() {
	    return this.getTypedRuleContext(UnpackednessContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyapp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyapp(this);
		}
	}


}



class AtypeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_atype;
    }

	ntgtycon() {
	    return this.getTypedRuleContext(NtgtyconContext,0);
	};

	tyvar() {
	    return this.getTypedRuleContext(TyvarContext,0);
	};

	Asterisk() {
	    return this.getToken(HaskellParser.Asterisk, 0);
	};

	Tilde() {
	    return this.getToken(HaskellParser.Tilde, 0);
	};

	atype() {
	    return this.getTypedRuleContext(AtypeContext,0);
	};

	Bang() {
	    return this.getToken(HaskellParser.Bang, 0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	fielddecls() {
	    return this.getTypedRuleContext(FielddeclsContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	ktype() {
	    return this.getTypedRuleContext(KtypeContext,0);
	};

	Comma() {
	    return this.getToken(HaskellParser.Comma, 0);
	};

	comma_types() {
	    return this.getTypedRuleContext(Comma_typesContext,0);
	};

	OpenBoxParen() {
	    return this.getToken(HaskellParser.OpenBoxParen, 0);
	};

	CloseBoxParen() {
	    return this.getToken(HaskellParser.CloseBoxParen, 0);
	};

	bar_types2() {
	    return this.getTypedRuleContext(Bar_types2Context,0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	quasiquote() {
	    return this.getTypedRuleContext(QuasiquoteContext,0);
	};

	splice_untyped() {
	    return this.getTypedRuleContext(Splice_untypedContext,0);
	};

	Quote() {
	    return this.getToken(HaskellParser.Quote, 0);
	};

	qcon_nowiredlist() {
	    return this.getTypedRuleContext(Qcon_nowiredlistContext,0);
	};

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	WILDCARD() {
	    return this.getToken(HaskellParser.WILDCARD, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAtype(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAtype(this);
		}
	}


}



class Inst_typeContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_inst_type;
    }

	sigtype() {
	    return this.getTypedRuleContext(SigtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInst_type(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInst_type(this);
		}
	}


}



class Deriv_typesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriv_types;
    }

	ktypedoc = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(KtypedocContext);
	    } else {
	        return this.getTypedRuleContext(KtypedocContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriv_types(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriv_types(this);
		}
	}


}



class Comma_typesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_comma_types;
    }

	ktype = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(KtypeContext);
	    } else {
	        return this.getTypedRuleContext(KtypeContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterComma_types(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitComma_types(this);
		}
	}


}



class Bar_types2Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_bar_types2;
    }

	ktype = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(KtypeContext);
	    } else {
	        return this.getTypedRuleContext(KtypeContext,i);
	    }
	};

	Pipe = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Pipe);
	    } else {
	        return this.getToken(HaskellParser.Pipe, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBar_types2(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBar_types2(this);
		}
	}


}



class Tv_bndrsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tv_bndrs;
    }

	tv_bndr = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Tv_bndrContext);
	    } else {
	        return this.getTypedRuleContext(Tv_bndrContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTv_bndrs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTv_bndrs(this);
		}
	}


}



class Tv_bndrContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tv_bndr;
    }

	tv_bndr_no_braces() {
	    return this.getTypedRuleContext(Tv_bndr_no_bracesContext,0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	tyvar() {
	    return this.getTypedRuleContext(TyvarContext,0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTv_bndr(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTv_bndr(this);
		}
	}


}



class Tv_bndr_no_bracesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tv_bndr_no_braces;
    }

	tyvar() {
	    return this.getTypedRuleContext(TyvarContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	kind() {
	    return this.getTypedRuleContext(KindContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTv_bndr_no_braces(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTv_bndr_no_braces(this);
		}
	}


}



class FdsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fds;
    }

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	fds1() {
	    return this.getTypedRuleContext(Fds1Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFds(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFds(this);
		}
	}


}



class Fds1Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fds1;
    }

	fd = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(FdContext);
	    } else {
	        return this.getTypedRuleContext(FdContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFds1(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFds1(this);
		}
	}


}



class FdContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fd;
    }

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	varids0 = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Varids0Context);
	    } else {
	        return this.getTypedRuleContext(Varids0Context,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFd(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFd(this);
		}
	}


}



class Varids0Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_varids0;
    }

	tyvar = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TyvarContext);
	    } else {
	        return this.getTypedRuleContext(TyvarContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVarids0(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVarids0(this);
		}
	}


}



class KindContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_kind;
    }

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterKind(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitKind(this);
		}
	}


}



class Gadt_constrlistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gadt_constrlist;
    }

	WHERE() {
	    return this.getToken(HaskellParser.WHERE, 0);
	};

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	gadt_constrs() {
	    return this.getTypedRuleContext(Gadt_constrsContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGadt_constrlist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGadt_constrlist(this);
		}
	}


}



class Gadt_constrsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gadt_constrs;
    }

	gadt_constr_with_doc = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Gadt_constr_with_docContext);
	    } else {
	        return this.getTypedRuleContext(Gadt_constr_with_docContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGadt_constrs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGadt_constrs(this);
		}
	}


}



class Gadt_constr_with_docContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gadt_constr_with_doc;
    }

	gadt_constr() {
	    return this.getTypedRuleContext(Gadt_constrContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGadt_constr_with_doc(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGadt_constr_with_doc(this);
		}
	}


}



class Gadt_constrContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gadt_constr;
    }

	con_list() {
	    return this.getTypedRuleContext(Con_listContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtypedoc() {
	    return this.getTypedRuleContext(SigtypedocContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGadt_constr(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGadt_constr(this);
		}
	}


}



class ConstrsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constrs;
    }

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	constrs1() {
	    return this.getTypedRuleContext(Constrs1Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstrs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstrs(this);
		}
	}


}



class Constrs1Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constrs1;
    }

	constr = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ConstrContext);
	    } else {
	        return this.getTypedRuleContext(ConstrContext,i);
	    }
	};

	Pipe = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Pipe);
	    } else {
	        return this.getToken(HaskellParser.Pipe, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstrs1(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstrs1(this);
		}
	}


}



class ConstrContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr;
    }

	constr_stuff() {
	    return this.getTypedRuleContext(Constr_stuffContext,0);
	};

	forall() {
	    return this.getTypedRuleContext(ForallContext,0);
	};

	constr_context() {
	    return this.getTypedRuleContext(Constr_contextContext,0);
	};

	DoubleArrow() {
	    return this.getToken(HaskellParser.DoubleArrow, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr(this);
		}
	}


}



class ForallContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_forall;
    }

	FORALL() {
	    return this.getToken(HaskellParser.FORALL, 0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	tv_bndrs() {
	    return this.getTypedRuleContext(Tv_bndrsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterForall(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitForall(this);
		}
	}


}



class Constr_stuffContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_constr_stuff;
    }

	constr_tyapps() {
	    return this.getTypedRuleContext(Constr_tyappsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConstr_stuff(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConstr_stuff(this);
		}
	}


}



class FielddeclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fielddecls;
    }

	fielddecl = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(FielddeclContext);
	    } else {
	        return this.getTypedRuleContext(FielddeclContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFielddecls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFielddecls(this);
		}
	}


}



class FielddeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fielddecl;
    }

	sig_vars() {
	    return this.getTypedRuleContext(Sig_varsContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	ctype() {
	    return this.getTypedRuleContext(CtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFielddecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFielddecl(this);
		}
	}


}



class DerivingsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_derivings;
    }

	deriving = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(DerivingContext);
	    } else {
	        return this.getTypedRuleContext(DerivingContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDerivings(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDerivings(this);
		}
	}


}



class DerivingContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriving;
    }

	DERIVING() {
	    return this.getToken(HaskellParser.DERIVING, 0);
	};

	deriv_clause_types() {
	    return this.getTypedRuleContext(Deriv_clause_typesContext,0);
	};

	deriv_strategy_no_via() {
	    return this.getTypedRuleContext(Deriv_strategy_no_viaContext,0);
	};

	deriv_strategy_via() {
	    return this.getTypedRuleContext(Deriv_strategy_viaContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriving(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriving(this);
		}
	}


}



class Deriv_clause_typesContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_deriv_clause_types;
    }

	qtycon() {
	    return this.getTypedRuleContext(QtyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	deriv_types() {
	    return this.getTypedRuleContext(Deriv_typesContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDeriv_clause_types(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDeriv_clause_types(this);
		}
	}


}



class Decl_no_thContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decl_no_th;
    }

	sigdecl() {
	    return this.getTypedRuleContext(SigdeclContext,0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	rhs() {
	    return this.getTypedRuleContext(RhsContext,0);
	};

	opt_sig() {
	    return this.getTypedRuleContext(Opt_sigContext,0);
	};

	pattern_synonym_decl() {
	    return this.getTypedRuleContext(Pattern_synonym_declContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecl_no_th(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecl_no_th(this);
		}
	}


}



class DeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_decl;
    }

	decl_no_th() {
	    return this.getTypedRuleContext(Decl_no_thContext,0);
	};

	splice_exp() {
	    return this.getTypedRuleContext(Splice_expContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDecl(this);
		}
	}


}



class RhsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_rhs;
    }

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	wherebinds() {
	    return this.getTypedRuleContext(WherebindsContext,0);
	};

	gdrhs() {
	    return this.getTypedRuleContext(GdrhsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRhs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRhs(this);
		}
	}


}



class GdrhsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gdrhs;
    }

	gdrh = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(GdrhContext);
	    } else {
	        return this.getTypedRuleContext(GdrhContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGdrhs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGdrhs(this);
		}
	}


}



class GdrhContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gdrh;
    }

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	guards() {
	    return this.getTypedRuleContext(GuardsContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGdrh(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGdrh(this);
		}
	}


}



class SigdeclContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sigdecl;
    }

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtypedoc() {
	    return this.getTypedRuleContext(SigtypedocContext,0);
	};

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	Comma() {
	    return this.getToken(HaskellParser.Comma, 0);
	};

	sig_vars() {
	    return this.getTypedRuleContext(Sig_varsContext,0);
	};

	fixity() {
	    return this.getTypedRuleContext(FixityContext,0);
	};

	ops() {
	    return this.getTypedRuleContext(OpsContext,0);
	};

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	pattern_synonym_sig() {
	    return this.getTypedRuleContext(Pattern_synonym_sigContext,0);
	};

	OpenPragmaBracket() {
	    return this.getToken(HaskellParser.OpenPragmaBracket, 0);
	};

	COMPLETE() {
	    return this.getToken(HaskellParser.COMPLETE, 0);
	};

	con_list() {
	    return this.getTypedRuleContext(Con_listContext,0);
	};

	ClosePragmaBracket = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.ClosePragmaBracket);
	    } else {
	        return this.getToken(HaskellParser.ClosePragmaBracket, i);
	    }
	};


	opt_tyconsig() {
	    return this.getTypedRuleContext(Opt_tyconsigContext,0);
	};

	INLINE() {
	    return this.getToken(HaskellParser.INLINE, 0);
	};

	qvar() {
	    return this.getTypedRuleContext(QvarContext,0);
	};

	activation() {
	    return this.getTypedRuleContext(ActivationContext,0);
	};

	SCC() {
	    return this.getToken(HaskellParser.SCC, 0);
	};

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	SPECIALISE() {
	    return this.getToken(HaskellParser.SPECIALISE, 0);
	};

	sigtypes1() {
	    return this.getTypedRuleContext(Sigtypes1Context,0);
	};

	SPECINLINE() {
	    return this.getToken(HaskellParser.SPECINLINE, 0);
	};

	INSTANCE() {
	    return this.getToken(HaskellParser.INSTANCE, 0);
	};

	inst_type() {
	    return this.getTypedRuleContext(Inst_typeContext,0);
	};

	MINIMAL() {
	    return this.getToken(HaskellParser.MINIMAL, 0);
	};

	name_boolformula_opt() {
	    return this.getTypedRuleContext(Name_boolformula_optContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSigdecl(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSigdecl(this);
		}
	}


}



class ActivationContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_activation;
    }

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	rule_activation_marker() {
	    return this.getTypedRuleContext(Rule_activation_markerContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterActivation(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitActivation(this);
		}
	}


}



class Th_quasiquoteContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_th_quasiquote;
    }

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTh_quasiquote(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTh_quasiquote(this);
		}
	}


}



class Th_qquasiquoteContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_th_qquasiquote;
    }

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	qvarid() {
	    return this.getTypedRuleContext(QvaridContext,0);
	};

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTh_qquasiquote(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTh_qquasiquote(this);
		}
	}


}



class QuasiquoteContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_quasiquote;
    }

	th_quasiquote() {
	    return this.getTypedRuleContext(Th_quasiquoteContext,0);
	};

	th_qquasiquote() {
	    return this.getTypedRuleContext(Th_qquasiquoteContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQuasiquote(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQuasiquote(this);
		}
	}


}



class ExpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_exp;
    }

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	DoubleColon() {
	    return this.getToken(HaskellParser.DoubleColon, 0);
	};

	sigtype() {
	    return this.getTypedRuleContext(SigtypeContext,0);
	};

	LarrowTail() {
	    return this.getToken(HaskellParser.LarrowTail, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	RarrowTail() {
	    return this.getToken(HaskellParser.RarrowTail, 0);
	};

	LLarrowTail() {
	    return this.getToken(HaskellParser.LLarrowTail, 0);
	};

	RRarrowTail() {
	    return this.getToken(HaskellParser.RRarrowTail, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExp(this);
		}
	}


}



class InfixexpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_infixexp;
    }

	exp10() {
	    return this.getTypedRuleContext(Exp10Context,0);
	};

	qop = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(QopContext);
	    } else {
	        return this.getTypedRuleContext(QopContext,i);
	    }
	};

	exp10p = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Exp10pContext);
	    } else {
	        return this.getTypedRuleContext(Exp10pContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInfixexp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInfixexp(this);
		}
	}


}



class Exp10pContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_exp10p;
    }

	exp10() {
	    return this.getTypedRuleContext(Exp10Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExp10p(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExp10p(this);
		}
	}


}



class Exp10Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_exp10;
    }

	fexp() {
	    return this.getTypedRuleContext(FexpContext,0);
	};

	Minus() {
	    return this.getToken(HaskellParser.Minus, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterExp10(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitExp10(this);
		}
	}


}



class FexpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fexp;
    }

	aexp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(AexpContext);
	    } else {
	        return this.getTypedRuleContext(AexpContext,i);
	    }
	};

	Atsign() {
	    return this.getToken(HaskellParser.Atsign, 0);
	};

	atype() {
	    return this.getTypedRuleContext(AtypeContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFexp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFexp(this);
		}
	}


}



class AexpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_aexp;
    }

	qvar() {
	    return this.getTypedRuleContext(QvarContext,0);
	};

	Atsign() {
	    return this.getToken(HaskellParser.Atsign, 0);
	};

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	Tilde() {
	    return this.getToken(HaskellParser.Tilde, 0);
	};

	Bang() {
	    return this.getToken(HaskellParser.Bang, 0);
	};

	ReverseSlash() {
	    return this.getToken(HaskellParser.ReverseSlash, 0);
	};

	apats() {
	    return this.getTypedRuleContext(ApatsContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	exp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ExpContext);
	    } else {
	        return this.getTypedRuleContext(ExpContext,i);
	    }
	};

	LET() {
	    return this.getToken(HaskellParser.LET, 0);
	};

	decllist() {
	    return this.getTypedRuleContext(DecllistContext,0);
	};

	IN() {
	    return this.getToken(HaskellParser.IN, 0);
	};

	LCASE() {
	    return this.getToken(HaskellParser.LCASE, 0);
	};

	alts() {
	    return this.getTypedRuleContext(AltsContext,0);
	};

	IF() {
	    return this.getToken(HaskellParser.IF, 0);
	};

	THEN() {
	    return this.getToken(HaskellParser.THEN, 0);
	};

	ELSE() {
	    return this.getToken(HaskellParser.ELSE, 0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	ifgdpats() {
	    return this.getTypedRuleContext(IfgdpatsContext,0);
	};

	CASE() {
	    return this.getToken(HaskellParser.CASE, 0);
	};

	OF() {
	    return this.getToken(HaskellParser.OF, 0);
	};

	DO() {
	    return this.getToken(HaskellParser.DO, 0);
	};

	stmtlist() {
	    return this.getTypedRuleContext(StmtlistContext,0);
	};

	MDO() {
	    return this.getToken(HaskellParser.MDO, 0);
	};

	aexp1() {
	    return this.getTypedRuleContext(Aexp1Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAexp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAexp(this);
		}
	}


}



class Aexp1Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_aexp1;
    }

	aexp2() {
	    return this.getTypedRuleContext(Aexp2Context,0);
	};

	OCURLY = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.OCURLY);
	    } else {
	        return this.getToken(HaskellParser.OCURLY, i);
	    }
	};


	CCURLY = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.CCURLY);
	    } else {
	        return this.getToken(HaskellParser.CCURLY, i);
	    }
	};


	fbinds = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(FbindsContext);
	    } else {
	        return this.getTypedRuleContext(FbindsContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAexp1(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAexp1(this);
		}
	}


}



class Aexp2Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_aexp2;
    }

	qvar() {
	    return this.getTypedRuleContext(QvarContext,0);
	};

	qcon() {
	    return this.getTypedRuleContext(QconContext,0);
	};

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	literal() {
	    return this.getTypedRuleContext(LiteralContext,0);
	};

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	pfloat() {
	    return this.getTypedRuleContext(PfloatContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	texp() {
	    return this.getTypedRuleContext(TexpContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	tup_exprs() {
	    return this.getTypedRuleContext(Tup_exprsContext,0);
	};

	OpenBoxParen() {
	    return this.getToken(HaskellParser.OpenBoxParen, 0);
	};

	CloseBoxParen() {
	    return this.getToken(HaskellParser.CloseBoxParen, 0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	list_() {
	    return this.getTypedRuleContext(List_Context,0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	WILDCARD() {
	    return this.getToken(HaskellParser.WILDCARD, 0);
	};

	splice_untyped() {
	    return this.getTypedRuleContext(Splice_untypedContext,0);
	};

	splice_typed() {
	    return this.getTypedRuleContext(Splice_typedContext,0);
	};

	Quote() {
	    return this.getToken(HaskellParser.Quote, 0);
	};

	DoubleQuote() {
	    return this.getToken(HaskellParser.DoubleQuote, 0);
	};

	tyvar() {
	    return this.getTypedRuleContext(TyvarContext,0);
	};

	gtycon() {
	    return this.getTypedRuleContext(GtyconContext,0);
	};

	TopenExpQuote() {
	    return this.getToken(HaskellParser.TopenExpQuote, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	TcloseQoute() {
	    return this.getToken(HaskellParser.TcloseQoute, 0);
	};

	TopenTexpQuote() {
	    return this.getToken(HaskellParser.TopenTexpQuote, 0);
	};

	TcloseTExpQoute() {
	    return this.getToken(HaskellParser.TcloseTExpQoute, 0);
	};

	TopenTypQoute() {
	    return this.getToken(HaskellParser.TopenTypQoute, 0);
	};

	ktype() {
	    return this.getTypedRuleContext(KtypeContext,0);
	};

	TopenPatQuote() {
	    return this.getToken(HaskellParser.TopenPatQuote, 0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	TopenDecQoute() {
	    return this.getToken(HaskellParser.TopenDecQoute, 0);
	};

	cvtopbody() {
	    return this.getTypedRuleContext(CvtopbodyContext,0);
	};

	quasiquote() {
	    return this.getTypedRuleContext(QuasiquoteContext,0);
	};

	AopenParen = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.AopenParen);
	    } else {
	        return this.getToken(HaskellParser.AopenParen, i);
	    }
	};


	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	cmdargs() {
	    return this.getTypedRuleContext(CmdargsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAexp2(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAexp2(this);
		}
	}


}



class Splice_expContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_splice_exp;
    }

	splice_typed() {
	    return this.getTypedRuleContext(Splice_typedContext,0);
	};

	splice_untyped() {
	    return this.getTypedRuleContext(Splice_untypedContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSplice_exp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSplice_exp(this);
		}
	}


}



class Splice_untypedContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_splice_untyped;
    }

	Dollar() {
	    return this.getToken(HaskellParser.Dollar, 0);
	};

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSplice_untyped(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSplice_untyped(this);
		}
	}


}



class Splice_typedContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_splice_typed;
    }

	DDollar() {
	    return this.getToken(HaskellParser.DDollar, 0);
	};

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSplice_typed(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSplice_typed(this);
		}
	}


}



class CmdargsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cmdargs;
    }

	acmd = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(AcmdContext);
	    } else {
	        return this.getTypedRuleContext(AcmdContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCmdargs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCmdargs(this);
		}
	}


}



class AcmdContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_acmd;
    }

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAcmd(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAcmd(this);
		}
	}


}



class CvtopbodyContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cvtopbody;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	cvtopdecls0() {
	    return this.getTypedRuleContext(Cvtopdecls0Context,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCvtopbody(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCvtopbody(this);
		}
	}


}



class Cvtopdecls0Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_cvtopdecls0;
    }

	topdecls() {
	    return this.getTypedRuleContext(TopdeclsContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCvtopdecls0(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCvtopdecls0(this);
		}
	}


}



class TexpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_texp;
    }

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	qop() {
	    return this.getTypedRuleContext(QopContext,0);
	};

	qopm() {
	    return this.getTypedRuleContext(QopmContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	texp() {
	    return this.getTypedRuleContext(TexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTexp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTexp(this);
		}
	}


}



class Tup_exprsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tup_exprs;
    }

	texp() {
	    return this.getTypedRuleContext(TexpContext,0);
	};

	commas_tup_tail() {
	    return this.getTypedRuleContext(Commas_tup_tailContext,0);
	};

	bars = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(BarsContext);
	    } else {
	        return this.getTypedRuleContext(BarsContext,i);
	    }
	};

	commas() {
	    return this.getTypedRuleContext(CommasContext,0);
	};

	tup_tail() {
	    return this.getTypedRuleContext(Tup_tailContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTup_exprs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTup_exprs(this);
		}
	}


}



class Commas_tup_tailContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_commas_tup_tail;
    }

	commas() {
	    return this.getTypedRuleContext(CommasContext,0);
	};

	tup_tail() {
	    return this.getTypedRuleContext(Tup_tailContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCommas_tup_tail(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCommas_tup_tail(this);
		}
	}


}



class Tup_tailContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tup_tail;
    }

	texp() {
	    return this.getTypedRuleContext(TexpContext,0);
	};

	commas_tup_tail() {
	    return this.getTypedRuleContext(Commas_tup_tailContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTup_tail(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTup_tail(this);
		}
	}


}



class List_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_list_;
    }

	texp() {
	    return this.getTypedRuleContext(TexpContext,0);
	};

	lexps() {
	    return this.getTypedRuleContext(LexpsContext,0);
	};

	DoubleDot() {
	    return this.getToken(HaskellParser.DoubleDot, 0);
	};

	Comma() {
	    return this.getToken(HaskellParser.Comma, 0);
	};

	exp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ExpContext);
	    } else {
	        return this.getTypedRuleContext(ExpContext,i);
	    }
	};

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	flattenedpquals() {
	    return this.getTypedRuleContext(FlattenedpqualsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterList_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitList_(this);
		}
	}


}



class LexpsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_lexps;
    }

	texp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TexpContext);
	    } else {
	        return this.getTypedRuleContext(TexpContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterLexps(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitLexps(this);
		}
	}


}



class FlattenedpqualsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_flattenedpquals;
    }

	pquals() {
	    return this.getTypedRuleContext(PqualsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFlattenedpquals(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFlattenedpquals(this);
		}
	}


}



class PqualsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pquals;
    }

	squals = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SqualsContext);
	    } else {
	        return this.getTypedRuleContext(SqualsContext,i);
	    }
	};

	Pipe = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Pipe);
	    } else {
	        return this.getToken(HaskellParser.Pipe, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPquals(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPquals(this);
		}
	}


}



class SqualsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_squals;
    }

	transformqual = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(TransformqualContext);
	    } else {
	        return this.getTypedRuleContext(TransformqualContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	qual = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(QualContext);
	    } else {
	        return this.getTypedRuleContext(QualContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSquals(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSquals(this);
		}
	}


}



class TransformqualContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_transformqual;
    }

	THEN() {
	    return this.getToken(HaskellParser.THEN, 0);
	};

	exp = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ExpContext);
	    } else {
	        return this.getTypedRuleContext(ExpContext,i);
	    }
	};

	BY() {
	    return this.getToken(HaskellParser.BY, 0);
	};

	GROUP() {
	    return this.getToken(HaskellParser.GROUP, 0);
	};

	USING() {
	    return this.getToken(HaskellParser.USING, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTransformqual(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTransformqual(this);
		}
	}


}



class GuardsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_guards;
    }

	guard_ = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Guard_Context);
	    } else {
	        return this.getTypedRuleContext(Guard_Context,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGuards(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGuards(this);
		}
	}


}



class Guard_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_guard_;
    }

	pat() {
	    return this.getTypedRuleContext(PatContext,0);
	};

	Revarrow() {
	    return this.getToken(HaskellParser.Revarrow, 0);
	};

	infixexp() {
	    return this.getTypedRuleContext(InfixexpContext,0);
	};

	LET() {
	    return this.getToken(HaskellParser.LET, 0);
	};

	decllist() {
	    return this.getTypedRuleContext(DecllistContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGuard_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGuard_(this);
		}
	}


}



class AltsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_alts;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	alt = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(AltContext);
	    } else {
	        return this.getTypedRuleContext(AltContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAlts(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAlts(this);
		}
	}


}



class AltContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_alt;
    }

	pat() {
	    return this.getTypedRuleContext(PatContext,0);
	};

	alt_rhs() {
	    return this.getTypedRuleContext(Alt_rhsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAlt(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAlt(this);
		}
	}


}



class Alt_rhsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_alt_rhs;
    }

	ralt() {
	    return this.getTypedRuleContext(RaltContext,0);
	};

	wherebinds() {
	    return this.getTypedRuleContext(WherebindsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAlt_rhs(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAlt_rhs(this);
		}
	}


}



class RaltContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ralt;
    }

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	gdpats() {
	    return this.getTypedRuleContext(GdpatsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterRalt(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitRalt(this);
		}
	}


}



class GdpatsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gdpats;
    }

	gdpat = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(GdpatContext);
	    } else {
	        return this.getTypedRuleContext(GdpatContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGdpats(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGdpats(this);
		}
	}


}



class IfgdpatsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ifgdpats;
    }

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	gdpats() {
	    return this.getTypedRuleContext(GdpatsContext,0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterIfgdpats(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitIfgdpats(this);
		}
	}


}



class GdpatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gdpat;
    }

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	guards() {
	    return this.getTypedRuleContext(GuardsContext,0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGdpat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGdpat(this);
		}
	}


}



class PatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pat;
    }

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPat(this);
		}
	}


}



class BindpatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_bindpat;
    }

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBindpat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBindpat(this);
		}
	}


}



class ApatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_apat;
    }

	aexp() {
	    return this.getTypedRuleContext(AexpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterApat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitApat(this);
		}
	}


}



class ApatsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_apats;
    }

	apat = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ApatContext);
	    } else {
	        return this.getTypedRuleContext(ApatContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterApats(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitApats(this);
		}
	}


}



class FpatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fpat;
    }

	qvar() {
	    return this.getTypedRuleContext(QvarContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	pat() {
	    return this.getTypedRuleContext(PatContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFpat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFpat(this);
		}
	}


}



class StmtlistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_stmtlist;
    }

	open_() {
	    return this.getTypedRuleContext(Open_Context,0);
	};

	close() {
	    return this.getTypedRuleContext(CloseContext,0);
	};

	stmts() {
	    return this.getTypedRuleContext(StmtsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStmtlist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStmtlist(this);
		}
	}


}



class StmtsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_stmts;
    }

	stmt = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(StmtContext);
	    } else {
	        return this.getTypedRuleContext(StmtContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStmts(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStmts(this);
		}
	}


}



class StmtContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_stmt;
    }

	qual() {
	    return this.getTypedRuleContext(QualContext,0);
	};

	REC() {
	    return this.getToken(HaskellParser.REC, 0);
	};

	stmtlist() {
	    return this.getTypedRuleContext(StmtlistContext,0);
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterStmt(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitStmt(this);
		}
	}


}



class QualContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qual;
    }

	bindpat() {
	    return this.getTypedRuleContext(BindpatContext,0);
	};

	Revarrow() {
	    return this.getToken(HaskellParser.Revarrow, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	LET() {
	    return this.getToken(HaskellParser.LET, 0);
	};

	binds() {
	    return this.getTypedRuleContext(BindsContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQual(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQual(this);
		}
	}


}



class FbindsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fbinds;
    }

	fbind = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(FbindContext);
	    } else {
	        return this.getTypedRuleContext(FbindContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	DoubleDot() {
	    return this.getToken(HaskellParser.DoubleDot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFbinds(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFbinds(this);
		}
	}


}



class FbindContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_fbind;
    }

	qvar() {
	    return this.getTypedRuleContext(QvarContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterFbind(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitFbind(this);
		}
	}


}



class DbindsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_dbinds;
    }

	dbind = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(DbindContext);
	    } else {
	        return this.getTypedRuleContext(DbindContext,i);
	    }
	};

	semi = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(SemiContext);
	    } else {
	        return this.getTypedRuleContext(SemiContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDbinds(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDbinds(this);
		}
	}


}



class DbindContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_dbind;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	exp() {
	    return this.getTypedRuleContext(ExpContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterDbind(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitDbind(this);
		}
	}


}



class Name_boolformula_optContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_name_boolformula_opt;
    }

	name_boolformula_and = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Name_boolformula_andContext);
	    } else {
	        return this.getTypedRuleContext(Name_boolformula_andContext,i);
	    }
	};

	Pipe = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Pipe);
	    } else {
	        return this.getToken(HaskellParser.Pipe, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterName_boolformula_opt(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitName_boolformula_opt(this);
		}
	}


}



class Name_boolformula_andContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_name_boolformula_and;
    }

	name_boolformula_and_list() {
	    return this.getTypedRuleContext(Name_boolformula_and_listContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterName_boolformula_and(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitName_boolformula_and(this);
		}
	}


}



class Name_boolformula_and_listContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_name_boolformula_and_list;
    }

	name_boolformula_atom = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Name_boolformula_atomContext);
	    } else {
	        return this.getTypedRuleContext(Name_boolformula_atomContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterName_boolformula_and_list(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitName_boolformula_and_list(this);
		}
	}


}



class Name_boolformula_atomContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_name_boolformula_atom;
    }

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	name_boolformula_opt() {
	    return this.getTypedRuleContext(Name_boolformula_optContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	name_var() {
	    return this.getTypedRuleContext(Name_varContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterName_boolformula_atom(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitName_boolformula_atom(this);
		}
	}


}



class NamelistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_namelist;
    }

	name_var = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(Name_varContext);
	    } else {
	        return this.getTypedRuleContext(Name_varContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterNamelist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitNamelist(this);
		}
	}


}



class Name_varContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_name_var;
    }

	var_() {
	    return this.getTypedRuleContext(Var_Context,0);
	};

	con() {
	    return this.getTypedRuleContext(ConContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterName_var(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitName_var(this);
		}
	}


}



class Qcon_nowiredlistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qcon_nowiredlist;
    }

	gen_qcon() {
	    return this.getTypedRuleContext(Gen_qconContext,0);
	};

	sysdcon_nolist() {
	    return this.getTypedRuleContext(Sysdcon_nolistContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQcon_nowiredlist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQcon_nowiredlist(this);
		}
	}


}



class QconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qcon;
    }

	gen_qcon() {
	    return this.getTypedRuleContext(Gen_qconContext,0);
	};

	sysdcon() {
	    return this.getTypedRuleContext(SysdconContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQcon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQcon(this);
		}
	}


}



class Gen_qconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gen_qcon;
    }

	qconid() {
	    return this.getTypedRuleContext(QconidContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	qconsym() {
	    return this.getTypedRuleContext(QconsymContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGen_qcon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGen_qcon(this);
		}
	}


}



class ConContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_con;
    }

	conid() {
	    return this.getTypedRuleContext(ConidContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	consym() {
	    return this.getTypedRuleContext(ConsymContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	sysdcon() {
	    return this.getTypedRuleContext(SysdconContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCon(this);
		}
	}


}



class Con_listContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_con_list;
    }

	con = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ConContext);
	    } else {
	        return this.getTypedRuleContext(ConContext,i);
	    }
	};

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCon_list(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCon_list(this);
		}
	}


}



class Sysdcon_nolistContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sysdcon_nolist;
    }

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	commas() {
	    return this.getTypedRuleContext(CommasContext,0);
	};

	OpenBoxParen() {
	    return this.getToken(HaskellParser.OpenBoxParen, 0);
	};

	CloseBoxParen() {
	    return this.getToken(HaskellParser.CloseBoxParen, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSysdcon_nolist(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSysdcon_nolist(this);
		}
	}


}



class SysdconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_sysdcon;
    }

	sysdcon_nolist() {
	    return this.getTypedRuleContext(Sysdcon_nolistContext,0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSysdcon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSysdcon(this);
		}
	}


}



class ConopContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_conop;
    }

	consym() {
	    return this.getTypedRuleContext(ConsymContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	conid() {
	    return this.getTypedRuleContext(ConidContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConop(this);
		}
	}


}



class QconopContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qconop;
    }

	gconsym() {
	    return this.getTypedRuleContext(GconsymContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	qconid() {
	    return this.getTypedRuleContext(QconidContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQconop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQconop(this);
		}
	}


}



class GconsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gconsym;
    }

	Colon() {
	    return this.getToken(HaskellParser.Colon, 0);
	};

	qconsym() {
	    return this.getTypedRuleContext(QconsymContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGconsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGconsym(this);
		}
	}


}



class GtyconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_gtycon;
    }

	ntgtycon() {
	    return this.getTypedRuleContext(NtgtyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	OpenBoxParen() {
	    return this.getToken(HaskellParser.OpenBoxParen, 0);
	};

	CloseBoxParen() {
	    return this.getToken(HaskellParser.CloseBoxParen, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterGtycon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitGtycon(this);
		}
	}


}



class NtgtyconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ntgtycon;
    }

	oqtycon() {
	    return this.getTypedRuleContext(OqtyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	commas() {
	    return this.getTypedRuleContext(CommasContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	OpenBoxParen() {
	    return this.getToken(HaskellParser.OpenBoxParen, 0);
	};

	CloseBoxParen() {
	    return this.getToken(HaskellParser.CloseBoxParen, 0);
	};

	Arrow() {
	    return this.getToken(HaskellParser.Arrow, 0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterNtgtycon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitNtgtycon(this);
		}
	}


}



class OqtyconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_oqtycon;
    }

	qtycon() {
	    return this.getTypedRuleContext(QtyconContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	qtyconsym() {
	    return this.getTypedRuleContext(QtyconsymContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOqtycon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOqtycon(this);
		}
	}


}



class QtyconopContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qtyconop;
    }

	qtyconsym() {
	    return this.getTypedRuleContext(QtyconsymContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	qtycon() {
	    return this.getTypedRuleContext(QtyconContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQtyconop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQtyconop(this);
		}
	}


}



class QtyconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qtycon;
    }

	tycon() {
	    return this.getTypedRuleContext(TyconContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQtycon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQtycon(this);
		}
	}


}



class TyconContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tycon;
    }

	conid() {
	    return this.getTypedRuleContext(ConidContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTycon(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTycon(this);
		}
	}


}



class QtyconsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qtyconsym;
    }

	qconsym() {
	    return this.getTypedRuleContext(QconsymContext,0);
	};

	qvarsym() {
	    return this.getTypedRuleContext(QvarsymContext,0);
	};

	tyconsym() {
	    return this.getTypedRuleContext(TyconsymContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQtyconsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQtyconsym(this);
		}
	}


}



class TyconsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyconsym;
    }

	consym() {
	    return this.getTypedRuleContext(ConsymContext,0);
	};

	varsym() {
	    return this.getTypedRuleContext(VarsymContext,0);
	};

	Colon() {
	    return this.getToken(HaskellParser.Colon, 0);
	};

	Minus() {
	    return this.getToken(HaskellParser.Minus, 0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyconsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyconsym(this);
		}
	}


}



class OpContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_op;
    }

	varop() {
	    return this.getTypedRuleContext(VaropContext,0);
	};

	conop() {
	    return this.getTypedRuleContext(ConopContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOp(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOp(this);
		}
	}


}



class VaropContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_varop;
    }

	varsym() {
	    return this.getTypedRuleContext(VarsymContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVarop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVarop(this);
		}
	}


}



class QopContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qop;
    }

	qvarop() {
	    return this.getTypedRuleContext(QvaropContext,0);
	};

	qconop() {
	    return this.getTypedRuleContext(QconopContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQop(this);
		}
	}


}



class QopmContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qopm;
    }

	qvaropm() {
	    return this.getTypedRuleContext(QvaropmContext,0);
	};

	qconop() {
	    return this.getTypedRuleContext(QconopContext,0);
	};

	hole_op() {
	    return this.getTypedRuleContext(Hole_opContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQopm(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQopm(this);
		}
	}


}



class Hole_opContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_hole_op;
    }

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	WILDCARD() {
	    return this.getToken(HaskellParser.WILDCARD, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterHole_op(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitHole_op(this);
		}
	}


}



class QvaropContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvarop;
    }

	qvarsym() {
	    return this.getTypedRuleContext(QvarsymContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	qvarid() {
	    return this.getTypedRuleContext(QvaridContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvarop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvarop(this);
		}
	}


}



class QvaropmContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvaropm;
    }

	qvarsym_no_minus() {
	    return this.getTypedRuleContext(Qvarsym_no_minusContext,0);
	};

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	qvarid() {
	    return this.getTypedRuleContext(QvaridContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvaropm(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvaropm(this);
		}
	}


}



class TyvarContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyvar;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyvar(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyvar(this);
		}
	}


}



class TyvaropContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyvarop;
    }

	BackQuote = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.BackQuote);
	    } else {
	        return this.getToken(HaskellParser.BackQuote, i);
	    }
	};


	tyvarid() {
	    return this.getTypedRuleContext(TyvaridContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyvarop(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyvarop(this);
		}
	}


}



class TyvaridContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tyvarid;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	special_id() {
	    return this.getTypedRuleContext(Special_idContext,0);
	};

	UNSAFE() {
	    return this.getToken(HaskellParser.UNSAFE, 0);
	};

	SAFE() {
	    return this.getToken(HaskellParser.SAFE, 0);
	};

	INTERRUPTIBLE() {
	    return this.getToken(HaskellParser.INTERRUPTIBLE, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTyvarid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTyvarid(this);
		}
	}


}



class TyclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_tycls;
    }

	conid() {
	    return this.getTypedRuleContext(ConidContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterTycls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitTycls(this);
		}
	}


}



class QtyclsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qtycls;
    }

	tycls() {
	    return this.getTypedRuleContext(TyclsContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQtycls(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQtycls(this);
		}
	}


}



class Var_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_var_;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	varsym() {
	    return this.getTypedRuleContext(VarsymContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVar_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVar_(this);
		}
	}


}



class QvarContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvar;
    }

	qvarid() {
	    return this.getTypedRuleContext(QvaridContext,0);
	};

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	qvarsym() {
	    return this.getTypedRuleContext(QvarsymContext,0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvar(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvar(this);
		}
	}


}



class QvaridContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvarid;
    }

	varid() {
	    return this.getTypedRuleContext(VaridContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvarid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvarid(this);
		}
	}


}



class VaridContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_varid;
    }

	VARID() {
	    return this.getToken(HaskellParser.VARID, 0);
	};

	special_id() {
	    return this.getTypedRuleContext(Special_idContext,0);
	};

	Hash = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Hash);
	    } else {
	        return this.getToken(HaskellParser.Hash, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVarid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVarid(this);
		}
	}


}



class QvarsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvarsym;
    }

	varsym() {
	    return this.getTypedRuleContext(VarsymContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvarsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvarsym(this);
		}
	}


}



class Qvarsym_no_minusContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qvarsym_no_minus;
    }

	varsym_no_minus() {
	    return this.getTypedRuleContext(Varsym_no_minusContext,0);
	};

	qvarsym() {
	    return this.getTypedRuleContext(QvarsymContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQvarsym_no_minus(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQvarsym_no_minus(this);
		}
	}


}



class VarsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_varsym;
    }

	varsym_no_minus() {
	    return this.getTypedRuleContext(Varsym_no_minusContext,0);
	};

	Minus() {
	    return this.getToken(HaskellParser.Minus, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVarsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVarsym(this);
		}
	}


}



class Varsym_no_minusContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_varsym_no_minus;
    }

	ascSymbol = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(AscSymbolContext);
	    } else {
	        return this.getTypedRuleContext(AscSymbolContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterVarsym_no_minus(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitVarsym_no_minus(this);
		}
	}


}



class Special_idContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_special_id;
    }

	AS() {
	    return this.getToken(HaskellParser.AS, 0);
	};

	QUALIFIED() {
	    return this.getToken(HaskellParser.QUALIFIED, 0);
	};

	HIDING() {
	    return this.getToken(HaskellParser.HIDING, 0);
	};

	EXPORT() {
	    return this.getToken(HaskellParser.EXPORT, 0);
	};

	STDCALL() {
	    return this.getToken(HaskellParser.STDCALL, 0);
	};

	CCALL() {
	    return this.getToken(HaskellParser.CCALL, 0);
	};

	CAPI() {
	    return this.getToken(HaskellParser.CAPI, 0);
	};

	JSCALL() {
	    return this.getToken(HaskellParser.JSCALL, 0);
	};

	STOCK() {
	    return this.getToken(HaskellParser.STOCK, 0);
	};

	ANYCLASS() {
	    return this.getToken(HaskellParser.ANYCLASS, 0);
	};

	VIA() {
	    return this.getToken(HaskellParser.VIA, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSpecial_id(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSpecial_id(this);
		}
	}


}



class QconidContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qconid;
    }

	conid() {
	    return this.getTypedRuleContext(ConidContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQconid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQconid(this);
		}
	}


}



class ConidContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_conid;
    }

	CONID() {
	    return this.getToken(HaskellParser.CONID, 0);
	};

	Hash = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Hash);
	    } else {
	        return this.getToken(HaskellParser.Hash, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConid(this);
		}
	}


}



class QconsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_qconsym;
    }

	consym() {
	    return this.getTypedRuleContext(ConsymContext,0);
	};

	modid() {
	    return this.getTypedRuleContext(ModidContext,0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterQconsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitQconsym(this);
		}
	}


}



class ConsymContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_consym;
    }

	Colon() {
	    return this.getToken(HaskellParser.Colon, 0);
	};

	ascSymbol = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(AscSymbolContext);
	    } else {
	        return this.getTypedRuleContext(AscSymbolContext,i);
	    }
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterConsym(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitConsym(this);
		}
	}


}



class LiteralContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_literal;
    }

	integer() {
	    return this.getTypedRuleContext(IntegerContext,0);
	};

	pfloat() {
	    return this.getTypedRuleContext(PfloatContext,0);
	};

	pchar() {
	    return this.getTypedRuleContext(PcharContext,0);
	};

	pstring() {
	    return this.getTypedRuleContext(PstringContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterLiteral(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitLiteral(this);
		}
	}


}



class Open_Context extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_open_;
    }

	VOCURLY() {
	    return this.getToken(HaskellParser.VOCURLY, 0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterOpen_(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitOpen_(this);
		}
	}


}



class CloseContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_close;
    }

	VCCURLY() {
	    return this.getToken(HaskellParser.VCCURLY, 0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterClose(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitClose(this);
		}
	}


}



class SemiContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_semi;
    }

	Semi() {
	    return this.getToken(HaskellParser.Semi, 0);
	};

	SEMI() {
	    return this.getToken(HaskellParser.SEMI, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSemi(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSemi(this);
		}
	}


}



class ModidContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_modid;
    }

	conid = function(i) {
	    if(i===undefined) {
	        i = null;
	    }
	    if(i===null) {
	        return this.getTypedRuleContexts(ConidContext);
	    } else {
	        return this.getTypedRuleContext(ConidContext,i);
	    }
	};

	Dot = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Dot);
	    } else {
	        return this.getToken(HaskellParser.Dot, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterModid(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitModid(this);
		}
	}


}



class CommasContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_commas;
    }

	Comma = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Comma);
	    } else {
	        return this.getToken(HaskellParser.Comma, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterCommas(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitCommas(this);
		}
	}


}



class BarsContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_bars;
    }

	Pipe = function(i) {
		if(i===undefined) {
			i = null;
		}
	    if(i===null) {
	        return this.getTokens(HaskellParser.Pipe);
	    } else {
	        return this.getToken(HaskellParser.Pipe, i);
	    }
	};


	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterBars(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitBars(this);
		}
	}


}



class SpecialContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_special;
    }

	OpenRoundBracket() {
	    return this.getToken(HaskellParser.OpenRoundBracket, 0);
	};

	CloseRoundBracket() {
	    return this.getToken(HaskellParser.CloseRoundBracket, 0);
	};

	Comma() {
	    return this.getToken(HaskellParser.Comma, 0);
	};

	Semi() {
	    return this.getToken(HaskellParser.Semi, 0);
	};

	OpenSquareBracket() {
	    return this.getToken(HaskellParser.OpenSquareBracket, 0);
	};

	CloseSquareBracket() {
	    return this.getToken(HaskellParser.CloseSquareBracket, 0);
	};

	BackQuote() {
	    return this.getToken(HaskellParser.BackQuote, 0);
	};

	OCURLY() {
	    return this.getToken(HaskellParser.OCURLY, 0);
	};

	CCURLY() {
	    return this.getToken(HaskellParser.CCURLY, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSpecial(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSpecial(this);
		}
	}


}



class SymbolContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_symbol;
    }

	ascSymbol() {
	    return this.getTypedRuleContext(AscSymbolContext,0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterSymbol(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitSymbol(this);
		}
	}


}



class AscSymbolContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_ascSymbol;
    }

	Bang() {
	    return this.getToken(HaskellParser.Bang, 0);
	};

	Hash() {
	    return this.getToken(HaskellParser.Hash, 0);
	};

	Dollar() {
	    return this.getToken(HaskellParser.Dollar, 0);
	};

	Percent() {
	    return this.getToken(HaskellParser.Percent, 0);
	};

	Ampersand() {
	    return this.getToken(HaskellParser.Ampersand, 0);
	};

	Asterisk() {
	    return this.getToken(HaskellParser.Asterisk, 0);
	};

	Plus() {
	    return this.getToken(HaskellParser.Plus, 0);
	};

	Dot() {
	    return this.getToken(HaskellParser.Dot, 0);
	};

	Divide() {
	    return this.getToken(HaskellParser.Divide, 0);
	};

	Less() {
	    return this.getToken(HaskellParser.Less, 0);
	};

	Eq() {
	    return this.getToken(HaskellParser.Eq, 0);
	};

	Greater() {
	    return this.getToken(HaskellParser.Greater, 0);
	};

	QuestionMark() {
	    return this.getToken(HaskellParser.QuestionMark, 0);
	};

	Atsign() {
	    return this.getToken(HaskellParser.Atsign, 0);
	};

	ReverseSlash() {
	    return this.getToken(HaskellParser.ReverseSlash, 0);
	};

	Caret() {
	    return this.getToken(HaskellParser.Caret, 0);
	};

	Pipe() {
	    return this.getToken(HaskellParser.Pipe, 0);
	};

	Tilde() {
	    return this.getToken(HaskellParser.Tilde, 0);
	};

	Colon() {
	    return this.getToken(HaskellParser.Colon, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterAscSymbol(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitAscSymbol(this);
		}
	}


}



class IntegerContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_integer;
    }

	DECIMAL() {
	    return this.getToken(HaskellParser.DECIMAL, 0);
	};

	OCTAL() {
	    return this.getToken(HaskellParser.OCTAL, 0);
	};

	HEXADECIMAL() {
	    return this.getToken(HaskellParser.HEXADECIMAL, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterInteger(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitInteger(this);
		}
	}


}



class PfloatContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pfloat;
    }

	FLOAT() {
	    return this.getToken(HaskellParser.FLOAT, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPfloat(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPfloat(this);
		}
	}


}



class PcharContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pchar;
    }

	CHAR() {
	    return this.getToken(HaskellParser.CHAR, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPchar(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPchar(this);
		}
	}


}



class PstringContext extends antlr4.ParserRuleContext {

    constructor(parser, parent, invokingState) {
        if(parent===undefined) {
            parent = null;
        }
        if(invokingState===undefined || invokingState===null) {
            invokingState = -1;
        }
        super(parent, invokingState);
        this.parser = parser;
        this.ruleIndex = HaskellParser.RULE_pstring;
    }

	STRING() {
	    return this.getToken(HaskellParser.STRING, 0);
	};

	enterRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.enterPstring(this);
		}
	}

	exitRule(listener) {
	    if(listener instanceof HaskellParserListener ) {
	        listener.exitPstring(this);
		}
	}


}




HaskellParser.ModuleContext = ModuleContext; 
HaskellParser.Module_contentContext = Module_contentContext; 
HaskellParser.Where_moduleContext = Where_moduleContext; 
HaskellParser.Module_bodyContext = Module_bodyContext; 
HaskellParser.PragmasContext = PragmasContext; 
HaskellParser.PragmaContext = PragmaContext; 
HaskellParser.Language_pragmaContext = Language_pragmaContext; 
HaskellParser.Options_ghcContext = Options_ghcContext; 
HaskellParser.Simple_optionsContext = Simple_optionsContext; 
HaskellParser.Extension_Context = Extension_Context; 
HaskellParser.BodyContext = BodyContext; 
HaskellParser.ImpdeclsContext = ImpdeclsContext; 
HaskellParser.ExportsContext = ExportsContext; 
HaskellParser.ExprtContext = ExprtContext; 
HaskellParser.ImpdeclContext = ImpdeclContext; 
HaskellParser.ImpspecContext = ImpspecContext; 
HaskellParser.HimportContext = HimportContext; 
HaskellParser.CnameContext = CnameContext; 
HaskellParser.FixityContext = FixityContext; 
HaskellParser.OpsContext = OpsContext; 
HaskellParser.TopdeclsContext = TopdeclsContext; 
HaskellParser.TopdeclContext = TopdeclContext; 
HaskellParser.Cl_declContext = Cl_declContext; 
HaskellParser.Ty_declContext = Ty_declContext; 
HaskellParser.Standalone_kind_sigContext = Standalone_kind_sigContext; 
HaskellParser.Sks_varsContext = Sks_varsContext; 
HaskellParser.Inst_declContext = Inst_declContext; 
HaskellParser.Overlap_pragmaContext = Overlap_pragmaContext; 
HaskellParser.Deriv_strategy_no_viaContext = Deriv_strategy_no_viaContext; 
HaskellParser.Deriv_strategy_viaContext = Deriv_strategy_viaContext; 
HaskellParser.Deriv_standalone_strategyContext = Deriv_standalone_strategyContext; 
HaskellParser.Opt_injective_infoContext = Opt_injective_infoContext; 
HaskellParser.Injectivity_condContext = Injectivity_condContext; 
HaskellParser.Inj_varidsContext = Inj_varidsContext; 
HaskellParser.Where_type_familyContext = Where_type_familyContext; 
HaskellParser.Ty_fam_inst_eqn_listContext = Ty_fam_inst_eqn_listContext; 
HaskellParser.Ty_fam_inst_eqnsContext = Ty_fam_inst_eqnsContext; 
HaskellParser.Ty_fam_inst_eqnContext = Ty_fam_inst_eqnContext; 
HaskellParser.At_decl_clsContext = At_decl_clsContext; 
HaskellParser.At_decl_instContext = At_decl_instContext; 
HaskellParser.Opt_kind_sigContext = Opt_kind_sigContext; 
HaskellParser.Opt_datafam_kind_sigContext = Opt_datafam_kind_sigContext; 
HaskellParser.Opt_tyfam_kind_sigContext = Opt_tyfam_kind_sigContext; 
HaskellParser.Opt_at_kind_inj_sigContext = Opt_at_kind_inj_sigContext; 
HaskellParser.Tycl_hdrContext = Tycl_hdrContext; 
HaskellParser.Tycl_hdr_instContext = Tycl_hdr_instContext; 
HaskellParser.Capi_ctypeContext = Capi_ctypeContext; 
HaskellParser.Standalone_derivingContext = Standalone_derivingContext; 
HaskellParser.Role_annotContext = Role_annotContext; 
HaskellParser.RolesContext = RolesContext; 
HaskellParser.RoleContext = RoleContext; 
HaskellParser.Pattern_synonym_declContext = Pattern_synonym_declContext; 
HaskellParser.Pattern_synonym_lhsContext = Pattern_synonym_lhsContext; 
HaskellParser.Vars_Context = Vars_Context; 
HaskellParser.CvarsContext = CvarsContext; 
HaskellParser.Where_declsContext = Where_declsContext; 
HaskellParser.Pattern_synonym_sigContext = Pattern_synonym_sigContext; 
HaskellParser.Decl_clsContext = Decl_clsContext; 
HaskellParser.Decls_clsContext = Decls_clsContext; 
HaskellParser.Decllist_clsContext = Decllist_clsContext; 
HaskellParser.Where_clsContext = Where_clsContext; 
HaskellParser.Decl_instContext = Decl_instContext; 
HaskellParser.Decls_instContext = Decls_instContext; 
HaskellParser.Decllist_instContext = Decllist_instContext; 
HaskellParser.Where_instContext = Where_instContext; 
HaskellParser.DeclsContext = DeclsContext; 
HaskellParser.DecllistContext = DecllistContext; 
HaskellParser.BindsContext = BindsContext; 
HaskellParser.WherebindsContext = WherebindsContext; 
HaskellParser.RulesContext = RulesContext; 
HaskellParser.Pragma_ruleContext = Pragma_ruleContext; 
HaskellParser.Rule_activation_markerContext = Rule_activation_markerContext; 
HaskellParser.Rule_activationContext = Rule_activationContext; 
HaskellParser.Rule_forallsContext = Rule_forallsContext; 
HaskellParser.Rule_varsContext = Rule_varsContext; 
HaskellParser.Rule_varContext = Rule_varContext; 
HaskellParser.WarningsContext = WarningsContext; 
HaskellParser.Pragma_warningContext = Pragma_warningContext; 
HaskellParser.DeprecationsContext = DeprecationsContext; 
HaskellParser.Pragma_deprecationContext = Pragma_deprecationContext; 
HaskellParser.StringsContext = StringsContext; 
HaskellParser.StringlistContext = StringlistContext; 
HaskellParser.AnnotationContext = AnnotationContext; 
HaskellParser.FdeclContext = FdeclContext; 
HaskellParser.CallconvContext = CallconvContext; 
HaskellParser.SafetyContext = SafetyContext; 
HaskellParser.FspecContext = FspecContext; 
HaskellParser.Opt_sigContext = Opt_sigContext; 
HaskellParser.Opt_tyconsigContext = Opt_tyconsigContext; 
HaskellParser.SigtypeContext = SigtypeContext; 
HaskellParser.SigtypedocContext = SigtypedocContext; 
HaskellParser.Sig_varsContext = Sig_varsContext; 
HaskellParser.Sigtypes1Context = Sigtypes1Context; 
HaskellParser.UnpackednessContext = UnpackednessContext; 
HaskellParser.Forall_vis_flagContext = Forall_vis_flagContext; 
HaskellParser.KtypeContext = KtypeContext; 
HaskellParser.KtypedocContext = KtypedocContext; 
HaskellParser.CtypeContext = CtypeContext; 
HaskellParser.CtypedocContext = CtypedocContext; 
HaskellParser.Tycl_contextContext = Tycl_contextContext; 
HaskellParser.Constr_contextContext = Constr_contextContext; 
HaskellParser.Type_Context = Type_Context; 
HaskellParser.TypedocContext = TypedocContext; 
HaskellParser.Constr_btypeContext = Constr_btypeContext; 
HaskellParser.Constr_tyappsContext = Constr_tyappsContext; 
HaskellParser.Constr_tyappContext = Constr_tyappContext; 
HaskellParser.BtypeContext = BtypeContext; 
HaskellParser.TyappsContext = TyappsContext; 
HaskellParser.TyappContext = TyappContext; 
HaskellParser.AtypeContext = AtypeContext; 
HaskellParser.Inst_typeContext = Inst_typeContext; 
HaskellParser.Deriv_typesContext = Deriv_typesContext; 
HaskellParser.Comma_typesContext = Comma_typesContext; 
HaskellParser.Bar_types2Context = Bar_types2Context; 
HaskellParser.Tv_bndrsContext = Tv_bndrsContext; 
HaskellParser.Tv_bndrContext = Tv_bndrContext; 
HaskellParser.Tv_bndr_no_bracesContext = Tv_bndr_no_bracesContext; 
HaskellParser.FdsContext = FdsContext; 
HaskellParser.Fds1Context = Fds1Context; 
HaskellParser.FdContext = FdContext; 
HaskellParser.Varids0Context = Varids0Context; 
HaskellParser.KindContext = KindContext; 
HaskellParser.Gadt_constrlistContext = Gadt_constrlistContext; 
HaskellParser.Gadt_constrsContext = Gadt_constrsContext; 
HaskellParser.Gadt_constr_with_docContext = Gadt_constr_with_docContext; 
HaskellParser.Gadt_constrContext = Gadt_constrContext; 
HaskellParser.ConstrsContext = ConstrsContext; 
HaskellParser.Constrs1Context = Constrs1Context; 
HaskellParser.ConstrContext = ConstrContext; 
HaskellParser.ForallContext = ForallContext; 
HaskellParser.Constr_stuffContext = Constr_stuffContext; 
HaskellParser.FielddeclsContext = FielddeclsContext; 
HaskellParser.FielddeclContext = FielddeclContext; 
HaskellParser.DerivingsContext = DerivingsContext; 
HaskellParser.DerivingContext = DerivingContext; 
HaskellParser.Deriv_clause_typesContext = Deriv_clause_typesContext; 
HaskellParser.Decl_no_thContext = Decl_no_thContext; 
HaskellParser.DeclContext = DeclContext; 
HaskellParser.RhsContext = RhsContext; 
HaskellParser.GdrhsContext = GdrhsContext; 
HaskellParser.GdrhContext = GdrhContext; 
HaskellParser.SigdeclContext = SigdeclContext; 
HaskellParser.ActivationContext = ActivationContext; 
HaskellParser.Th_quasiquoteContext = Th_quasiquoteContext; 
HaskellParser.Th_qquasiquoteContext = Th_qquasiquoteContext; 
HaskellParser.QuasiquoteContext = QuasiquoteContext; 
HaskellParser.ExpContext = ExpContext; 
HaskellParser.InfixexpContext = InfixexpContext; 
HaskellParser.Exp10pContext = Exp10pContext; 
HaskellParser.Exp10Context = Exp10Context; 
HaskellParser.FexpContext = FexpContext; 
HaskellParser.AexpContext = AexpContext; 
HaskellParser.Aexp1Context = Aexp1Context; 
HaskellParser.Aexp2Context = Aexp2Context; 
HaskellParser.Splice_expContext = Splice_expContext; 
HaskellParser.Splice_untypedContext = Splice_untypedContext; 
HaskellParser.Splice_typedContext = Splice_typedContext; 
HaskellParser.CmdargsContext = CmdargsContext; 
HaskellParser.AcmdContext = AcmdContext; 
HaskellParser.CvtopbodyContext = CvtopbodyContext; 
HaskellParser.Cvtopdecls0Context = Cvtopdecls0Context; 
HaskellParser.TexpContext = TexpContext; 
HaskellParser.Tup_exprsContext = Tup_exprsContext; 
HaskellParser.Commas_tup_tailContext = Commas_tup_tailContext; 
HaskellParser.Tup_tailContext = Tup_tailContext; 
HaskellParser.List_Context = List_Context; 
HaskellParser.LexpsContext = LexpsContext; 
HaskellParser.FlattenedpqualsContext = FlattenedpqualsContext; 
HaskellParser.PqualsContext = PqualsContext; 
HaskellParser.SqualsContext = SqualsContext; 
HaskellParser.TransformqualContext = TransformqualContext; 
HaskellParser.GuardsContext = GuardsContext; 
HaskellParser.Guard_Context = Guard_Context; 
HaskellParser.AltsContext = AltsContext; 
HaskellParser.AltContext = AltContext; 
HaskellParser.Alt_rhsContext = Alt_rhsContext; 
HaskellParser.RaltContext = RaltContext; 
HaskellParser.GdpatsContext = GdpatsContext; 
HaskellParser.IfgdpatsContext = IfgdpatsContext; 
HaskellParser.GdpatContext = GdpatContext; 
HaskellParser.PatContext = PatContext; 
HaskellParser.BindpatContext = BindpatContext; 
HaskellParser.ApatContext = ApatContext; 
HaskellParser.ApatsContext = ApatsContext; 
HaskellParser.FpatContext = FpatContext; 
HaskellParser.StmtlistContext = StmtlistContext; 
HaskellParser.StmtsContext = StmtsContext; 
HaskellParser.StmtContext = StmtContext; 
HaskellParser.QualContext = QualContext; 
HaskellParser.FbindsContext = FbindsContext; 
HaskellParser.FbindContext = FbindContext; 
HaskellParser.DbindsContext = DbindsContext; 
HaskellParser.DbindContext = DbindContext; 
HaskellParser.Name_boolformula_optContext = Name_boolformula_optContext; 
HaskellParser.Name_boolformula_andContext = Name_boolformula_andContext; 
HaskellParser.Name_boolformula_and_listContext = Name_boolformula_and_listContext; 
HaskellParser.Name_boolformula_atomContext = Name_boolformula_atomContext; 
HaskellParser.NamelistContext = NamelistContext; 
HaskellParser.Name_varContext = Name_varContext; 
HaskellParser.Qcon_nowiredlistContext = Qcon_nowiredlistContext; 
HaskellParser.QconContext = QconContext; 
HaskellParser.Gen_qconContext = Gen_qconContext; 
HaskellParser.ConContext = ConContext; 
HaskellParser.Con_listContext = Con_listContext; 
HaskellParser.Sysdcon_nolistContext = Sysdcon_nolistContext; 
HaskellParser.SysdconContext = SysdconContext; 
HaskellParser.ConopContext = ConopContext; 
HaskellParser.QconopContext = QconopContext; 
HaskellParser.GconsymContext = GconsymContext; 
HaskellParser.GtyconContext = GtyconContext; 
HaskellParser.NtgtyconContext = NtgtyconContext; 
HaskellParser.OqtyconContext = OqtyconContext; 
HaskellParser.QtyconopContext = QtyconopContext; 
HaskellParser.QtyconContext = QtyconContext; 
HaskellParser.TyconContext = TyconContext; 
HaskellParser.QtyconsymContext = QtyconsymContext; 
HaskellParser.TyconsymContext = TyconsymContext; 
HaskellParser.OpContext = OpContext; 
HaskellParser.VaropContext = VaropContext; 
HaskellParser.QopContext = QopContext; 
HaskellParser.QopmContext = QopmContext; 
HaskellParser.Hole_opContext = Hole_opContext; 
HaskellParser.QvaropContext = QvaropContext; 
HaskellParser.QvaropmContext = QvaropmContext; 
HaskellParser.TyvarContext = TyvarContext; 
HaskellParser.TyvaropContext = TyvaropContext; 
HaskellParser.TyvaridContext = TyvaridContext; 
HaskellParser.TyclsContext = TyclsContext; 
HaskellParser.QtyclsContext = QtyclsContext; 
HaskellParser.Var_Context = Var_Context; 
HaskellParser.QvarContext = QvarContext; 
HaskellParser.QvaridContext = QvaridContext; 
HaskellParser.VaridContext = VaridContext; 
HaskellParser.QvarsymContext = QvarsymContext; 
HaskellParser.Qvarsym_no_minusContext = Qvarsym_no_minusContext; 
HaskellParser.VarsymContext = VarsymContext; 
HaskellParser.Varsym_no_minusContext = Varsym_no_minusContext; 
HaskellParser.Special_idContext = Special_idContext; 
HaskellParser.QconidContext = QconidContext; 
HaskellParser.ConidContext = ConidContext; 
HaskellParser.QconsymContext = QconsymContext; 
HaskellParser.ConsymContext = ConsymContext; 
HaskellParser.LiteralContext = LiteralContext; 
HaskellParser.Open_Context = Open_Context; 
HaskellParser.CloseContext = CloseContext; 
HaskellParser.SemiContext = SemiContext; 
HaskellParser.ModidContext = ModidContext; 
HaskellParser.CommasContext = CommasContext; 
HaskellParser.BarsContext = BarsContext; 
HaskellParser.SpecialContext = SpecialContext; 
HaskellParser.SymbolContext = SymbolContext; 
HaskellParser.AscSymbolContext = AscSymbolContext; 
HaskellParser.IntegerContext = IntegerContext; 
HaskellParser.PfloatContext = PfloatContext; 
HaskellParser.PcharContext = PcharContext; 
HaskellParser.PstringContext = PstringContext; 
